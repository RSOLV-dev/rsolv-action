apiVersion: v1
kind: ConfigMap
metadata:
  name: webhook-receiver-script
  namespace: monitoring
data:
  webhook-server.py: |
    #!/usr/bin/env python3
    import json
    import smtplib
    from email.mime.text import MIMEText
    from email.mime.multipart import MIMEMultipart
    from http.server import HTTPServer, BaseHTTPRequestHandler
    from datetime import datetime, timedelta
    import logging
    from threading import Lock

    logging.basicConfig(level=logging.INFO)
    logger = logging.getLogger(__name__)

    # Email config
    SMTP_HOST = 'smtp.postmarkapp.com'
    SMTP_PORT = 587
    SMTP_USER = SMTP_PASS = '82dfc287-055a-4e27-a8f2-3f7c412a1f89'
    FROM_EMAIL = 'alerts@rsolv.dev'
    TO_EMAIL = 'admin@rsolv.dev'

    # Throttle: min 5 minutes between identical emails
    sent_times = {}
    sent_lock = Lock()
    THROTTLE_WINDOW = timedelta(minutes=5)

    class WebhookHandler(BaseHTTPRequestHandler):
        def do_POST(self):
            try:
                data = json.loads(self.rfile.read(int(self.headers['Content-Length'])))
                logger.info(f"Received {len(data.get('alerts', []))} alerts")

                for alert in data.get('alerts', []):
                    if alert['status'] == 'resolved' and alert['labels'].get('alertname') == 'RSOLVMainSiteDown':
                        alert_key = f"{alert['labels']['alertname']}:{alert['labels'].get('instance', 'Unknown')}"

                        if self.should_send(alert_key):
                            self.send_recovery_email(alert)
                        else:
                            logger.info(f"Throttled: {alert_key}")

                self.send_response(200)
                self.end_headers()
                self.wfile.write(b'OK')
            except Exception as e:
                logger.error(f"Error: {e}")
                self.send_response(500)
                self.end_headers()

        def should_send(self, key):
            with sent_lock:
                now = datetime.now()
                if key in sent_times and now - sent_times[key] < THROTTLE_WINDOW:
                    return False
                sent_times[key] = now
                return True
        
        def send_recovery_email(self, alert):
            name = alert['labels'].get('alertname', 'Unknown')
            instance = alert['labels'].get('instance', 'Unknown')

            # Calculate downtime
            start = datetime.fromisoformat(alert['startsAt'].replace('Z', '+00:00'))
            end = datetime.fromisoformat(alert['endsAt'].replace('Z', '+00:00'))
            minutes = int((end - start).total_seconds() / 60)

            text = f"""RSOLV Site RECOVERED

Alert: {name}
Instance: {instance}
Downtime: {minutes} minutes
Started: {start.strftime('%Y-%m-%d %H:%M UTC')}
Recovered: {end.strftime('%Y-%m-%d %H:%M UTC')}

Dashboard: https://grafana.rsolv.dev/d/rsolv-uptime/rsolv-platform-uptime"""

            html = f"""<html><body>
<h2>✅ RSOLV Site RECOVERED</h2>
<p><strong>Alert:</strong> {name}<br>
<strong>Instance:</strong> {instance}<br>
<strong>Downtime:</strong> {minutes} minutes<br>
<strong>Started:</strong> {start.strftime('%Y-%m-%d %H:%M UTC')}<br>
<strong>Recovered:</strong> {end.strftime('%Y-%m-%d %H:%M UTC')}</p>
<p><a href="https://grafana.rsolv.dev/d/rsolv-uptime/rsolv-platform-uptime">View Dashboard</a></p>
</body></html>"""

            try:
                msg = MIMEMultipart('alternative')
                msg['Subject'] = f"✅ RECOVERED: {name}"
                msg['From'] = FROM_EMAIL
                msg['To'] = TO_EMAIL
                msg.attach(MIMEText(text, 'plain'))
                msg.attach(MIMEText(html, 'html'))

                with smtplib.SMTP(SMTP_HOST, SMTP_PORT) as server:
                    server.starttls()
                    server.login(SMTP_USER, SMTP_PASS)
                    server.send_message(msg)

                logger.info(f"Sent recovery email: {name} - {instance}")
            except Exception as e:
                logger.error(f"Failed to send email: {e}")

        def log_message(self, *args):
            pass  # Suppress HTTP logs

    if __name__ == '__main__':
        server_address = ('', 8080)
        httpd = HTTPServer(server_address, WebhookHandler)
        logger.info('Webhook receiver listening on port 8080...')
        httpd.serve_forever()

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: webhook-receiver
  namespace: monitoring
spec:
  replicas: 1
  selector:
    matchLabels:
      app: webhook-receiver
  template:
    metadata:
      labels:
        app: webhook-receiver
    spec:
      containers:
      - name: webhook-receiver
        image: python:3.9-slim
        command: ["python", "/app/webhook-server.py"]
        ports:
        - containerPort: 8080
        volumeMounts:
        - name: script
          mountPath: /app
      volumes:
      - name: script
        configMap:
          name: webhook-receiver-script
          defaultMode: 0755

---
apiVersion: v1
kind: Service
metadata:
  name: webhook-receiver
  namespace: monitoring
spec:
  selector:
    app: webhook-receiver
  ports:
  - port: 80
    targetPort: 8080
    protocol: TCP