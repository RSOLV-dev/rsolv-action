apiVersion: v1
kind: ConfigMap
metadata:
  name: webhook-receiver-script
  namespace: monitoring
data:
  webhook-server.py: |
    #!/usr/bin/env python3
    import json
    import smtplib
    from email.mime.text import MIMEText
    from email.mime.multipart import MIMEMultipart
    from http.server import HTTPServer, BaseHTTPRequestHandler
    from datetime import datetime
    import os
    import logging

    # Configure logging
    logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
    logger = logging.getLogger(__name__)

    # Email configuration
    SMTP_HOST = 'smtp.postmarkapp.com'
    SMTP_PORT = 587
    SMTP_USER = '82dfc287-055a-4e27-a8f2-3f7c412a1f89'
    SMTP_PASS = '82dfc287-055a-4e27-a8f2-3f7c412a1f89'
    FROM_EMAIL = 'alerts@rsolv.dev'
    TO_EMAIL = 'admin@rsolv.dev'

    class WebhookHandler(BaseHTTPRequestHandler):
        def do_POST(self):
            content_length = int(self.headers['Content-Length'])
            post_data = self.rfile.read(content_length)
            
            try:
                data = json.loads(post_data.decode('utf-8'))
                logger.info(f"Received webhook: {json.dumps(data, indent=2)}")
                
                # Process alerts
                for alert in data.get('alerts', []):
                    if alert['status'] == 'resolved':
                        self.send_recovery_email(alert, data)
                
                self.send_response(200)
                self.end_headers()
                self.wfile.write(b'OK')
            except Exception as e:
                logger.error(f"Error processing webhook: {e}")
                self.send_response(500)
                self.end_headers()
                self.wfile.write(str(e).encode())
        
        def send_recovery_email(self, alert, data):
            alert_name = alert['labels'].get('alertname', 'Unknown')
            instance = alert['labels'].get('instance', 'Unknown')
            
            # Only send recovery emails for critical site down alerts
            if alert_name != 'RSOLVMainSiteDown':
                return
            
            subject = f"✅ RECOVERED: {alert_name}"
            
            # Calculate downtime
            starts_at = datetime.fromisoformat(alert['startsAt'].replace('Z', '+00:00'))
            ends_at = datetime.fromisoformat(alert['endsAt'].replace('Z', '+00:00'))
            downtime = ends_at - starts_at
            downtime_minutes = int(downtime.total_seconds() / 60)
            
            html_body = f"""
            <html>
                <body>
                    <h2>✅ RSOLV Site has RECOVERED!</h2>
                    <p><strong>Alert:</strong> {alert_name}</p>
                    <p><strong>Instance:</strong> {instance}</p>
                    <p><strong>Status:</strong> RESOLVED ✅</p>
                    <p><strong>Downtime Duration:</strong> {downtime_minutes} minutes</p>
                    <p><strong>Started at:</strong> {starts_at.strftime('%Y-%m-%d %H:%M:%S UTC')}</p>
                    <p><strong>Recovered at:</strong> {ends_at.strftime('%Y-%m-%d %H:%M:%S UTC')}</p>
                    <p><a href="https://grafana.rsolv.dev/d/rsolv-uptime/rsolv-platform-uptime">View Dashboard</a></p>
                </body>
            </html>
            """
            
            text_body = f"""
            RSOLV Site has RECOVERED!
            
            Alert: {alert_name}
            Instance: {instance}
            Status: RESOLVED
            Downtime Duration: {downtime_minutes} minutes
            Started at: {starts_at.strftime('%Y-%m-%d %H:%M:%S UTC')}
            Recovered at: {ends_at.strftime('%Y-%m-%d %H:%M:%S UTC')}
            
            View Dashboard: https://grafana.rsolv.dev/d/rsolv-uptime/rsolv-platform-uptime
            """
            
            try:
                msg = MIMEMultipart('alternative')
                msg['Subject'] = subject
                msg['From'] = FROM_EMAIL
                msg['To'] = TO_EMAIL
                
                msg.attach(MIMEText(text_body, 'plain'))
                msg.attach(MIMEText(html_body, 'html'))
                
                with smtplib.SMTP(SMTP_HOST, SMTP_PORT) as server:
                    server.starttls()
                    server.login(SMTP_USER, SMTP_PASS)
                    server.send_message(msg)
                
                logger.info(f"Recovery email sent for {alert_name} - {instance}")
            except Exception as e:
                logger.error(f"Failed to send recovery email: {e}")
        
        def log_message(self, format, *args):
            # Suppress default access logs
            pass

    if __name__ == '__main__':
        server_address = ('', 8080)
        httpd = HTTPServer(server_address, WebhookHandler)
        logger.info('Webhook receiver listening on port 8080...')
        httpd.serve_forever()

---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: webhook-receiver
  namespace: monitoring
spec:
  replicas: 1
  selector:
    matchLabels:
      app: webhook-receiver
  template:
    metadata:
      labels:
        app: webhook-receiver
    spec:
      containers:
      - name: webhook-receiver
        image: python:3.9-slim
        command: ["python", "/app/webhook-server.py"]
        ports:
        - containerPort: 8080
        volumeMounts:
        - name: script
          mountPath: /app
      volumes:
      - name: script
        configMap:
          name: webhook-receiver-script
          defaultMode: 0755

---
apiVersion: v1
kind: Service
metadata:
  name: webhook-receiver
  namespace: monitoring
spec:
  selector:
    app: webhook-receiver
  ports:
  - port: 80
    targetPort: 8080
    protocol: TCP