defmodule Rsolv.Security.Patterns.Php.XxeVulnerability do
  @moduledoc """
  Pattern for detecting XML External Entity (XXE) vulnerabilities in PHP.
  
  This pattern identifies when PHP XML parsing functions like simplexml_load_string()
  or DOMDocument->loadXML() are used with user-controlled input without proper
  security measures, potentially leading to XXE attacks.
  
  ## Vulnerability Details
  
  XXE (XML External Entity) injection is a web security vulnerability that allows
  attackers to interfere with an application's processing of XML data. It occurs
  when XML input containing external entity references is processed by a weakly
  configured XML parser.
  
  ### Attack Example
  ```php
  // Vulnerable code - user controls XML content
  $xml = simplexml_load_string($_POST['xml_data']);
  
  // Malicious XML payload:
  // <!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]>
  // <root>&xxe;</root>
  ```
  
  The attack exploits XML's external entity feature to read local files,
  perform SSRF attacks, or cause denial of service through entity expansion.
  """
  
  use Rsolv.Security.Patterns.PatternBase
  alias Rsolv.Security.Pattern
  
  @impl true
  def pattern do
    %Pattern{
      id: "php-xxe-vulnerability",
      name: "XML External Entity (XXE) Vulnerability",
      description: "Processing XML without disabling external entities",
      type: :xxe,
      severity: :high,
      languages: ["php"],
      regex: ~r/(simplexml_load_string\s*\([^)]*\$_(GET|POST|REQUEST|COOKIE|FILES)|->loadXML\s*\([^)]*\$_(GET|POST|REQUEST|COOKIE|FILES))/,
      cwe_id: "CWE-611",
      owasp_category: "A05:2021",
      recommendation: "Disable external entity loading with libxml_disable_entity_loader(true)",
      test_cases: %{
        vulnerable: [
          ~S|$xml = simplexml_load_string($_POST['xml']);|,
          ~S|$doc->loadXML($_POST['data']);|,
          ~S|$dom = new DOMDocument(); $dom->loadXML($_GET['xml']);|,
          ~S|$result = simplexml_load_string($_REQUEST['content']);|
        ],
        safe: [
          ~S|$xml = simplexml_load_string($safe_data, 'SimpleXMLElement', LIBXML_NOCDATA);|,
          ~S|$data = json_decode($_POST['data'], true);|,
          ~S|$xml = simplexml_load_file('config.xml');|
        ]
      }
    }
  end
  
  @impl true
  def vulnerability_metadata do
    %{
      description: """
      XML External Entity (XXE) injection is a critical web security vulnerability that
      allows attackers to interfere with an application's processing of XML data. The
      vulnerability occurs when XML input containing references to external entities
      is processed by a weakly configured XML parser, enabling various attacks including
      local file disclosure, server-side request forgery (SSRF), and denial of service.
      
      PHP's XML parsing functions are particularly vulnerable because they enable
      external entity processing by default in many configurations. This creates
      significant security risks when processing untrusted XML input from users.
      
      ### Understanding XML External Entities
      
      XML external entities are a feature of the XML specification that allows
      documents to reference external resources. While this feature has legitimate
      uses, it becomes a security vulnerability when processing untrusted input.
      
      ### Attack Mechanics
      
      XXE attacks typically follow this pattern:
      1. **Entity Declaration**: Attacker defines external entities in XML DOCTYPE
      2. **Entity Reference**: XML content references the declared entities  
      3. **Parser Processing**: XML parser resolves external references
      4. **Data Exfiltration**: Results are returned to the attacker
      
      ### Common Attack Vectors
      
      #### File Disclosure
      ```xml
      <!DOCTYPE attack [<!ENTITY xxe SYSTEM "file:///etc/passwd">]>
      <root>&xxe;</root>
      ```
      
      #### Server-Side Request Forgery (SSRF)
      ```xml
      <!DOCTYPE attack [<!ENTITY xxe SYSTEM "http://internal.server/admin">]>
      <root>&xxe;</root>
      ```
      
      #### Denial of Service (Billion Laughs)
      ```xml
      <!DOCTYPE lolz [
        <!ENTITY lol "lol">
        <!ENTITY lol2 "&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;">
        <!ENTITY lol3 "&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;">
        <!-- ...more levels... -->
      ]>
      <lolz>&lol9;</lolz>
      ```
      """,
      references: [
        %{
          type: :cwe,
          id: "CWE-611",
          title: "Improper Restriction of XML External Entity Reference",
          url: "https://cwe.mitre.org/data/definitions/611.html"
        },
        %{
          type: :owasp,
          id: "A05:2021",
          title: "OWASP Top 10 2021 - A05 Security Misconfiguration",
          url: "https://owasp.org/Top10/A05_2021-Security_Misconfiguration/"
        },
        %{
          type: :owasp,
          id: "xxe_processing",
          title: "OWASP XXE Processing",
          url: "https://owasp.org/www-community/vulnerabilities/XML_External_Entity_(XXE)_Processing"
        },
        %{
          type: :owasp,
          id: "xxe_prevention",
          title: "OWASP XXE Prevention Cheat Sheet",
          url: "https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html"
        },
        %{
          type: :research,
          id: "portswigger_xxe",
          title: "XML external entity (XXE) injection - PortSwigger",
          url: "https://portswigger.net/web-security/xxe"
        }
      ],
      attack_vectors: [
        "Local file disclosure via file:// protocol URIs",
        "Remote file inclusion via http:// and https:// URIs", 
        "Server-side request forgery (SSRF) to internal services",
        "Denial of service through recursive entity expansion (Billion Laughs)",
        "Port scanning of internal network infrastructure",
        "Authentication bypass via internal API access",
        "Information disclosure through error messages",
        "Out-of-band data exfiltration via DNS or HTTP requests"
      ],
      real_world_impact: [
        "Complete server file system disclosure including configuration files",
        "Database credentials and API keys exposed through config files",
        "Internal network reconnaissance and service enumeration",
        "SSRF attacks against internal applications and microservices",
        "Cloud metadata service access (AWS, Azure, GCP credentials)",
        "Application and server denial of service",
        "Sensitive business data exfiltration",
        "Compliance violations (GDPR, HIPAA, PCI-DSS) due to data exposure"
      ],
      cve_examples: [
        %{
          id: "CVE-2023-3823",
          description: "XXE injection in PHP versions 8.0.* before 8.0.30, 8.1.* before 8.1.22, and 8.2.* before 8.2.8",
          severity: "high",
          cvss: 7.5,
          note: "Local file disclosure vulnerability in PHP's XML parsing functions"
        },
        %{
          id: "CVE-2024-40075",
          description: "XXE injection in Laravel framework allowing file disclosure",
          severity: "high",
          cvss: 7.7,
          note: "Framework-level vulnerability affecting XML processing components"
        },
        %{
          id: "CVE-2018-1000124",
          description: "XXE vulnerability in I-librarian via simplexml_load_string",
          severity: "medium",
          cvss: 6.5,
          note: "Classic example of vulnerable simplexml_load_string usage"
        },
        %{
          id: "CVE-2024-48917",
          description: "XXE bypass in PhpSpreadsheet XmlScanner class",
          severity: "high",
          cvss: 8.2,
          note: "Bypass of previous XXE protections in popular PHP library"
        },
        %{
          id: "CVE-2024-45293",
          description: "XXE in PHPSpreadsheet Excel parser allowing information disclosure",
          severity: "medium",
          cvss: 6.8,
          note: "Information disclosure through XXE in Excel file processing"
        }
      ],
      detection_notes: """
      This pattern detects XXE vulnerabilities by identifying:
      - simplexml_load_string() function calls with user input parameters
      - DOMDocument->loadXML() method calls with user-controlled data
      - XML parsing functions that process superglobal variables ($_GET, $_POST, etc.)
      - Common patterns where XML content comes from user input sources
      
      The regex looks for:
      - Function/method patterns that indicate XML parsing
      - Direct access to user input superglobals
      - Method chaining patterns common with DOMDocument usage
      
      False positives may occur when:
      - XML parsing is performed on validated/trusted internal data
      - External entity loading is properly disabled before parsing
      - Input validation and sanitization are performed before XML processing
      - Safe parsing options like LIBXML_NOCDATA are used consistently
      """,
      safe_alternatives: [
        "Use libxml_disable_entity_loader(true) before XML parsing",
        "Parse with LIBXML_NOCDATA flag to disable entity processing",
        "Use JSON format instead of XML for data exchange when possible",
        "Validate XML against a strict schema (XSD) before processing",
        "Use XML parsing libraries with secure defaults (e.g., XMLReader with restrictions)",
        "Implement input validation to reject XML with DOCTYPE declarations",
        "Use allowlist-based filtering for acceptable XML content",
        "Process XML in sandboxed environments with limited file system access"
      ],
      additional_context: %{
        common_mistakes: [
          "Believing that input validation alone prevents XXE attacks",
          "Using simplexml_load_string() with LIBXML_NOENT flag (enables entity processing)",
          "Thinking that HTTPS sources for external entities are safe",
          "Assuming that XML from 'trusted' sources doesn't need XXE protection",
          "Using DOMDocument without explicitly disabling external entity loading",
          "Processing XML files uploaded by users without XXE safeguards"
        ],
        secure_patterns: [
          "libxml_disable_entity_loader(true) before any XML parsing",
          "simplexml_load_string($xml, 'SimpleXMLElement', LIBXML_NOCDATA)",
          "DOMDocument with resolveExternals and substituteEntities set to false",
          "Input validation to reject XML containing DOCTYPE declarations",
          "Use of XMLReader with proper configuration for large XML files"
        ],
        php_version_notes: [
          "PHP 5.6 and earlier: External entity loading enabled by default",
          "PHP 7.0+: Some improvements but still vulnerable without proper configuration",
          "PHP 8.0+: Enhanced security but requires explicit protection measures",
          "libxml2 version affects available security options",
          "LIBXML_NOCDATA prevents most XXE attacks when used consistently"
        ],
        framework_considerations: [
          "Laravel: Provides some XXE protection but custom XML parsing is vulnerable",
          "Symfony: XMLUtils component has built-in XXE protection",
          "WordPress: XML-RPC and import functions historically vulnerable",
          "Drupal: Core XML processing generally protected but contrib modules vary",
          "CodeIgniter: No built-in XXE protection, requires manual safeguards"
        ]
      }
    }
  end
  
  @doc """
  Returns test cases for the pattern.
  
  ## Examples
  
      iex> test_cases = Rsolv.Security.Patterns.Php.XxeVulnerability.test_cases()
      iex> length(test_cases.positive) > 0
      true
      
      iex> test_cases = Rsolv.Security.Patterns.Php.XxeVulnerability.test_cases()
      iex> length(test_cases.negative) > 0
      true
      
      iex> pattern = Rsolv.Security.Patterns.Php.XxeVulnerability.pattern()
      iex> pattern.id
      "php-xxe-vulnerability"
  """
  def test_cases do
    %{
      positive: [
        %{
          code: ~S|$xml = simplexml_load_string($_POST['xml']);|,
          description: "Basic simplexml_load_string with POST data"
        },
        %{
          code: ~S|$data = simplexml_load_string($_GET['data']);|,
          description: "GET parameter XML processing"
        },
        %{
          code: ~S|$config = simplexml_load_string($_REQUEST['config']);|,
          description: "REQUEST superglobal processing"
        },
        %{
          code: ~S|$dom = new DOMDocument(); $dom->loadXML($_POST['xml']);|,
          description: "DOMDocument loadXML with user input"
        },
        %{
          code: ~S|$doc->loadXML($_GET['data']);|,
          description: "Direct loadXML call on existing DOMDocument"
        },
        %{
          code: ~S|$parser = new DOMDocument(); $result = $parser->loadXML($_COOKIE['xml']);|,
          description: "Cookie-based XML input"
        },
        %{
          code: ~S|simplexml_load_string($_REQUEST['content']);|,
          description: "Direct function call without assignment"
        },
        %{
          code: ~S|$document = new DOMDocument(); $success = $document->loadXML($_POST['import']);|,
          description: "Assignment of loadXML result"
        }
      ],
      negative: [
        %{
          code: ~S|$xml = simplexml_load_string($safe_data);|,
          description: "Internal variable XML processing"
        },
        %{
          code: ~S|libxml_disable_entity_loader(true); $xml = simplexml_load_string($_POST['xml']);|,
          description: "Protected XML parsing with disabled entities"
        },
        %{
          code: ~S|$xml = simplexml_load_string($content, 'SimpleXMLElement', LIBXML_NOCDATA);|,
          description: "Secure parsing with LIBXML_NOCDATA flag"
        },
        %{
          code: ~S|$data = json_decode($_POST['data'], true);|,
          description: "JSON parsing instead of XML"
        },
        %{
          code: ~S|$dom = new DOMDocument(); $dom->resolveExternals = false; $dom->loadXML($internal_xml);|,
          description: "DOMDocument with disabled external resolution"
        },
        %{
          code: ~S|function simplexml_load_string_safe($data) { return simplexml_load_string($data); }|,
          description: "Function name containing XML parsing function"
        },
        %{
          code: ~S|$validated_xml = validateXML($_POST['xml']); $result = simplexml_load_string($validated_xml);|,
          description: "Validated input before XML parsing"
        }
      ]
    }
  end
  
  @doc """
  Returns examples of vulnerable and fixed code.
  """
  def examples do
    %{
      vulnerable: %{
        "XML Configuration Import" => ~S"""
        // Configuration import - VULNERABLE
        if ($_POST['action'] == 'import_config') {
            $xml_config = $_POST['config_xml'];
            
            // Parse XML directly from user input
            $config = simplexml_load_string($xml_config);
            
            foreach ($config->setting as $setting) {
                $key = (string)$setting['name'];
                $value = (string)$setting['value'];
                updateConfigValue($key, $value);
            }
            
            echo "Configuration imported successfully";
        }
        
        // XXE Payload can read files:
        // <!DOCTYPE config [<!ENTITY xxe SYSTEM "file:///etc/passwd">]>
        // <config><setting name="test" value="&xxe;"/></config>
        """,
        "Document Processing" => ~S"""
        // Document upload processing - VULNERABLE
        class DocumentProcessor {
            public function processUpload() {
                if (isset($_FILES['document'])) {
                    $xml_content = file_get_contents($_FILES['document']['tmp_name']);
                    
                    // Process XML document without protection
                    $dom = new DOMDocument();
                    $dom->loadXML($xml_content);
                    
                    $title = $dom->getElementsByTagName('title')->item(0)->nodeValue;
                    $content = $dom->getElementsByTagName('content')->item(0)->nodeValue;
                    
                    return [
                        'title' => $title,
                        'content' => $content
                    ];
                }
            }
        }
        
        // Attacker uploads XML file with XXE payload
        """,
        "API Endpoint" => ~S"""
        // REST API endpoint - VULNERABLE
        if ($_SERVER['REQUEST_METHOD'] === 'POST' && $_SERVER['CONTENT_TYPE'] === 'application/xml') {
            $xml_input = file_get_contents('php://input');
            
            // Parse XML from raw POST body
            $data = simplexml_load_string($xml_input);
            
            $user_id = (string)$data->user_id;
            $action = (string)$data->action;
            $parameters = (array)$data->parameters;
            
            processAPIRequest($user_id, $action, $parameters);
        }
        
        // API accepts XML with potential XXE payloads
        """,
        "RSS Feed Parser" => ~S"""
        // RSS feed parsing - VULNERABLE
        function parseRSSFeed($feed_url) {
            // Get RSS content (could be user-controlled URL)
            $rss_content = file_get_contents($feed_url);
            
            // Parse RSS XML directly
            $rss = simplexml_load_string($rss_content);
            
            $items = [];
            foreach ($rss->channel->item as $item) {
                $items[] = [
                    'title' => (string)$item->title,
                    'description' => (string)$item->description,
                    'link' => (string)$item->link
                ];
            }
            
            return $items;
        }
        
        // If $feed_url is user-controlled, XXE is possible
        """
      },
      fixed: %{
        "Disable external entities" => ~S"""
        // Configuration import - SECURE
        if ($_POST['action'] == 'import_config') {
            $xml_config = $_POST['config_xml'];
            
            // Disable external entity loading BEFORE parsing
            libxml_disable_entity_loader(true);
            
            // Parse XML with additional security flags
            $config = simplexml_load_string(
                $xml_config, 
                'SimpleXMLElement', 
                LIBXML_NOCDATA | LIBXML_NOENT
            );
            
            if ($config === false) {
                die('Invalid XML format');
            }
            
            foreach ($config->setting as $setting) {
                $key = (string)$setting['name'];
                $value = (string)$setting['value'];
                
                // Validate configuration keys and values
                if (isValidConfigKey($key) && isValidConfigValue($value)) {
                    updateConfigValue($key, $value);
                }
            }
            
            echo "Configuration imported successfully";
        }
        """,
        "DOMDocument with security" => ~S"""
        // Document upload processing - SECURE
        class SecureDocumentProcessor {
            public function processUpload() {
                if (isset($_FILES['document'])) {
                    $xml_content = file_get_contents($_FILES['document']['tmp_name']);
                    
                    // Create DOM with security settings
                    $dom = new DOMDocument();
                    $dom->resolveExternals = false;
                    $dom->substituteEntities = false;
                    
                    // Disable external entity loading
                    libxml_disable_entity_loader(true);
                    
                    // Load XML with secure options
                    $result = $dom->loadXML(
                        $xml_content, 
                        LIBXML_NOCDATA | LIBXML_NONET
                    );
                    
                    if (!$result) {
                        throw new Exception('Invalid XML document');
                    }
                    
                    // Validate against schema if needed
                    if (!$this->validateXMLSchema($dom)) {
                        throw new Exception('XML does not match required schema');
                    }
                    
                    $title = $dom->getElementsByTagName('title')->item(0)?->nodeValue ?? '';
                    $content = $dom->getElementsByTagName('content')->item(0)?->nodeValue ?? '';
                    
                    return [
                        'title' => htmlspecialchars($title),
                        'content' => htmlspecialchars($content)
                    ];
                }
            }
            
            private function validateXMLSchema(DOMDocument $dom): bool {
                // Implement schema validation
                return $dom->schemaValidate('/path/to/schema.xsd');
            }
        }
        """,
        "Use JSON instead" => ~S"""
        // API endpoint - SECURE (JSON alternative)
        if ($_SERVER['REQUEST_METHOD'] === 'POST') {
            $content_type = $_SERVER['CONTENT_TYPE'] ?? '';
            
            if (str_contains($content_type, 'application/json')) {
                // Use JSON instead of XML
                $json_input = file_get_contents('php://input');
                $data = json_decode($json_input, true);
                
                if (json_last_error() !== JSON_ERROR_NONE) {
                    http_response_code(400);
                    echo json_encode(['error' => 'Invalid JSON']);
                    exit;
                }
                
                // Validate required fields
                if (!isset($data['user_id'], $data['action'])) {
                    http_response_code(400);
                    echo json_encode(['error' => 'Missing required fields']);
                    exit;
                }
                
                $user_id = filter_var($data['user_id'], FILTER_VALIDATE_INT);
                $action = filter_var($data['action'], FILTER_SANITIZE_STRING);
                $parameters = $data['parameters'] ?? [];
                
                if ($user_id === false) {
                    http_response_code(400);
                    echo json_encode(['error' => 'Invalid user_id']);
                    exit;
                }
                
                processAPIRequest($user_id, $action, $parameters);
            } else {
                http_response_code(415);
                echo json_encode(['error' => 'Unsupported content type']);
            }
        }
        """,
        "XMLReader for large files" => ~S"""
        // Large XML processing - SECURE
        function parseRSSFeedSecure($feed_url) {
            // Validate URL is from trusted source
            $allowed_hosts = ['feeds.example.com', 'rss.trusted.com'];
            $host = parse_url($feed_url, PHP_URL_HOST);
            
            if (!in_array($host, $allowed_hosts)) {
                throw new Exception('Untrusted RSS source');
            }
            
            // Get RSS content
            $rss_content = file_get_contents($feed_url);
            
            if ($rss_content === false) {
                throw new Exception('Failed to fetch RSS feed');
            }
            
            // Use XMLReader for large files (more secure)
            $reader = new XMLReader();
            
            // Disable external entity loading
            libxml_disable_entity_loader(true);
            
            // Open XML string with secure options
            if (!$reader->XML($rss_content, 'UTF-8', LIBXML_NOCDATA | LIBXML_NONET)) {
                throw new Exception('Failed to parse XML');
            }
            
            $items = [];
            
            // Process XML safely
            while ($reader->read()) {
                if ($reader->nodeType === XMLReader::ELEMENT && $reader->localName === 'item') {
                    $item_xml = $reader->readOuterXML();
                    
                    // Parse individual item with security
                    $item = simplexml_load_string(
                        $item_xml, 
                        'SimpleXMLElement', 
                        LIBXML_NOCDATA | LIBXML_NONET
                    );
                    
                    if ($item !== false) {
                        $items[] = [
                            'title' => htmlspecialchars((string)$item->title),
                            'description' => htmlspecialchars((string)$item->description),
                            'link' => filter_var((string)$item->link, FILTER_VALIDATE_URL)
                        ];
                    }
                }
            }
            
            $reader->close();
            return $items;
        }
        """
      }
    }
  end
  
  @doc """
  Returns detailed vulnerability description.
  """
  def vulnerability_description do
    """
    XML External Entity (XXE) injection is a critical web security vulnerability that
    allows attackers to interfere with an application's processing of XML data. This
    vulnerability can lead to serious security breaches including local file disclosure,
    server-side request forgery (SSRF), and denial of service attacks.
    
    ## Understanding XXE Attacks
    
    ### The XML External Entity Feature
    
    XML external entities are a legitimate feature of XML that allows documents to
    reference external resources. However, when processing untrusted XML input,
    this feature becomes a significant security vulnerability.
    
    ```xml
    <!DOCTYPE root [
      <!ENTITY external_entity SYSTEM "file:///etc/passwd">
    ]>
    <root>&external_entity;</root>
    ```
    
    When an XML parser processes this document, it will:
    1. Read the external entity definition
    2. Fetch the content from file:///etc/passwd
    3. Include that content in the document
    4. Return the sensitive file contents to the attacker
    
    ### PHP's XML Parsing Vulnerabilities
    
    PHP provides several functions for XML parsing, many of which are vulnerable
    to XXE attacks by default:
    
    #### simplexml_load_string()
    ```php
    // VULNERABLE - processes external entities by default
    $xml = simplexml_load_string($_POST['xml']);
    
    // SECURE - disable entity processing
    libxml_disable_entity_loader(true);
    $xml = simplexml_load_string($_POST['xml'], 'SimpleXMLElement', LIBXML_NOCDATA);
    ```
    
    #### DOMDocument->loadXML()
    ```php
    // VULNERABLE - external entities enabled
    $dom = new DOMDocument();
    $dom->loadXML($_POST['xml']);
    
    // SECURE - disable external processing
    $dom = new DOMDocument();
    $dom->resolveExternals = false;
    $dom->substituteEntities = false;
    libxml_disable_entity_loader(true);
    $dom->loadXML($_POST['xml'], LIBXML_NOCDATA | LIBXML_NONET);
    ```
    
    ## Attack Scenarios
    
    ### Local File Disclosure
    
    The most common XXE attack reads sensitive files from the server:
    
    ```xml
    <!DOCTYPE attack [
      <!ENTITY xxe SYSTEM "file:///etc/passwd">
    ]>
    <data>&xxe;</data>
    ```
    
    This can expose:
    - System configuration files (/etc/passwd, /etc/hosts)
    - Application configuration files (database credentials, API keys)
    - Source code files
    - Log files containing sensitive information
    
    ### Server-Side Request Forgery (SSRF)
    
    XXE can be used to make requests to internal services:
    
    ```xml
    <!DOCTYPE attack [
      <!ENTITY xxe SYSTEM "http://internal-admin.company.com/admin">
    ]>
    <data>&xxe;</data>
    ```
    
    This enables:
    - Access to internal APIs and admin interfaces
    - Port scanning of internal networks
    - Cloud metadata service access (AWS, Azure, GCP)
    - Bypass of network security controls
    
    ### Denial of Service (Billion Laughs Attack)
    
    XXE can cause resource exhaustion through entity expansion:
    
    ```xml
    <!DOCTYPE lolz [
      <!ENTITY lol "lol">
      <!ENTITY lol2 "&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;">
      <!ENTITY lol3 "&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;">
      <!ENTITY lol4 "&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;">
    ]>
    <lolz>&lol4;</lolz>
    ```
    
    This can cause:
    - Memory exhaustion
    - CPU consumption
    - Application crashes
    - Server downtime
    
    ## Real-World Impact
    
    ### Historical Vulnerabilities
    
    - **CVE-2023-3823**: PHP core XXE vulnerability affecting multiple versions
    - **CVE-2024-40075**: Laravel framework XXE allowing file disclosure
    - **CVE-2018-1000124**: I-librarian application vulnerable to XXE
    - **CVE-2024-48917**: PhpSpreadsheet XXE bypass vulnerability
    
    ### Common Vulnerable Scenarios
    
    1. **File Upload Processing**: XML files uploaded by users
    2. **API Endpoints**: REST APIs accepting XML input
    3. **Configuration Import**: Admin interfaces importing XML settings
    4. **RSS/Feed Parsing**: Processing external RSS or Atom feeds
    5. **Document Processing**: Office documents with XML components
    6. **Web Services**: SOAP and XML-RPC endpoints
    
    ## Prevention Strategies
    
    ### Immediate Protection
    
    1. **Disable External Entity Loading**
    ```php
    libxml_disable_entity_loader(true);
    ```
    
    2. **Use Secure Parsing Flags**
    ```php
    $xml = simplexml_load_string($input, 'SimpleXMLElement', LIBXML_NOCDATA | LIBXML_NONET);
    ```
    
    3. **Configure DOMDocument Securely**
    ```php
    $dom = new DOMDocument();
    $dom->resolveExternals = false;
    $dom->substituteEntities = false;
    ```
    
    ### Best Practices
    
    1. **Use JSON Instead of XML** when possible
    2. **Validate Input** against strict schemas before parsing
    3. **Sanitize Output** even from trusted XML sources
    4. **Implement Access Controls** on file system and network resources
    5. **Monitor and Log** XML processing activities
    6. **Regular Security Updates** for XML parsing libraries
    
    ### Framework-Specific Guidance
    
    - **Laravel**: Use built-in validation and avoid direct XML parsing
    - **Symfony**: Leverage XMLUtils component for secure parsing
    - **WordPress**: Be cautious with XML-RPC and import functionality
    - **Custom Applications**: Always disable external entities before parsing
    
    ## Testing for XXE Vulnerabilities
    
    ### Basic Test Payload
    ```xml
    <!DOCTYPE test [<!ENTITY xxe SYSTEM "file:///etc/hostname">]>
    <test>&xxe;</test>
    ```
    
    ### Advanced Testing
    - Use different protocols (file://, http://, ftp://)
    - Test various encoding schemes
    - Try parameter entities for blind XXE
    - Test error-based information disclosure
    
    Remember: XXE vulnerabilities can have severe consequences including complete
    server compromise. Always implement proper protections when processing XML data.
    """
  end
  
  @doc """
  Returns AST enhancement rules to reduce false positives.
  
  This enhancement helps distinguish between actual vulnerabilities and false positives
  by analyzing the context of XML parsing usage and checking for security measures.
  
  ## Examples
  
      iex> enhancement = Rsolv.Security.Patterns.Php.XxeVulnerability.ast_enhancement()
      iex> Map.keys(enhancement) |> Enum.sort()
      [:ast_rules, :min_confidence]
      
      iex> enhancement = Rsolv.Security.Patterns.Php.XxeVulnerability.ast_enhancement()
      iex> enhancement.min_confidence
      0.7
      
      iex> enhancement = Rsolv.Security.Patterns.Php.XxeVulnerability.ast_enhancement()
      iex> length(enhancement.ast_rules)
      4
  """
  @impl true
  def ast_enhancement do
    %{
      ast_rules: [
        %{
          type: "xml_parsing_functions",
          description: "PHP functions and methods that parse XML",
          functions: [
            "simplexml_load_string",
            "simplexml_load_file",
            "loadXML",
            "load",
            "xml_parse",
            "XMLReader::XML",
            "XMLReader::open"
          ],
          contexts: [
            "user_input_processing",
            "file_upload_handling", 
            "api_endpoint_processing",
            "configuration_import",
            "document_processing"
          ]
        },
        %{
          type: "xxe_mitigation",
          description: "Functions and settings that prevent XXE attacks",
          functions: [
            "libxml_disable_entity_loader",
            "libxml_set_external_entity_loader",
            "resolveExternals",
            "substituteEntities"
          ],
          flags: [
            "LIBXML_NOCDATA",
            "LIBXML_NOENT", 
            "LIBXML_NONET",
            "LIBXML_NOBLANKS"
          ]
        },
        %{
          type: "context_analysis",
          description: "Analyze usage context to determine vulnerability risk",
          high_risk_patterns: [
            "XML parsing with $_GET, $_POST, $_REQUEST, $_COOKIE",
            "file_get_contents() followed by XML parsing",
            "XML parsing in file upload handlers",
            "API endpoints processing raw XML input",
            "XML parsing without libxml protection"
          ],
          mitigation_indicators: [
            "libxml_disable_entity_loader called before parsing",
            "LIBXML_NOCDATA or LIBXML_NONET flags used",
            "DOMDocument with resolveExternals = false",
            "schema validation before XML processing",
            "input validation rejecting DOCTYPE declarations"
          ],
          false_positive_patterns: [
            "XML parsing of hardcoded strings",
            "XML parsing with validated internal data",
            "XML processing in unit tests",
            "configuration files with trusted XML",
            "XML parsing with comprehensive validation"
          ]
        },
        %{
          type: "input_source_analysis",
          description: "Identify sources of XML input data",
          dangerous_sources: [
            "$_GET",
            "$_POST",
            "$_REQUEST", 
            "$_COOKIE",
            "$_FILES",
            "file_get_contents('php://input')",
            "fopen() with user-controlled paths",
            "file_get_contents() with user URLs"
          ],
          safe_sources: [
            "hardcoded XML strings",
            "internal configuration files",
            "validated and sanitized input",
            "XML from trusted internal APIs",
            "database-stored XML with validation"
          ]
        }
      ],
      min_confidence: 0.7
    }
  end
end
