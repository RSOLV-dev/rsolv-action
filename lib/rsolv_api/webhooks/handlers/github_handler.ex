defmodule RsolvApi.Webhooks.Handlers.GitHubHandler do
  @moduledoc """
  Handles GitHub webhook events for pull requests and issues.
  Tracks PR creation and merge events for billing purposes.
  
  Identifies RSOLV PRs using multiple methods:
  - Label: rsolv:automated
  - Branch: rsolv/* prefix
  - Title: [RSOLV] prefix
  - Body: Various RSOLV text patterns
  """
  
  alias RsolvApi.Billing.FixAttempt
  alias RsolvApi.Repo
  import Ecto.Query
  require Logger

  # Multiple ways to identify RSOLV PRs
  @rsolv_identifiers %{
    label: "rsolv:automated",
    branch_prefix: "rsolv/",
    title_prefix: "[RSOLV]",
    body_patterns: [
      "automatically generated by [RSOLV]",
      "automatically generated by RSOLV",
      "Generated by RSOLV",
      "rsolv.dev"
    ]
  }

  def handle_event("pull_request", payload) do
    Logger.info("Handling pull_request event with action: #{inspect(payload["action"])}")
    
    case payload["action"] do
      "opened" -> handle_pr_opened(payload)
      "reopened" -> handle_pr_opened(payload)
      "closed" ->
        if payload["pull_request"]["merged"] do
          handle_pr_merged(payload)
        else
          handle_pr_rejected(payload)
        end
      _ -> {:ok, :ignored}
    end
  end

  def handle_event("issues", payload) do
    case payload["action"] do
      "closed" -> {:ok, :issue_closed}
      _ -> {:ok, :ignored}
    end
  end

  def handle_event(_, _), do: {:ok, :ignored}

  @doc """
  Extract issue number from various formats:
  - Fixes #123
  - Closes https://github.com/owner/repo/issues/456
  - Resolves owner/repo#789
  """
  def extract_issue_references(text) when is_binary(text) do
    references = []
    
    # GitHub keywords: fixes, closes, resolves
    keywords = ~w(fix fixes fixed close closes closed resolve resolves resolved)
    keyword_pattern = Enum.join(keywords, "|")
    
    # Pattern 1: fixes #123
    case Regex.scan(~r/(?:#{keyword_pattern})\s+#(\d+)/i, text) do
      matches when is_list(matches) ->
        references ++ Enum.map(matches, fn [_, num] -> 
          %{type: :number, value: String.to_integer(num)}
        end)
      _ -> references
    end
    
    # Pattern 2: fixes https://github.com/owner/repo/issues/123
    |> then(fn refs ->
      case Regex.scan(~r/(?:#{keyword_pattern})\s+https?:\/\/github\.com\/([^\/]+)\/([^\/]+)\/issues\/(\d+)/i, text) do
        matches when is_list(matches) ->
          refs ++ Enum.map(matches, fn [_, owner, repo, num] ->
            %{
              type: :url,
              owner: owner,
              repo: repo,
              value: String.to_integer(num)
            }
          end)
        _ -> refs
      end
    end)
    
    # Pattern 3: fixes owner/repo#123
    |> then(fn refs ->
      case Regex.scan(~r/(?:#{keyword_pattern})\s+([^\/\s]+)\/([^#\s]+)#(\d+)/i, text) do
        matches when is_list(matches) ->
          refs ++ Enum.map(matches, fn [_, owner, repo, num] ->
            %{
              type: :cross_repo,
              owner: owner,
              repo: repo,
              value: String.to_integer(num)
            }
          end)
        _ -> refs
      end
    end)
    
    # Fallback: any #123 or github.com/owner/repo/issues/123
    |> then(fn refs ->
      if Enum.empty?(refs) do
        # Try plain #123
        case Regex.run(~r/#(\d+)/, text) do
          [_, num] -> [%{type: :number, value: String.to_integer(num)}]
          _ ->
            # Try plain URL
            case Regex.run(~r/github\.com\/([^\/]+)\/([^\/]+)\/issues\/(\d+)/, text) do
              [_, owner, repo, num] ->
                [%{type: :url, owner: owner, repo: repo, value: String.to_integer(num)}]
              _ -> []
            end
        end
      else
        refs
      end
    end)
  end

  def extract_issue_references(_), do: []

  # Private functions

  defp handle_pr_opened(payload) do
    pr = payload["pull_request"]
    
    Logger.info("Evaluating PR: #{pr["title"]}")
    
    # Check if this is a RSOLV-generated PR using multiple methods
    if is_rsolv_pr?(pr) do
      Logger.info("Identified as RSOLV PR, tracking...")
      
      org = pr["base"]["repo"]["owner"]["login"]
      repo = pr["base"]["repo"]["name"]
      pr_number = pr["number"]
      
      # Extract all issue references
      issue_refs = extract_issue_references(pr["body"] || "")
      
      # Use the first reference or nil
      issue_number = case issue_refs do
        [%{value: num} | _] -> num
        _ -> nil
      end
      
      # Extract metadata
      metadata = %{
        branch: pr["head"]["ref"],
        labels: Enum.map(pr["labels"] || [], & &1["name"]),
        created_by: pr["user"]["login"],
        issue_references: issue_refs
      }
      
      # Create or update fix attempt
      case find_fix_attempt(org, repo, pr_number) do
        nil ->
          %FixAttempt{}
          |> FixAttempt.changeset(%{
            github_org: org,
            repo_name: repo,
            issue_number: issue_number,
            pr_number: pr_number,
            pr_title: pr["title"],
            pr_url: pr["html_url"],
            status: "pending",
            metadata: metadata
          })
          |> Repo.insert()
          
        existing ->
          # Update metadata if needed
          existing
          |> FixAttempt.changeset(%{metadata: metadata})
          |> Repo.update()
          
          {:ok, :already_exists}
      end
      
      {:ok, :pr_opened}
    else
      Logger.info("Not a RSOLV PR, ignoring")
      {:ok, :ignored}
    end
  end

  defp handle_pr_merged(payload) do
    pr = payload["pull_request"]
    org = pr["base"]["repo"]["owner"]["login"]
    repo = pr["base"]["repo"]["name"]
    pr_number = pr["number"]
    
    case find_fix_attempt(org, repo, pr_number) do
      nil -> {:ok, :not_tracked}
      fix_attempt ->
        fix_attempt
        |> FixAttempt.changeset(%{
          status: "merged",
          merged_at: pr["merged_at"] || DateTime.utc_now(),
          merged_by: pr["merged_by"] && pr["merged_by"]["login"],
          commit_sha: pr["merge_commit_sha"]
        })
        |> Repo.update()
        
        {:ok, :merged}
    end
  end

  defp handle_pr_rejected(payload) do
    pr = payload["pull_request"]
    org = pr["base"]["repo"]["owner"]["login"]
    repo = pr["base"]["repo"]["name"]
    pr_number = pr["number"]
    
    case find_fix_attempt(org, repo, pr_number) do
      nil -> {:ok, :not_tracked}
      fix_attempt ->
        fix_attempt
        |> FixAttempt.changeset(%{status: "rejected"})
        |> Repo.update()
        
        {:ok, :rejected}
    end
  end

  @doc """
  Check if a PR was generated by RSOLV using multiple identification methods.
  Returns true if ANY method matches.
  """
  def is_rsolv_pr?(pr) do
    # Method 1: Check labels
    has_label = pr["labels"] && Enum.any?(pr["labels"], fn label ->
      label["name"] == @rsolv_identifiers.label
    end)
    
    # Method 2: Check branch name
    has_branch = pr["head"] && pr["head"]["ref"] &&
      String.starts_with?(pr["head"]["ref"], @rsolv_identifiers.branch_prefix)
    
    # Method 3: Check title
    has_title = pr["title"] &&
      String.starts_with?(pr["title"], @rsolv_identifiers.title_prefix)
    
    # Method 4: Check body content
    has_body_pattern = pr["body"] && Enum.any?(@rsolv_identifiers.body_patterns, fn pattern ->
      String.contains?(pr["body"], pattern)
    end)
    
    # Log what we found
    Logger.debug("""
    RSOLV PR identification:
    - Has label: #{has_label}
    - Has branch prefix: #{has_branch}
    - Has title prefix: #{has_title}
    - Has body pattern: #{has_body_pattern}
    """)
    
    # Return true if ANY method matches (more flexible)
    # Ensure we always return a boolean, not nil
    !!(has_label || has_branch || has_title || has_body_pattern)
  end

  defp find_fix_attempt(org, repo, pr_number) do
    Repo.get_by(FixAttempt, 
      github_org: org,
      repo_name: repo,
      pr_number: pr_number
    )
  end
end