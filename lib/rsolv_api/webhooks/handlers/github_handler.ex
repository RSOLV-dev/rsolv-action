defmodule RsolvApi.Webhooks.Handlers.GitHubHandler do
  @moduledoc """
  Handles GitHub webhook events for pull requests and issues.
  Tracks PR creation and merge events for billing purposes.
  """

  alias RsolvApi.Billing.FixAttempt
  alias RsolvApi.Repo
  import Ecto.Query

  @doc """
  Handles GitHub webhook events
  """
  def handle_event("pull_request", payload) do
    case payload["action"] do
      "opened" ->
        handle_pr_opened(payload)
        
      "closed" ->
        if payload["pull_request"]["merged"] do
          handle_pr_merged(payload)
        else
          handle_pr_rejected(payload)
        end
        
      _ ->
        {:ok, :ignored}
    end
  end
  
  def handle_event("issues", payload) do
    case payload["action"] do
      "closed" ->
        {:ok, :issue_closed}
        
      _ ->
        {:ok, :ignored}
    end
  end
  
  def handle_event(_, _), do: {:ok, :ignored}
  
  @doc """
  Extracts issue number from PR body
  """
  def extract_issue_number(pr_body) when is_binary(pr_body) do
    # Look for patterns like "Fixes #123", "Closes #456", etc.
    case Regex.run(~r/(?:fixes|closes|resolves)\s+#(\d+)/i, pr_body) do
      [_, issue_number] -> String.to_integer(issue_number)
      nil -> 
        # Also check for plain issue references
        case Regex.run(~r/#(\d+)/, pr_body) do
          [_, issue_number] -> String.to_integer(issue_number)
          nil -> nil
        end
    end
  end
  
  def extract_issue_number(_), do: nil
  
  # Private functions
  
  defp handle_pr_opened(payload) do
    pr = payload["pull_request"]
    
    # Only track RSOLV-generated PRs
    if pr["body"] && String.contains?(pr["body"], "Generated by RSOLV") do
      org = pr["base"]["repo"]["owner"]["login"]
      repo = pr["base"]["repo"]["name"]
      pr_number = pr["number"]
      issue_number = extract_issue_number(pr["body"])
      
      # Create fix attempt record (or find existing)
      case find_fix_attempt(org, repo, pr_number) do
        nil ->
          %FixAttempt{}
          |> FixAttempt.changeset(%{
            github_org: org,
            repo_name: repo,
            issue_number: issue_number,
            pr_number: pr_number,
            pr_title: pr["title"],
            pr_url: pr["html_url"],
            status: "pending"
          })
          |> Repo.insert()
          
        _existing ->
          # Already exists, idempotent
          {:ok, :already_exists}
      end
      
      {:ok, :pr_opened}
    else
      {:ok, :ignored}
    end
  end
  
  defp handle_pr_merged(payload) do
    pr = payload["pull_request"]
    org = pr["base"]["repo"]["owner"]["login"]
    repo = pr["base"]["repo"]["name"]
    pr_number = pr["number"]
    
    # Find and update the fix attempt
    case find_fix_attempt(org, repo, pr_number) do
      nil ->
        {:ok, :not_tracked}
        
      fix_attempt ->
        fix_attempt
        |> FixAttempt.changeset(%{
          status: "merged",
          merged_at: pr["merged_at"] || DateTime.utc_now(),
          merged_by: pr["merged_by"] && pr["merged_by"]["login"],
          commit_sha: pr["merge_commit_sha"]
        })
        |> Repo.update()
        
        {:ok, :merged}
    end
  end
  
  defp handle_pr_rejected(payload) do
    pr = payload["pull_request"]
    org = pr["base"]["repo"]["owner"]["login"]
    repo = pr["base"]["repo"]["name"]
    pr_number = pr["number"]
    
    # Find and update the fix attempt
    case find_fix_attempt(org, repo, pr_number) do
      nil ->
        {:ok, :not_tracked}
        
      fix_attempt ->
        fix_attempt
        |> FixAttempt.changeset(%{
          status: "rejected"
        })
        |> Repo.update()
        
        {:ok, :rejected}
    end
  end
  
  defp find_fix_attempt(org, repo, pr_number) do
    Repo.get_by(FixAttempt, 
      github_org: org,
      repo_name: repo,
      pr_number: pr_number
    )
  end
end