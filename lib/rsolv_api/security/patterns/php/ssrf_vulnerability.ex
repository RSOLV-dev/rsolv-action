defmodule RsolvApi.Security.Patterns.Php.SsrfVulnerability do
  @moduledoc """
  Pattern for detecting Server-Side Request Forgery (SSRF) vulnerabilities in PHP.
  
  This pattern identifies when PHP HTTP request functions like file_get_contents(),
  curl_setopt(), fopen(), or readfile() are used with user-controlled URLs
  without proper validation, potentially allowing attackers to make requests
  to internal resources or arbitrary external endpoints.
  
  ## Vulnerability Details
  
  Server-Side Request Forgery (SSRF) is a web security vulnerability that allows
  an attacker to induce the server-side application to make HTTP requests to an
  arbitrary domain of the attacker's choosing. In typical scenarios, the attacker
  might cause the server to make connections to internal-only services within
  the organization's infrastructure or to arbitrary external systems.
  
  ### Attack Example
  ```php
  // Vulnerable code - user controls the URL
  $url = $_POST['webhook_url'];
  $response = file_get_contents($url);
  
  // Attacker can make requests to:
  // - Internal services: http://localhost:8080/admin
  // - Cloud metadata: http://169.254.169.254/metadata
  // - Internal networks: http://192.168.1.1/config
  ```
  
  The attack exploits the server's network position to access resources that
  would normally be inaccessible to an external attacker, including internal
  services, cloud instance metadata, and private network resources.
  """
  
  use RsolvApi.Security.Patterns.PatternBase
  alias RsolvApi.Security.Pattern
  
  @impl true
  def pattern do
    %Pattern{
      id: "php-ssrf-vulnerability",
      name: "Server-Side Request Forgery (SSRF)",
      description: "Unvalidated URLs in server-side requests",
      type: :ssrf,
      severity: :high,
      languages: ["php"],
      regex: ~r/(file_get_contents|fopen|readfile)\s*\([^)]*\$_(GET|POST|REQUEST|COOKIE)|curl_setopt\s*\([^,]+,\s*CURLOPT_URL\s*,[^)]*\$_(GET|POST|REQUEST|COOKIE)/,
      default_tier: :protected,
      cwe_id: "CWE-918",
      owasp_category: "A10:2021",
      recommendation: "Validate URLs against an allowlist before making requests",
      test_cases: %{
        vulnerable: [
          ~S|$content = file_get_contents($_POST['url']);|,
          ~S|curl_setopt($ch, CURLOPT_URL, $_GET['api']);|,
          ~S|$handle = fopen($_REQUEST['endpoint'], 'r');|,
          ~S|readfile($_COOKIE['download_url']);|
        ],
        safe: [
          ~S|$content = file_get_contents('https://api.example.com');|,
          ~S|curl_setopt($ch, CURLOPT_URL, $validated_url);|,
          ~S|$handle = fopen($safe_url, 'r');|,
          ~S|if (in_array($url, $allowed_urls)) { $content = file_get_contents($url); }|
        ]
      }
    }
  end
  
  @impl true
  def vulnerability_metadata do
    %{
      description: """
      Server-Side Request Forgery (SSRF) is a critical web security vulnerability that allows
      attackers to induce server-side applications to make HTTP requests to arbitrary destinations.
      This vulnerability enables attackers to abuse the server's network position to access
      internal resources, bypass network security controls, and potentially compromise entire
      infrastructure environments.
      
      SSRF attacks are particularly dangerous because they leverage the server's trusted network
      position. Internal services often have relaxed security controls assuming they can only
      be accessed by other internal systems. When an attacker can trigger arbitrary requests
      from the server, they effectively bypass network firewalls and access controls that
      would normally protect internal resources.
      
      ### The Attack Mechanism
      
      SSRF vulnerabilities typically arise when applications:
      1. **Accept user-controlled URLs** for server-side HTTP requests
      2. **Fail to validate destination URLs** against allowlists
      3. **Process requests without network restrictions** 
      4. **Return response data** to the attacker (blind vs non-blind SSRF)
      
      ### Common Vulnerable Scenarios
      
      #### Image Proxying and Processing
      Applications that fetch and process images from user-provided URLs are extremely
      vulnerable to SSRF attacks:
      ```php
      $image_url = $_POST['image_url'];
      $image_data = file_get_contents($image_url);
      // Process image...
      ```
      
      #### Webhook and Callback Processing
      Applications that make callbacks to user-specified URLs for notifications:
      ```php
      $webhook_url = $_POST['webhook_url'];
      $payload = json_encode($notification_data);
      $context = stream_context_create([
          'http' => ['method' => 'POST', 'content' => $payload]
      ]);
      file_get_contents($webhook_url, false, $context);
      ```
      
      #### API Aggregation and Proxying
      Services that aggregate data from multiple APIs using user-provided endpoints:
      ```php
      $api_endpoint = $_GET['api_url'];
      $curl = curl_init();
      curl_setopt($curl, CURLOPT_URL, $api_endpoint);
      $response = curl_exec($curl);
      ```
      """,
      references: [
        %{
          type: :cwe,
          id: "CWE-918",
          title: "Server-Side Request Forgery (SSRF)",
          url: "https://cwe.mitre.org/data/definitions/918.html"
        },
        %{
          type: :owasp,
          id: "A10:2021",
          title: "OWASP Top 10 2021 - A10 Server-Side Request Forgery (SSRF)",
          url: "https://owasp.org/Top10/A10_2021-Server-Side_Request_Forgery_%28SSRF%29/"
        },
        %{
          type: :owasp,
          id: "ssrf_prevention",
          title: "OWASP Server-Side Request Forgery Prevention Cheat Sheet",
          url: "https://cheatsheetseries.owasp.org/cheatsheets/Server_Side_Request_Forgery_Prevention_Cheat_Sheet.html"
        },
        %{
          type: :research,
          id: "portswigger_ssrf",
          title: "Server-side request forgery (SSRF) - PortSwigger",
          url: "https://portswigger.net/web-security/ssrf"
        },
        %{
          type: :research,
          id: "ssrf_techniques",
          title: "PHP SSRF Techniques - Medium",
          url: "https://medium.com/@themiddleblue/php-ssrf-techniques-9d422cb28d51"
        }
      ],
      attack_vectors: [
        "Internal service enumeration via localhost and 127.0.0.1 requests",
        "Cloud instance metadata access (AWS, Azure, GCP) via 169.254.169.254",
        "Internal network reconnaissance using private IP ranges",
        "Port scanning of internal infrastructure through HTTP requests",
        "Bypass of IP-based access controls and firewalls",
        "Data exfiltration through DNS exfiltration techniques",
        "Credential harvesting from internal service endpoints",
        "Exploitation of internal services with weak authentication"
      ],
      real_world_impact: [
        "Complete compromise of cloud infrastructure through metadata access",
        "Internal network mapping and service discovery",
        "Extraction of sensitive credentials from internal APIs",
        "Access to administrative interfaces behind firewalls", 
        "Bypass of VPN and network segmentation controls",
        "Denial of service against internal infrastructure",
        "Data breach through internal database access",
        "Lateral movement within compromised networks"
      ],
      cve_examples: [
        %{
          id: "CVE-2024-27564",
          description: "SSRF in pictureproxy.php allows arbitrary requests via url parameter",
          severity: "high",
          cvss: 8.6,
          note: "ChatGPT application SSRF vulnerability allowing internal network access"
        },
        %{
          id: "CVE-2024-27565",
          description: "Server-Side Request Forgery in weixin.php of ChatGPT-wechat-personal",
          severity: "high", 
          cvss: 7.5,
          note: "SSRF vulnerability in WeChat integration allowing arbitrary requests"
        },
        %{
          id: "CVE-2024-35451",
          description: "Authenticated SSRF to Remote Code Execution in LinkStack",
          severity: "critical",
          cvss: 9.0,
          note: "SSRF vulnerability escalated to RCE through internal service exploitation"
        },
        %{
          id: "CVE-2023-5877",
          description: "SSRF vulnerability in WordPress plugin allowing internal network access",
          severity: "high",
          cvss: 8.0,
          note: "WordPress SSRF affecting thousands of installations"
        },
        %{
          id: "CVE-2023-46725",
          description: "SSRF in PHP application allowing metadata service access",
          severity: "critical",
          cvss: 9.1,
          note: "Cloud instance compromise through SSRF and metadata service access"
        }
      ],
      detection_notes: """
      This pattern detects SSRF vulnerabilities by identifying:
      - HTTP request functions that commonly fetch remote resources
      - Direct usage of superglobal variables ($_GET, $_POST, $_REQUEST, $_COOKIE) in URL parameters
      - curl_setopt() calls that set CURLOPT_URL with user input
      - Functions like file_get_contents(), fopen(), readfile() with user-controlled URLs
      
      The regex specifically looks for:
      - file_get_contents(), fopen(), readfile() functions with user input
      - curl_setopt() calls setting CURLOPT_URL with superglobal variables
      - Various whitespace and formatting patterns around function calls
      
      False positives may occur when:
      - HTTP requests use properly validated URLs
      - Hardcoded URLs are used without user input
      - URL validation and allowlist checking is performed
      - Network restrictions prevent SSRF exploitation
      """,
      safe_alternatives: [
        "Validate URLs against a strict allowlist of permitted domains",
        "Use DNS resolution to block internal IP addresses and localhost",
        "Implement network-level controls to restrict outbound requests",
        "Use dedicated proxy services with security controls",
        "Validate URL schemes to only allow HTTP/HTTPS where appropriate",
        "Implement request timeouts and size limits",
        "Use separate network zones for external requests",
        "Monitor and log all outbound HTTP requests for anomalies"
      ],
      additional_context: %{
        common_mistakes: [
          "Believing that URL parsing alone prevents SSRF attacks",
          "Only blocking localhost without considering 127.0.0.1 and other loopback IPs", 
          "Failing to block cloud instance metadata URLs (169.254.169.254)",
          "Using blacklist-based filtering instead of allowlist validation",
          "Not considering DNS rebinding attacks for internal IP access",
          "Ignoring non-HTTP protocols that may be supported by URL functions"
        ],
        secure_patterns: [
          "parse_url() combined with allowlist validation",
          "filter_var($url, FILTER_VALIDATE_URL) with additional checks",
          "Network-level restrictions using iptables or similar",
          "Dedicated outbound proxy with security controls",
          "DNS filtering to block resolution of internal addresses"
        ],
        php_version_notes: [
          "All PHP versions: HTTP context options affect SSRF risk",
          "PHP 5.4+: stream_context_create() security considerations",
          "PHP 7.0+: curl improvements but manual validation still required",
          "PHP 8.0+: Enhanced stream security but SSRF protection needed",
          "libcurl version affects available protocols and security options"
        ],
        attack_targets: [
          "AWS metadata: http://169.254.169.254/latest/meta-data/",
          "Azure metadata: http://169.254.169.254/metadata/instance",
          "GCP metadata: http://metadata.google.internal/",
          "Localhost services: http://localhost:8080, http://127.0.0.1:3000",
          "Internal networks: http://192.168.1.1, http://10.0.0.1",
          "File protocol: file:///etc/passwd (if supported)",
          "FTP services: ftp://internal.server/data"
        ]
      }
    }
  end
  
  @doc """
  Returns test cases for the pattern.
  
  ## Examples
  
      iex> test_cases = RsolvApi.Security.Patterns.Php.SsrfVulnerability.test_cases()
      iex> length(test_cases.positive) > 0
      true
      
      iex> test_cases = RsolvApi.Security.Patterns.Php.SsrfVulnerability.test_cases()
      iex> length(test_cases.negative) > 0
      true
      
      iex> pattern = RsolvApi.Security.Patterns.Php.SsrfVulnerability.pattern()
      iex> pattern.id
      "php-ssrf-vulnerability"
  """
  def test_cases do
    %{
      positive: [
        %{
          code: ~S|$content = file_get_contents($_POST['url']);|,
          description: "file_get_contents with POST URL"
        },
        %{
          code: ~S|curl_setopt($ch, CURLOPT_URL, $_GET['api']);|,
          description: "curl_setopt with GET parameter"
        },
        %{
          code: ~S|$handle = fopen($_REQUEST['endpoint'], 'r');|,
          description: "fopen with REQUEST parameter"
        },
        %{
          code: ~S|readfile($_COOKIE['download_url']);|,
          description: "readfile with cookie parameter"
        },
        %{
          code: ~S|$data = file_get_contents($_GET['webhook_url']);|,
          description: "Webhook URL from GET parameter"
        },
        %{
          code: ~S|curl_setopt($curl, CURLOPT_URL, $_POST['callback']);|,
          description: "Callback URL via curl"
        },
        %{
          code: ~S|$image = file_get_contents($_REQUEST['image_proxy']);|,
          description: "Image proxy with user URL"
        },
        %{
          code: ~S|$fp = fopen($_COOKIE['remote_file'], 'rb');|,
          description: "Remote file access via cookie"
        },
        %{
          code: ~S|readfile($_GET['download']);|,
          description: "Direct download with GET parameter"
        },
        %{
          code: ~S|curl_setopt($ch, CURLOPT_URL, $_REQUEST['target_api']);|,
          description: "API target via REQUEST superglobal"
        }
      ],
      negative: [
        %{
          code: ~S|$content = file_get_contents('https://api.example.com');|,
          description: "Hardcoded URL"
        },
        %{
          code: ~S|curl_setopt($ch, CURLOPT_URL, $validated_url);|,
          description: "Pre-validated URL variable"
        },
        %{
          code: ~S|$handle = fopen($safe_url, 'r');|,
          description: "Safe URL variable"
        },
        %{
          code: ~S|if (in_array($url, $allowed_urls)) { $content = file_get_contents($url); }|,
          description: "Allowlist validation"
        },
        %{
          code: ~S|$url = filter_var($_POST['url'], FILTER_VALIDATE_URL); if ($url) { $content = file_get_contents($url); }|,
          description: "URL validation with filter_var"
        },
        %{
          code: ~S|function file_get_contents_safe($url) { return file_get_contents($url); }|,
          description: "Function name containing HTTP function"
        },
        %{
          code: ~S|$data = json_decode($_POST['data'], true); $content = file_get_contents($data['url']);|,
          description: "Indirect access through data structure"
        },
        %{
          code: ~S|readfile('./local/file.txt');|,
          description: "Local file access"
        }
      ]
    }
  end
  
  @doc """
  Returns examples of vulnerable and fixed code.
  """
  def examples do
    %{
      vulnerable: %{
        "Image Proxy Service" => ~S"""
        // Image proxy - VULNERABLE
        if (isset($_GET['image_url'])) {
            $image_url = $_GET['image_url'];
            
            // Fetch image without validation
            $image_data = file_get_contents($image_url);
            
            if ($image_data !== false) {
                header('Content-Type: image/jpeg');
                echo $image_data;
            } else {
                http_response_code(404);
                echo "Image not found";
            }
        }
        
        // Attack: ?image_url=http://localhost:8080/admin
        // Result: Access to internal admin interface
        """,
        "Webhook Handler" => ~S"""
        // Webhook notification - VULNERABLE
        function sendWebhook($webhook_url, $data) {
            $payload = json_encode($data);
            
            $curl = curl_init();
            curl_setopt($curl, CURLOPT_URL, $webhook_url);
            curl_setopt($curl, CURLOPT_POST, true);
            curl_setopt($curl, CURLOPT_POSTFIELDS, $payload);
            curl_setopt($curl, CURLOPT_HTTPHEADER, ['Content-Type: application/json']);
            curl_setopt($curl, CURLOPT_RETURNTRANSFER, true);
            
            $response = curl_exec($curl);
            curl_close($curl);
            
            return $response;
        }
        
        // Usage with user input
        $webhook_url = $_POST['webhook_url'];
        sendWebhook($webhook_url, ['event' => 'user_signup']);
        
        // Attack: webhook_url=http://169.254.169.254/latest/meta-data/
        // Result: AWS metadata access
        """,
        "RSS Feed Aggregator" => ~S"""
        // RSS aggregator - VULNERABLE
        class FeedAggregator {
            public function fetchFeed($feed_url) {
                // Fetch RSS feed without validation
                $feed_content = file_get_contents($feed_url);
                
                if ($feed_content === false) {
                    return ['error' => 'Failed to fetch feed'];
                }
                
                $xml = simplexml_load_string($feed_content);
                if ($xml === false) {
                    return ['error' => 'Invalid RSS format'];
                }
                
                $items = [];
                foreach ($xml->channel->item as $item) {
                    $items[] = [
                        'title' => (string)$item->title,
                        'link' => (string)$item->link,
                        'description' => (string)$item->description
                    ];
                }
                
                return ['items' => $items];
            }
        }
        
        $aggregator = new FeedAggregator();
        $feed = $aggregator->fetchFeed($_GET['feed_url']);
        
        // Attack: feed_url=http://192.168.1.1/config
        // Result: Internal network reconnaissance
        """,
        "File Download Proxy" => ~S"""
        // Download proxy - VULNERABLE
        if (isset($_POST['download_url'])) {
            $download_url = $_POST['download_url'];
            
            // Download file from user-specified URL
            $file_content = file_get_contents($download_url);
            
            if ($file_content !== false) {
                $filename = basename(parse_url($download_url, PHP_URL_PATH));
                
                header('Content-Disposition: attachment; filename="' . $filename . '"');
                header('Content-Type: application/octet-stream');
                echo $file_content;
            } else {
                echo "Download failed";
            }
        }
        
        // Attack: download_url=file:///etc/passwd
        // Result: Local file disclosure (if file:// protocol supported)
        """
      },
      fixed: %{
        "URL allowlist validation" => ~S"""
        // Image proxy - SECURE
        function fetchImageSafely($image_url) {
            // Define allowed domains
            $allowed_domains = [
                'images.example.com',
                'cdn.trusted.com',
                'static.oursite.com'
            ];
            
            // Validate URL format
            $parsed_url = parse_url($image_url);
            if (!$parsed_url || !isset($parsed_url['scheme'], $parsed_url['host'])) {
                return false;
            }
            
            // Only allow HTTP and HTTPS
            if (!in_array($parsed_url['scheme'], ['http', 'https'])) {
                return false;
            }
            
            // Check domain allowlist
            if (!in_array($parsed_url['host'], $allowed_domains)) {
                return false;
            }
            
            // Additional security: resolve hostname to prevent DNS rebinding
            $ip = gethostbyname($parsed_url['host']);
            if ($ip === $parsed_url['host']) {
                // DNS resolution failed
                return false;
            }
            
            // Block internal IP ranges
            if (filter_var($ip, FILTER_VALIDATE_IP, FILTER_FLAG_NO_PRIV_RANGE | FILTER_FLAG_NO_RES_RANGE) === false) {
                return false;
            }
            
            // Fetch with timeout and size limits
            $context = stream_context_create([
                'http' => [
                    'timeout' => 10,
                    'max_redirects' => 3,
                    'user_agent' => 'SecureImageProxy/1.0'
                ]
            ]);
            
            return file_get_contents($image_url, false, $context);
        }
        
        if (isset($_GET['image_url'])) {
            $image_data = fetchImageSafely($_GET['image_url']);
            
            if ($image_data !== false) {
                header('Content-Type: image/jpeg');
                echo $image_data;
            } else {
                http_response_code(400);
                echo "Invalid or forbidden image URL";
            }
        }
        """,
        "Network restrictions" => ~S"""
        // Webhook handler - SECURE with network controls
        class SecureWebhookSender {
            private $allowed_webhooks = [];
            
            public function __construct() {
                // Load pre-approved webhook URLs from config
                $this->allowed_webhooks = [
                    'https://hooks.slack.com/services/YOUR/WEBHOOK/URL',
                    'https://api.github.com/webhooks/YOUR_WEBHOOK',
                    'https://webhooks.yourservice.com/notify'
                ];
            }
            
            public function sendWebhook($webhook_identifier, $data) {
                // Use identifier instead of raw URL
                if (!isset($this->allowed_webhooks[$webhook_identifier])) {
                    throw new InvalidArgumentException('Unknown webhook identifier');
                }
                
                $webhook_url = $this->allowed_webhooks[$webhook_identifier];
                $payload = json_encode($data);
                
                // Use curl with security options
                $curl = curl_init();
                curl_setopt_array($curl, [
                    CURLOPT_URL => $webhook_url,
                    CURLOPT_POST => true,
                    CURLOPT_POSTFIELDS => $payload,
                    CURLOPT_HTTPHEADER => [
                        'Content-Type: application/json',
                        'User-Agent: SecureWebhook/1.0'
                    ],
                    CURLOPT_RETURNTRANSFER => true,
                    CURLOPT_TIMEOUT => 10,
                    CURLOPT_CONNECTTIMEOUT => 5,
                    CURLOPT_MAXREDIRS => 3,
                    CURLOPT_SSL_VERIFYPEER => true,
                    CURLOPT_SSL_VERIFYHOST => 2,
                    // Prevent access to local addresses
                    CURLOPT_PROTOCOLS => CURLPROTO_HTTP | CURLPROTO_HTTPS,
                    CURLOPT_REDIR_PROTOCOLS => CURLPROTO_HTTP | CURLPROTO_HTTPS
                ]);
                
                $response = curl_exec($curl);
                $http_code = curl_getinfo($curl, CURLINFO_HTTP_CODE);
                curl_close($curl);
                
                if ($response === false || $http_code >= 400) {
                    throw new Exception('Webhook delivery failed');
                }
                
                return $response;
            }
        }
        
        $webhook_sender = new SecureWebhookSender();
        $webhook_sender->sendWebhook('slack_notifications', ['event' => 'user_signup']);
        """,
        "Proxy with validation" => ~S"""
        // RSS aggregator - SECURE
        class SecureFeedAggregator {
            private $allowed_feeds = [];
            private $cache_dir = '/tmp/feed_cache/';
            
            public function __construct() {
                // Pre-approved RSS feeds
                $this->allowed_feeds = [
                    'bbc_news' => 'https://feeds.bbci.co.uk/news/rss.xml',
                    'tech_news' => 'https://rss.cnn.com/rss/tech.rss',
                    'security_news' => 'https://feeds.feedburner.com/SecurityWeek'
                ];
            }
            
            public function fetchFeed($feed_identifier) {
                if (!isset($this->allowed_feeds[$feed_identifier])) {
                    return ['error' => 'Unknown feed identifier'];
                }
                
                $feed_url = $this->allowed_feeds[$feed_identifier];
                $cache_file = $this->cache_dir . md5($feed_url) . '.xml';
                
                // Check cache first (prevent excessive requests)
                if (file_exists($cache_file) && (time() - filemtime($cache_file)) < 3600) {
                    $feed_content = file_get_contents($cache_file);
                } else {
                    // Fetch with strict context
                    $context = stream_context_create([
                        'http' => [
                            'timeout' => 15,
                            'max_redirects' => 2,
                            'user_agent' => 'SecureFeedAggregator/1.0',
                            'protocol_version' => 1.1
                        ]
                    ]);
                    
                    $feed_content = file_get_contents($feed_url, false, $context);
                    
                    if ($feed_content === false) {
                        return ['error' => 'Failed to fetch feed'];
                    }
                    
                    // Cache the result
                    file_put_contents($cache_file, $feed_content, LOCK_EX);
                }
                
                // Parse XML safely
                libxml_disable_entity_loader(true);
                $xml = simplexml_load_string($feed_content, 'SimpleXMLElement', LIBXML_NOCDATA);
                
                if ($xml === false) {
                    return ['error' => 'Invalid RSS format'];
                }
                
                $items = [];
                foreach ($xml->channel->item as $item) {
                    $items[] = [
                        'title' => htmlspecialchars((string)$item->title),
                        'link' => filter_var((string)$item->link, FILTER_VALIDATE_URL),
                        'description' => htmlspecialchars((string)$item->description)
                    ];
                }
                
                return ['items' => array_slice($items, 0, 20)]; // Limit items
            }
        }
        
        $aggregator = new SecureFeedAggregator();
        $feed = $aggregator->fetchFeed($_GET['feed_id']); // Use identifier, not URL
        """,
        "File mapping system" => ~S"""
        // Download proxy - SECURE with file mapping
        class SecureDownloadProxy {
            private $file_mappings = [];
            
            public function __construct() {
                // Map download IDs to actual URLs
                $this->file_mappings = [
                    'user_manual' => 'https://docs.example.com/manual.pdf',
                    'product_catalog' => 'https://cdn.example.com/catalog.pdf',
                    'privacy_policy' => 'https://legal.example.com/privacy.pdf'
                ];
            }
            
            public function downloadFile($file_id) {
                if (!isset($this->file_mappings[$file_id])) {
                    return false;
                }
                
                $file_url = $this->file_mappings[$file_id];
                
                // Additional validation even for mapped URLs
                $parsed_url = parse_url($file_url);
                if (!$parsed_url || $parsed_url['scheme'] !== 'https') {
                    return false;
                }
                
                // Download with security controls
                $context = stream_context_create([
                    'http' => [
                        'timeout' => 30,
                        'max_redirects' => 2,
                        'user_agent' => 'SecureDownloader/1.0'
                    ]
                ]);
                
                $file_content = file_get_contents($file_url, false, $context);
                
                if ($file_content === false) {
                    return false;
                }
                
                // Validate file size (prevent DoS)
                if (strlen($file_content) > 50 * 1024 * 1024) { // 50MB limit
                    return false;
                }
                
                return [
                    'content' => $file_content,
                    'filename' => basename($parsed_url['path']),
                    'size' => strlen($file_content)
                ];
            }
        }
        
        if (isset($_POST['file_id'])) {
            $downloader = new SecureDownloadProxy();
            $file_data = $downloader->downloadFile($_POST['file_id']);
            
            if ($file_data) {
                header('Content-Disposition: attachment; filename="' . $file_data['filename'] . '"');
                header('Content-Type: application/octet-stream');
                header('Content-Length: ' . $file_data['size']);
                echo $file_data['content'];
            } else {
                http_response_code(404);
                echo "File not found or download failed";
            }
        }
        """
      }
    }
  end
  
  @doc """
  Returns detailed vulnerability description.
  """
  def vulnerability_description do
    """
    Server-Side Request Forgery (SSRF) is a critical web security vulnerability that allows
    attackers to induce server-side applications to make HTTP requests to arbitrary destinations
    of the attacker's choosing. This vulnerability effectively allows attackers to abuse the
    server's network position to access internal resources, bypass security controls, and
    potentially compromise entire infrastructure environments.
    
    ## Understanding SSRF Attacks
    
    ### The Core Problem
    
    SSRF vulnerabilities arise when applications accept user-controlled URLs and make HTTP
    requests to those URLs without proper validation. The server's trusted network position
    becomes a weapon that attackers can leverage to:
    
    - Access internal services that are normally protected by firewalls
    - Bypass IP-based access controls and authentication mechanisms  
    - Enumerate internal network infrastructure and services
    - Extract sensitive data from cloud instance metadata services
    - Perform port scanning and network reconnaissance
    
    ### Attack Mechanics
    
    #### Basic SSRF Attack Flow
    ```
    1. Attacker submits malicious URL → Application Server
    2. Server makes request to attacker's URL → Internal Network
    3. Internal service responds → Application Server  
    4. Response data returned → Attacker
    ```
    
    #### Common Vulnerable Functions in PHP
    
    **file_get_contents() - Most Common**
    ```php
    // VULNERABLE - direct user input
    $url = $_POST['webhook_url'];
    $response = file_get_contents($url);
    
    // Attack payloads:
    // http://localhost:8080/admin
    // http://127.0.0.1:3000/config
    // http://169.254.169.254/latest/meta-data/
    ```
    
    **cURL Functions**
    ```php
    // VULNERABLE - cURL with user URL
    $api_url = $_GET['api_endpoint'];
    $curl = curl_init();
    curl_setopt($curl, CURLOPT_URL, $api_url);
    $result = curl_exec($curl);
    
    // Enables sophisticated attacks with custom headers, methods
    ```
    
    **File Stream Functions**
    ```php
    // VULNERABLE - file operations with URLs
    $config_url = $_POST['config_source'];
    $handle = fopen($config_url, 'r');
    $data = stream_get_contents($handle);
    ```
    
    ## Advanced Attack Techniques
    
    ### Cloud Instance Metadata Exploitation
    
    The most devastating SSRF attacks target cloud instance metadata services:
    
    ```
    AWS EC2: http://169.254.169.254/latest/meta-data/iam/security-credentials/
    Azure: http://169.254.169.254/metadata/instance/compute/
    GCP: http://metadata.google.internal/computeMetadata/v1/instance/
    ```
    
    These endpoints expose:
    - Temporary AWS access keys and tokens
    - Instance configuration and network details
    - Service account credentials
    - Security group and firewall configurations
    
    ### Internal Network Reconnaissance
    
    Attackers use SSRF to map internal infrastructure:
    ```
    Port scanning: http://192.168.1.1:22, http://192.168.1.1:80, etc.
    Service discovery: http://internal-db:5432, http://redis:6379
    Admin interfaces: http://internal-admin:8080/dashboard
    ```
    
    ### Protocol Exploitation
    
    SSRF isn't limited to HTTP - many functions support multiple protocols:
    ```
    file:// - Local file access: file:///etc/passwd
    ftp:// - FTP server interaction: ftp://internal-ftp/config
    gopher:// - Raw TCP communication for complex attacks
    dict:// - Dictionary server protocol for information gathering
    ```
    
    ### DNS Rebinding Attacks
    
    Sophisticated attacks use DNS rebinding to bypass IP filtering:
    ```
    1. Attacker controls domain: evil.com
    2. DNS initially resolves to: 1.2.3.4 (external IP)
    3. Application validates external IP as "safe"
    4. DNS resolution changes to: 127.0.0.1 (internal IP)
    5. Subsequent requests hit internal services
    ```
    
    ## Real-World Attack Scenarios
    
    ### Scenario 1: Cloud Infrastructure Compromise
    ```php
    // Vulnerable image processing service
    $image_url = $_POST['profile_image'];
    $image_data = file_get_contents($image_url);
    
    // Attack: profile_image=http://169.254.169.254/latest/meta-data/iam/security-credentials/WebServerRole
    // Result: AWS credentials exposed, full account compromise
    ```
    
    ### Scenario 2: Internal Database Access
    ```php
    // Vulnerable webhook handler
    $webhook = $_POST['notification_url']; 
    $payload = json_encode(['user_id' => $user_id]);
    file_get_contents($webhook, false, stream_context_create([
        'http' => ['method' => 'POST', 'content' => $payload]
    ]));
    
    // Attack: notification_url=http://internal-admin:8080/execute?cmd=SELECT * FROM users
    // Result: Database queries executed, data extraction
    ```
    
    ### Scenario 3: Network Pivot Point
    ```php
    // Vulnerable RSS feed aggregator
    $feed_url = $_GET['rss_feed'];
    $rss_content = file_get_contents($feed_url);
    
    // Attack: rss_feed=http://192.168.1.100:22
    // Result: SSH service discovery, further attack vectors identified
    ```
    
    ## Defense Strategies
    
    ### Immediate Protection Measures
    
    #### 1. URL Allowlist Validation
    ```php
    function validateUrl($url) {
        $allowed_hosts = ['api.trusted.com', 'webhooks.ourservice.com'];
        $parsed = parse_url($url);
        
        if (!$parsed || !in_array($parsed['host'], $allowed_hosts)) {
            return false;
        }
        
        return filter_var($url, FILTER_VALIDATE_URL) !== false;
    }
    ```
    
    #### 2. Network-Level Restrictions
    ```php
    function isInternalIP($ip) {
        return !filter_var($ip, FILTER_VALIDATE_IP, 
                   FILTER_FLAG_NO_PRIV_RANGE | FILTER_FLAG_NO_RES_RANGE);
    }
    
    function validateDestination($url) {
        $host = parse_url($url, PHP_URL_HOST);
        $ip = gethostbyname($host);
        
        if (isInternalIP($ip)) {
            throw new SecurityException('Internal IP access forbidden');
        }
    }
    ```
    
    #### 3. Protocol Restrictions
    ```php
    function makeSecureRequest($url) {
        $parsed = parse_url($url);
        
        // Only allow HTTP/HTTPS
        if (!in_array($parsed['scheme'], ['http', 'https'])) {
            throw new SecurityException('Unsupported protocol');
        }
        
        // Use cURL with restricted protocols
        $curl = curl_init();
        curl_setopt_array($curl, [
            CURLOPT_URL => $url,
            CURLOPT_PROTOCOLS => CURLPROTO_HTTP | CURLPROTO_HTTPS,
            CURLOPT_REDIR_PROTOCOLS => CURLPROTO_HTTP | CURLPROTO_HTTPS,
            CURLOPT_TIMEOUT => 10,
            CURLOPT_MAXREDIRS => 3
        ]);
        
        return curl_exec($curl);
    }
    ```
    
    ### Advanced Protection Strategies
    
    #### 1. Dedicated Outbound Proxy
    Route all external requests through a hardened proxy server that:
    - Blocks internal IP ranges and cloud metadata endpoints
    - Logs all outbound requests for monitoring
    - Implements rate limiting and request quotas
    - Validates response content and size limits
    
    #### 2. Network Segmentation
    - Isolate web servers in DMZ networks
    - Restrict outbound connectivity to essential services only
    - Use application-specific network policies
    - Monitor and alert on unusual network patterns
    
    #### 3. DNS Security
    - Use secure DNS resolvers that block malicious domains
    - Implement DNS filtering to prevent resolution of internal addresses
    - Monitor DNS queries for suspicious patterns
    - Consider using DNS over HTTPS (DoH) for additional security
    
    ## Framework-Specific Considerations
    
    ### Laravel
    ```php
    // Use HTTP client with validation
    use Illuminate\\Support\\Facades\\Http;
    
    $response = Http::timeout(10)
                   ->withOptions(['verify' => true])
                   ->get($validated_url);
    ```
    
    ### Symfony
    ```php
    // Use Symfony HTTP client with security options
    use Symfony\\Component\\HttpClient\\HttpClient;
    
    $client = HttpClient::create([
        'timeout' => 10,
        'max_redirects' => 3
    ]);
    ```
    
    ## Monitoring and Detection
    
    ### Log Analysis
    Monitor for suspicious patterns:
    - Requests to internal IP ranges (10.x.x.x, 192.168.x.x, 127.x.x.x)
    - Access to cloud metadata endpoints (169.254.169.254)
    - Unusual outbound HTTP requests from web servers
    - Multiple requests to sequential IP addresses (port scanning)
    
    ### Automated Detection
    ```php
    function logSSRFAttempt($url, $source_ip) {
        $suspicious_patterns = [
            '/localhost/i',
            '/127\\.0\\.0\\.1/',
            '/192\\.168\\.',
            '/10\\.',
            '/169\\.254\\.169\\.254/',
            '/metadata/'
        ];
        
        foreach ($suspicious_patterns as $pattern) {
            if (preg_match($pattern, $url)) {
                error_log("SSRF attempt detected: $url from $source_ip");
                // Trigger security alert
                break;
            }
        }
    }
    ```
    
    Remember: SSRF vulnerabilities can lead to complete infrastructure compromise.
    Always validate and restrict URL destinations, implement network-level controls,
    and monitor outbound requests for suspicious activity.
    """
  end
  
  @doc """
  Returns AST enhancement rules to reduce false positives.
  
  This enhancement helps distinguish between actual vulnerabilities and false positives
  by analyzing the context of HTTP request operations and checking for safety measures.
  
  ## Examples
  
      iex> enhancement = RsolvApi.Security.Patterns.Php.SsrfVulnerability.ast_enhancement()
      iex> Map.keys(enhancement) |> Enum.sort()
      [:min_confidence, :rules]
      
      iex> enhancement = RsolvApi.Security.Patterns.Php.SsrfVulnerability.ast_enhancement()
      iex> enhancement.min_confidence
      0.8
      
      iex> enhancement = RsolvApi.Security.Patterns.Php.SsrfVulnerability.ast_enhancement()
      iex> length(enhancement.rules)
      4
  """
  @impl true
  def ast_enhancement do
    %{
      rules: [
        %{
          type: "ssrf_functions",
          description: "PHP functions that can make HTTP requests",
          functions: [
            "file_get_contents",
            "fopen", 
            "readfile",
            "curl_init",
            "curl_setopt",
            "curl_exec",
            "stream_get_contents",
            "copy",
            "file"
          ],
          contexts: [
            "webhook_handlers",
            "image_proxying",
            "rss_aggregation", 
            "api_integration",
            "file_downloading"
          ]
        },
        %{
          type: "url_validation", 
          description: "Functions and patterns that validate URLs for SSRF prevention",
          functions: [
            "filter_var",
            "parse_url",
            "gethostbyname",
            "in_array",
            "preg_match",
            "strpos"
          ],
          validation_patterns: [
            "FILTER_VALIDATE_URL",
            "FILTER_FLAG_NO_PRIV_RANGE",
            "FILTER_FLAG_NO_RES_RANGE",
            "parse_url($url, PHP_URL_HOST)",
            "in_array($host, $allowed_hosts)"
          ]
        },
        %{
          type: "context_analysis",
          description: "Analyze usage context to determine SSRF risk level",
          high_risk_patterns: [
            "HTTP requests with direct user input URLs",
            "curl_setopt with CURLOPT_URL and user data",
            "file_get_contents with superglobal variables",
            "Webhook processing without URL validation",
            "Image proxying services accepting arbitrary URLs"
          ],
          mitigation_indicators: [
            "URL allowlist validation with in_array()",
            "parse_url() combined with host checking",
            "filter_var() with FILTER_VALIDATE_URL",
            "IP address validation with FILTER_FLAG_NO_PRIV_RANGE",
            "Network-level restrictions and proxy usage"
          ],
          false_positive_patterns: [
            "Hardcoded URLs without user input",
            "Pre-validated URL variables from trusted sources",
            "HTTP requests in unit tests",
            "Configuration-based URL mapping systems",
            "URLs constructed from trusted database values"
          ]
        },
        %{
          type: "user_input_analysis", 
          description: "Identify sources of user-controlled URL data",
          dangerous_sources: [
            "$_GET",
            "$_POST",
            "$_REQUEST",
            "$_COOKIE",
            "$_FILES",
            "file_get_contents('php://input')",
            "json_decode() with user data",
            "XML parsing results with user input"
          ],
          safe_sources: [
            "Configuration constants and files",
            "Hardcoded URL strings",
            "Database lookups with ID-based mapping",
            "URL allowlists and predefined endpoints",
            "Validated and sanitized input variables"
          ]
        }
      ],
      min_confidence: 0.8
    }
  end
end