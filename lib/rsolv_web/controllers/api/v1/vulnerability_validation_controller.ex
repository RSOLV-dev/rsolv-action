defmodule RsolvWeb.Api.V1.VulnerabilityValidationController do
  @moduledoc """
  Controller for validating detected vulnerabilities using AST analysis.
  Part of RFC-036: Server-Side AST Validation Before Issue Creation.
  
  This controller receives vulnerabilities detected by regex patterns and
  validates them using AST analysis to reduce false positives.
  """
  
  use RsolvWeb, :controller

  alias Rsolv.Cache.ValidationCache
  alias RsolvWeb.Telemetry.ValidationTelemetry
  alias RsolvWeb.Api.V1.FilePathClassifier
  alias RsolvWeb.Api.V1.SafePatternDetector
  alias RsolvWeb.Api.V1.TaintAnalyzer

  require Logger

  plug RsolvWeb.Plugs.ApiAuthentication
  
  def validate(conn, params) do
    start_time = System.monotonic_time(:millisecond)
    customer = conn.assigns.customer

    with {:ok, vulnerabilities} <- validate_request(params) do
      
      # Process vulnerabilities
      validated_results = validate_vulnerabilities(
        vulnerabilities,
        params["files"] || %{}
      )
      
      # Calculate stats
      stats = calculate_stats(validated_results)
      
      # Track cache statistics
      cache_stats = ValidationCache.get_stats()
      
      # Build response
      response = %{
        validated: validated_results,
        stats: stats,
        cache_stats: cache_stats
      }
      
      # Emit telemetry events
      ValidationTelemetry.emit_validation_request(start_time, response, Map.get(cache_stats, "cache_hits", 0) > 0)
      ValidationTelemetry.emit_false_positive(response, customer.id)
      
      json(conn, response)
    else
      {:error, :invalid_request} = error ->
        ValidationTelemetry.emit_validation_error(start_time, error)
        conn
        |> put_status(400)
        |> json(%{error: "Invalid request format"})
    end
  end

  defp validate_request(%{"vulnerabilities" => vulnerabilities}) 
       when is_list(vulnerabilities) do
    {:ok, vulnerabilities}
  end
  defp validate_request(_), do: {:error, :invalid_request}
  
  defp validate_vulnerabilities(vulnerabilities, files) do
    # Track which results we've already computed to handle internal duplicates
    cache_map = %{}
    
    {validated_results, _final_cache_map} = 
      Enum.map_reduce(vulnerabilities, cache_map, fn vuln, acc_cache ->
        file_info = Map.get(files, vuln["filePath"], %{})
        file_content = case file_info do
          %{"content" => content} -> content
          content when is_binary(content) -> content
          _ -> ""
        end
        cache_key = ValidationCache.generate_key(vuln, file_content)
        
        # Check if we've already processed this in the current batch
        case Map.get(acc_cache, cache_key) do
          nil ->
            # Not in local cache, check global cache
            result = case ValidationCache.get(cache_key) do
              {:ok, cached_result} ->
                # Found in global cache
                ValidationTelemetry.emit_cache_hit()
                cached_result
              :error ->
                # Not in cache, compute result
                ValidationTelemetry.emit_cache_miss()
                computed_result = validate_single_vulnerability(vuln, files)
                # Store in cache for future requests
                ValidationCache.put(cache_key, computed_result)
                computed_result
            end
            # Store in local cache for this batch
            {result, Map.put(acc_cache, cache_key, result)}
          
          cached_result ->
            # Found in local cache (duplicate in same batch)
            ValidationCache.increment_internal_hits()
            {cached_result, acc_cache}
        end
      end)
    
    validated_results
  end
  
  defp validate_single_vulnerability(vuln, files) do
    file_info = Map.get(files, vuln["filePath"])
    file_content = case file_info do
      %{"content" => content} -> content
      content when is_binary(content) -> content
      _ -> nil
    end
    
    if file_content do
      # Perform AST validation
      # Perform AST validation - always returns {:ok, result}
      {:ok, result} = perform_ast_validation(vuln, file_content)
      result
    else
      # No file content, can't validate
      %{
        "id" => vuln["id"],
        "isValid" => true,
        "confidence" => 0.5,
        "reason" => "File content unavailable"
      }
    end
  end
  
  defp perform_ast_validation(vuln, file_content) do
    # Step 1: Check file path classification
    file_classification = FilePathClassifier.classify(vuln["filePath"])
    confidence_multiplier = FilePathClassifier.confidence_multiplier(file_classification)
    
    # Step 2: Check for safe patterns
    vulnerability_type = vuln["type"] |> to_vulnerability_atom()
    language = detect_language(vuln["filePath"])
    is_safe_pattern = SafePatternDetector.is_safe_pattern?(
      vulnerability_type,
      vuln["code"],
      %{language: language}
    )
    
    cond do
      # Check if safe pattern detected
      is_safe_pattern ->
        explanation = SafePatternDetector.explain_safety(
          vulnerability_type,
          vuln["code"],
          %{language: language}
        )
        {:ok, %{
          "id" => vuln["id"],
          "isValid" => false,
          "confidence" => 0.1 * confidence_multiplier,
          "reason" => "Safe pattern detected: #{explanation}",
          "astContext" => %{
            "inUserInputFlow" => false,
            "hasValidation" => true,
            "fileClassification" => to_string(file_classification),
            "safePattern" => true
          }
        }}
      
      # Check if this is in a comment
      is_in_comment?(vuln["code"], file_content, vuln["line"]) ->
        {:ok, %{
          "id" => vuln["id"],
          "isValid" => false,
          "confidence" => 0.1 * confidence_multiplier,
          "reason" => "Code found in comment",
          "astContext" => %{
            "inUserInputFlow" => false,
            "hasValidation" => false,
            "fileClassification" => to_string(file_classification)
          }
        }}
      
      # Check if this is in a string literal (false positive)
      is_in_string_literal?(vuln["code"], file_content, vuln["line"]) ->
        {:ok, %{
          "id" => vuln["id"],
          "isValid" => false,
          "confidence" => 0.1 * confidence_multiplier,
          "reason" => "Code found in string literal",
          "astContext" => %{
            "inUserInputFlow" => false,
            "hasValidation" => false,
            "fileClassification" => to_string(file_classification)
          }
        }}
      
      # For real vulnerabilities, perform deeper analysis
      true ->
        {:ok, context} = analyze_vulnerability_context(vuln, file_content)
        base_confidence = calculate_confidence(context)
        adjusted_confidence = base_confidence * confidence_multiplier
        
        # Apply filtering for vendor and test files with low confidence
        should_filter = FilePathClassifier.should_filter?(file_classification, adjusted_confidence)
        
        {:ok, %{
          "id" => vuln["id"],
          "isValid" => not should_filter,
          "confidence" => adjusted_confidence,
          "reason" => if(should_filter, do: "Filtered: #{file_classification} file with low confidence", else: nil),
          "astContext" => Map.merge(context, %{
            "fileClassification" => to_string(file_classification)
          })
        }}
    end
  end
  
  defp is_in_comment?(code, file_content, line_number) do
    lines = String.split(file_content, "\n")
    line = Enum.at(lines, line_number - 1, "")
    
    # Check for single-line comment
    cond do
      # If the entire line is the comment pattern (e.g., "// eval(userInput)")
      String.trim(line) == code and String.starts_with?(String.trim(code), "//") ->
        true
      
      # Check if code appears after // on the line
      String.contains?(line, "//") ->
        comment_start = case :binary.match(line, "//") do
          :nomatch -> nil
          {pos, _} -> pos
        end
        code_pos = case :binary.match(line, code) do
          :nomatch -> -1
          {pos, _} -> pos
        end
        comment_start != nil and code_pos >= comment_start
      
      # Check for Python/Ruby style comments
      String.trim(line) == code and String.starts_with?(String.trim(code), "#") ->
        true
      
      # Check if in multi-line comment (simplified check)
      String.contains?(code, "/*") or String.contains?(code, "*/") or
      String.contains?(code, "=begin") ->
        true
      
      # Check if we're inside Python docstring/multi-line string
      true ->
        check_multiline_context(code, file_content, line_number)
    end
  end
  
  defp check_multiline_context(_code, file_content, line_number) do
    lines = String.split(file_content, "\n")
    
    # Get all lines up to and including the current line
    check_lines = Enum.take(lines, line_number)
    
    # Check for JavaScript multi-line comments
    in_js_comment = check_js_multiline_comment(check_lines)
    
    # Check if we're inside a Python docstring
    # Count triple quotes before our line
    before_lines = Enum.take(lines, line_number - 1)
    triple_quote_count = Enum.reduce(before_lines, 0, fn line, acc ->
      acc + length(Regex.scan(~r/"""/, line))
    end)
    
    in_python_docstring = rem(triple_quote_count, 2) == 1
    
    # Check if we're in a Ruby multi-line comment
    in_ruby_comment = Enum.any?(before_lines, fn line ->
      String.contains?(line, "=begin")
    end) and not Enum.any?(before_lines, fn line ->
      String.contains?(line, "=end")
    end)
    
    in_js_comment or in_python_docstring or in_ruby_comment
  end
  
  defp check_js_multiline_comment(lines) do
    # Track if we're inside a /* */ comment
    {in_comment, _} = Enum.reduce(lines, {false, false}, fn line, {in_comment, _} ->
      cond do
        # If we're in a comment and find */, we're out
        in_comment and String.contains?(line, "*/") ->
          {false, true}
        
        # If we find /*, we're in a comment
        String.contains?(line, "/*") ->
          # Check if it also closes on same line
          if String.contains?(line, "*/") do
            # Check which comes last
            open_pos = :binary.match(line, "/*") |> elem(0)
            close_pos = :binary.match(line, "*/") |> elem(0)
            {close_pos < open_pos, true}
          else
            {true, true}
          end
        
        true ->
          {in_comment, in_comment}
      end
    end)
    
    in_comment
  end
  
  defp is_in_string_literal?(code, file_content, line_number) do
    lines = String.split(file_content, "\n")
    line = Enum.at(lines, line_number - 1, "")
    
    # Check various string literal patterns
    cond do
      # Direct string assignment patterns
      String.match?(line, ~r/=\s*["'`].*eval.*["'`]/) and
      String.trim(line) == code ->
        true
        
      # Check if the code includes quotes as part of the pattern
      # e.g., code = "const warning = 'Never use eval()'"
      String.match?(code, ~r/["'`].*eval.*["'`]/) ->
        # It's a string literal assignment
        true
        
      # Template literal check
      String.contains?(line, "`") and String.contains?(line, "eval") and
      not String.match?(line, ~r/eval\s*\(/) ->
        true
        
      # Python/Ruby string patterns
      String.match?(line, ~r/=\s*["'].*exec.*["']/) ->
        true
        
      true ->
        false
    end
  end
  
  defp analyze_vulnerability_context(vuln, file_content) do
    # Use TaintAnalyzer for comprehensive taint analysis
    line_number = vuln["line"] || 1
    taint_analysis = TaintAnalyzer.analyze(vuln["code"], file_content, line_number)
    
    # Build context from taint analysis
    context = %{
      "inUserInputFlow" => taint_analysis.direct_input || taint_analysis.tainted_flow,
      "hasValidation" => taint_analysis.has_sanitization,
      "taintLevel" => taint_analysis.taint_level,
      "taintConfidence" => taint_analysis.confidence,
      "directInput" => taint_analysis.direct_input,
      "taintedFlow" => taint_analysis.tainted_flow,
      "suspiciousName" => taint_analysis.suspicious_name,
      "hasSanitization" => taint_analysis.has_sanitization
    }
    
    # Add hops information if available
    context = if Map.has_key?(taint_analysis, :hops) do
      Map.put(context, "taintHops", taint_analysis.hops)
    else
      context
    end
    
    {:ok, context}
  end
  
  
  defp calculate_confidence(context) do
    # Use taint confidence from TaintAnalyzer if available
    # This provides multi-level confidence based on taint analysis
    if Map.has_key?(context, "taintConfidence") do
      context["taintConfidence"]
    else
      # Fallback to simple calculation if taint analysis not available
      if context["inUserInputFlow"] do
        0.95
      else
        0.8
      end
    end
  end
  
  defp calculate_stats(validated_results) do
    total = length(validated_results)
    validated = Enum.count(validated_results, fn r -> r["isValid"] == true end)
    rejected = total - validated
    
    %{
      "total" => total,
      "validated" => validated,
      "rejected" => rejected
    }
  end
  
  # Helper function to convert vulnerability type string to atom
  defp to_vulnerability_atom(type) when is_binary(type) do
    type
    |> String.downcase()
    |> String.replace("-", "_")
    |> String.to_atom()
  end
  defp to_vulnerability_atom(type), do: type
  
  # Helper function to detect language from file extension
  defp detect_language(file_path) when is_binary(file_path) do
    cond do
      String.ends_with?(file_path, [".js", ".jsx", ".ts", ".tsx", ".mjs"]) -> "javascript"
      String.ends_with?(file_path, [".py"]) -> "python"
      String.ends_with?(file_path, [".rb", ".erb"]) -> "ruby"
      String.ends_with?(file_path, [".php"]) -> "php"
      String.ends_with?(file_path, [".ex", ".exs"]) -> "elixir"
      String.ends_with?(file_path, [".go"]) -> "go"
      String.ends_with?(file_path, [".java"]) -> "java"
      String.ends_with?(file_path, [".rs"]) -> "rust"
      true -> "javascript"  # Default to JavaScript
    end
  end
  defp detect_language(_), do: "javascript"
end