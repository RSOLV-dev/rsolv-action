defmodule RsolvWeb.Api.V1.VulnerabilityValidationRouter do
  @moduledoc """
  Router module that selects the appropriate validation controller based on feature flag.
  Allows gradual rollout of the new false positive caching system.
  """

  use RsolvWeb, :controller
  use OpenApiSpex.ControllerSpecs

  alias FunWithFlags, as: Flags
  alias RsolvWeb.Api.V1.VulnerabilityValidationController
  alias RsolvWeb.Api.V1.VulnerabilityValidationControllerWithCache

  alias RsolvWeb.Schemas.Vulnerability.{
    VulnerabilityValidateRequest,
    VulnerabilityValidateResponse
  }

  alias RsolvWeb.Schemas.Error.ErrorResponse

  require Logger

  plug RsolvWeb.Plugs.ApiAuthentication
  plug OpenApiSpex.Plug.CastAndValidate, json_render_error_v2: true

  tags(["Vulnerabilities"])

  operation(:validate,
    summary: "Validate potential vulnerabilities using AST analysis",
    description: """
    Validates detected vulnerabilities using Abstract Syntax Tree (AST) analysis to reduce false positives.

    **Validation Process:**
    1. **File Path Classification** - Categorizes files (vendor, test, source) and adjusts confidence
    2. **Safe Pattern Detection** - Identifies known-safe patterns (e.g., parameterized queries)
    3. **Comment/String Detection** - Filters code in comments or string literals
    4. **Taint Analysis** - Traces data flow from user input to vulnerable sinks
    5. **Confidence Scoring** - Multi-level confidence based on context

    **False Positive Reduction:**
    - Automatically filters vendor files with low confidence
    - Detects safe library wrappers (e.g., `db.query()` vs manual string concat)
    - Identifies validation/sanitization in code flow
    - Caches validation results to improve performance

    **Feature Flag:** `false_positive_caching`
    - When enabled, uses caching controller for faster repeated validations
    - Can be forced via `FORCE_CACHE_CONTROLLER=true` environment variable

    **Response Includes:**
    - Validated vulnerabilities with confidence scores
    - AST context (user input flow, validation present, file classification)
    - Statistics (total, validated, rejected counts)
    - Cache statistics (hits, misses)
    """,
    request_body:
      {"Vulnerability validation request", "application/json", VulnerabilityValidateRequest},
    responses: [
      ok:
        {"Validation completed successfully", "application/json", VulnerabilityValidateResponse},
      bad_request: {"Invalid request format", "application/json", ErrorResponse},
      unauthorized: {"Invalid or missing API key", "application/json", ErrorResponse},
      internal_server_error: {"Validation failed", "application/json", ErrorResponse}
    ],
    security: [%{"ApiKeyAuth" => []}]
  )

  def validate(conn, params) do
    Logger.info("ðŸš€ [Router Debug] Received validation request")
    # Check for environment variable override first (for staging testing)
    use_cache =
      cond do
        System.get_env("FORCE_CACHE_CONTROLLER") == "true" ->
          Logger.debug("Using cached validation controller (forced via env var)")
          true

        System.get_env("FORCE_CACHE_CONTROLLER") == "false" ->
          Logger.debug("Using standard validation controller (forced via env var)")
          false

        true ->
          # Check if the false positive caching feature is enabled
          case Flags.enabled?(:false_positive_caching) do
            {:ok, true} ->
              Logger.debug("Using cached validation controller (via feature flag)")
              true

            _ ->
              Logger.debug("Using standard validation controller (feature flag disabled)")
              false
          end
      end

    if use_cache do
      Logger.info("ðŸŽ¯ [Router Debug] Routing to VulnerabilityValidationControllerWithCache")
      VulnerabilityValidationControllerWithCache.validate(conn, params)
    else
      Logger.info("ðŸŽ¯ [Router Debug] Routing to VulnerabilityValidationController")
      VulnerabilityValidationController.validate(conn, params)
    end
  end
end
