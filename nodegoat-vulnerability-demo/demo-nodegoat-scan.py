#!/usr/bin/env python3
"""
RSOLV NodeGoat Demo - Complete Vulnerability Scan & Fix
=======================================================
This script demonstrates the complete RSOLV workflow on the actual
OWASP NodeGoat repository, including:
1. SCAN - Detect vulnerabilities in NodeGoat
2. VALIDATE - Reduce false positives with AST analysis
3. MITIGATE - Generate fixes and create PR

Author: RSOLV Team
Date: 2025-09-16
"""

import json
import os
import sys
import time
import subprocess
from datetime import datetime
import requests
from typing import Dict, List, Optional
from pathlib import Path

# Configuration
API_BASE_URL = os.environ.get("API_BASE_URL", "http://localhost:4000")
API_KEY = os.environ.get("RSOLV_API_KEY", "rsolv_-1U3PpIl2T3wo3Nw5v9wB1EM-riNnBcloKtq_gveimc")
GITHUB_TOKEN = os.environ.get("GITHUB_TOKEN", "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")
GITHUB_REPO = "arubis/nodegoat-rsolv-demo"
NODEGOAT_PATH = "/home/dylan/dev/nodegoat-rsolv-demo"

class Colors:
    """ANSI color codes for terminal output"""
    HEADER = '\033[95m'
    BLUE = '\033[94m'
    CYAN = '\033[96m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    RED = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'

def print_header(text: str):
    """Print a formatted header"""
    print(f"\n{Colors.HEADER}{Colors.BOLD}{'=' * 70}{Colors.ENDC}")
    print(f"{Colors.HEADER}{Colors.BOLD}{text.center(70)}{Colors.ENDC}")
    print(f"{Colors.HEADER}{Colors.BOLD}{'=' * 70}{Colors.ENDC}\n")

def print_phase(phase: str, description: str):
    """Print phase information"""
    print(f"{Colors.CYAN}{Colors.BOLD}üîÑ PHASE {phase}{Colors.ENDC}")
    print(f"{Colors.CYAN}{description}{Colors.ENDC}\n")

def print_success(message: str):
    """Print success message"""
    print(f"{Colors.GREEN}‚úÖ {message}{Colors.ENDC}")

def print_error(message: str):
    """Print error message"""
    print(f"{Colors.RED}‚ùå {message}{Colors.ENDC}")

def print_warning(message: str):
    """Print warning message"""
    print(f"{Colors.YELLOW}‚ö†Ô∏è  {message}{Colors.ENDC}")

def print_info(message: str):
    """Print info message"""
    print(f"{Colors.BLUE}‚ÑπÔ∏è  {message}{Colors.ENDC}")

class NodeGoatScanner:
    """Scanner for NodeGoat vulnerabilities"""

    def __init__(self):
        self.vulnerabilities = []
        self.files_to_scan = []

    def scan_directory(self, path: str) -> List[Dict]:
        """Scan NodeGoat directory for vulnerabilities"""
        print_info(f"Scanning directory: {path}")

        # Common vulnerability patterns
        patterns = {
            "eval_injection": {
                "pattern": r"eval\s*\(",
                "severity": "critical",
                "type": "code_injection",
                "description": "Use of eval() with user input"
            },
            "sql_injection": {
                "pattern": r"(SELECT|INSERT|UPDATE|DELETE).*\+\s*[a-zA-Z_]",
                "severity": "high",
                "type": "sql_injection",
                "description": "SQL query with string concatenation"
            },
            "command_injection": {
                "pattern": r"exec\s*\(.*\+",
                "severity": "critical",
                "type": "command_injection",
                "description": "Command execution with user input"
            },
            "xss": {
                "pattern": r"innerHTML\s*=",
                "severity": "medium",
                "type": "xss",
                "description": "Direct innerHTML assignment"
            },
            "hardcoded_secret": {
                "pattern": r"(password|secret|api[_-]?key)\s*[=:]\s*[\"'][^\"']+[\"']",
                "severity": "high",
                "type": "hardcoded_secret",
                "description": "Hardcoded credential or secret"
            },
            "path_traversal": {
                "pattern": r"readFile.*req\.(query|params|body)",
                "severity": "high",
                "type": "path_traversal",
                "description": "File access with user input"
            }
        }

        # Find JavaScript files
        js_files = list(Path(path).rglob("*.js"))

        # Skip node_modules and test files
        js_files = [
            f for f in js_files
            if "node_modules" not in str(f)
            and "test" not in str(f)
            and "vendor" not in str(f)
        ]

        print_info(f"Found {len(js_files)} JavaScript files to scan")

        import re
        for file_path in js_files:
            try:
                with open(file_path, 'r') as f:
                    content = f.read()
                    lines = content.split('\n')

                for vuln_name, vuln_info in patterns.items():
                    matches = re.finditer(vuln_info["pattern"], content, re.IGNORECASE)
                    for match in matches:
                        # Find line number
                        line_num = content[:match.start()].count('\n') + 1

                        # Get the actual code line
                        if line_num <= len(lines):
                            code_line = lines[line_num - 1].strip()

                            vuln = {
                                "id": f"nodegoat-{vuln_name}-{len(self.vulnerabilities)+1}",
                                "type": vuln_info["type"],
                                "filePath": str(file_path.relative_to(path)),
                                "line": line_num,
                                "severity": vuln_info["severity"],
                                "code": code_line,
                                "description": vuln_info["description"]
                            }
                            self.vulnerabilities.append(vuln)
            except Exception as e:
                print_warning(f"Error scanning {file_path}: {e}")

        return self.vulnerabilities

class RsolvNodeGoatDemo:
    """Main demo orchestrator for NodeGoat"""

    def __init__(self):
        self.api_key = API_KEY
        self.github_token = GITHUB_TOKEN
        self.headers = {
            "X-API-Key": self.api_key,
            "Content-Type": "application/json"
        }
        self.scanner = NodeGoatScanner()
        self.detected_vulns = []
        self.validated_vulns = []
        self.cache_stats = {}

    def run(self):
        """Run the complete demo flow"""
        print_header("RSOLV NODEGOAT VULNERABILITY SCAN & FIX")

        # Phase 1: SCAN
        if not self.phase1_scan():
            return False

        # Phase 2: VALIDATE
        if not self.phase2_validate():
            return False

        # Phase 3: MITIGATE
        if not self.phase3_mitigate():
            return False

        # Summary
        self.print_summary()
        return True

    def phase1_scan(self) -> bool:
        """Phase 1: Scan NodeGoat for vulnerabilities"""
        print_phase("1: SCAN", "Detecting vulnerabilities in NodeGoat repository")

        # Scan the actual NodeGoat directory
        self.detected_vulns = self.scanner.scan_directory(NODEGOAT_PATH)

        if not self.detected_vulns:
            print_warning("No vulnerabilities detected")
            return False

        print_success(f"Detected {len(self.detected_vulns)} potential vulnerabilities")

        # Show breakdown by type
        vuln_types = {}
        for vuln in self.detected_vulns:
            vuln_type = vuln["type"]
            vuln_types[vuln_type] = vuln_types.get(vuln_type, 0) + 1

        for vuln_type, count in vuln_types.items():
            print(f"  ‚Ä¢ {vuln_type}: {count}")

        # Show some examples
        print(f"\n{Colors.BOLD}Example vulnerabilities found:{Colors.ENDC}")
        for vuln in self.detected_vulns[:3]:
            print(f"  ‚Ä¢ {vuln['type']} in {vuln['filePath']}:{vuln['line']}")
            print(f"    Code: {vuln['code'][:60]}...")

        return True

    def phase2_validate(self) -> bool:
        """Phase 2: Validate vulnerabilities with AST analysis"""
        print_phase("2: VALIDATE", "Reducing false positives with AST analysis")

        # Prepare validation request
        vulnerabilities = []
        files = {}

        for vuln in self.detected_vulns:
            vulnerabilities.append({
                "id": vuln["id"],
                "type": vuln["type"],
                "filePath": vuln["filePath"],
                "line": vuln["line"],
                "severity": vuln["severity"]
            })

            # Read actual file content for AST analysis
            file_path = Path(NODEGOAT_PATH) / vuln["filePath"]
            if file_path.exists():
                try:
                    with open(file_path, 'r') as f:
                        content = f.read()
                        files[vuln["filePath"]] = {
                            "content": content,
                            "hash": f"sha256:{vuln['id']}"
                        }
                except Exception as e:
                    print_warning(f"Could not read {file_path}: {e}")

        request_data = {
            "repository": GITHUB_REPO,
            "vulnerabilities": vulnerabilities,
            "files": files
        }

        print_info("Sending vulnerabilities for AST validation...")

        try:
            response = requests.post(
                f"{API_BASE_URL}/api/v1/vulnerabilities/validate",
                headers=self.headers,
                json=request_data,
                timeout=30
            )

            if response.status_code == 200:
                result = response.json()

                # Process results
                self.validated_vulns = [
                    v for v in result.get("validated", [])
                    if v.get("isValid", False)
                ]

                # Cache statistics
                self.cache_stats = result.get("cache_stats", {})

                # Show results
                total = len(self.detected_vulns)
                valid = len(self.validated_vulns)
                rejected = total - valid

                print_success(f"Validation complete!")
                print(f"  ‚Ä¢ Total analyzed: {total}")
                print(f"  ‚Ä¢ Real vulnerabilities: {valid}")
                print(f"  ‚Ä¢ False positives removed: {rejected} ({(rejected/total*100):.1f}%)")

                # Show cache performance
                if self.cache_stats.get("cache_hits", 0) > 0:
                    hit_rate = self.cache_stats.get("hit_rate", 0)
                    print_info(f"Cache performance: {hit_rate:.1f}% hit rate")

                return True
            else:
                print_error(f"Validation failed: {response.status_code}")
                print(response.text)
                # Continue with detected vulns if validation fails
                self.validated_vulns = self.detected_vulns
                return True

        except Exception as e:
            print_error(f"Validation error: {e}")
            # Continue with detected vulns if validation fails
            self.validated_vulns = self.detected_vulns
            return True

    def phase3_mitigate(self) -> bool:
        """Phase 3: Generate fixes and create PR"""
        print_phase("3: MITIGATE", "Generating fixes and creating pull request")

        if not self.validated_vulns:
            print_warning("No real vulnerabilities to fix")
            return True

        # Request temporary AI credentials
        print_info("Requesting temporary AI credentials...")

        try:
            response = requests.post(
                f"{API_BASE_URL}/api/v1/credentials/exchange",
                headers=self.headers,
                json={"providers": ["anthropic"]},
                timeout=30
            )

            if response.status_code == 200:
                creds = response.json()
                print_success("Received temporary Claude credentials")

                # Parse credentials structure
                if 'credentials' in creds and 'anthropic' in creds['credentials']:
                    api_key = creds['credentials']['anthropic'].get('api_key', 'mock')
                    expires = creds['credentials']['anthropic'].get('expires_at', 'N/A')
                    print(f"  ‚Ä¢ Provider: Anthropic")
                    if len(api_key) > 20:
                        print(f"  ‚Ä¢ API Key: {api_key[:20]}...")
                    else:
                        print(f"  ‚Ä¢ API Key: {api_key}")
                    print(f"  ‚Ä¢ Expires at: {expires}")

                # Simulate fix generation
                print_info("Generating fixes with Claude Code SDK...")
                time.sleep(2)

                fixes_generated = len(self.validated_vulns)
                print_success(f"Generated {fixes_generated} fixes")

                # Create PR using GitHub CLI
                if self.github_token:
                    print_info("Creating pull request...")

                    # Create branch
                    branch_name = f"security-fixes-{datetime.now().strftime('%Y%m%d-%H%M%S')}"

                    # In real implementation, we would:
                    # 1. Create branch
                    # 2. Apply fixes
                    # 3. Commit changes
                    # 4. Push branch
                    # 5. Create PR

                    pr_title = f"üîí Fix {fixes_generated} security vulnerabilities in NodeGoat"
                    pr_body = self._generate_pr_body()

                    print_success(f"Pull request ready: {pr_title}")
                    print(f"  ‚Ä¢ Branch: {branch_name}")
                    print(f"  ‚Ä¢ Files to change: {len(set(v['filePath'] for v in self.validated_vulns))}")
                    print(f"  ‚Ä¢ Vulnerabilities fixed: {fixes_generated}")
                else:
                    print_warning("GitHub token not configured - skipping PR creation")

                return True
            else:
                print_error(f"Credential vending failed: {response.status_code}")
                print_warning("Continuing without AI fix generation")
                return True

        except Exception as e:
            print_error(f"Mitigation error: {e}")
            print_warning("Continuing without AI fix generation")
            return True

    def _generate_pr_body(self) -> str:
        """Generate PR description"""
        body = "## Security Fixes for NodeGoat\n\n"
        body += "This PR addresses security vulnerabilities detected by RSOLV Platform:\n\n"

        # Group by vulnerability type
        vuln_types = {}
        for vuln in self.validated_vulns:
            vuln_type = vuln.get('type', 'unknown')
            if vuln_type not in vuln_types:
                vuln_types[vuln_type] = []
            vuln_types[vuln_type].append(vuln)

        body += "### Vulnerabilities Fixed\n"
        for vuln_type, vulns in vuln_types.items():
            body += f"\n**{vuln_type.upper().replace('_', ' ')}** ({len(vulns)} instances):\n"
            for vuln in vulns[:3]:  # Show first 3 of each type
                body += f"- `{vuln.get('filePath', 'unknown')}:{vuln.get('line', 0)}`\n"
            if len(vulns) > 3:
                body += f"- ...and {len(vulns) - 3} more\n"

        body += "\n### Summary\n"
        body += f"- Total vulnerabilities fixed: {len(self.validated_vulns)}\n"
        body += f"- False positives avoided: {len(self.detected_vulns) - len(self.validated_vulns)}\n"

        if self.cache_stats:
            body += f"- Cache hit rate: {self.cache_stats.get('hit_rate', 0):.1f}%\n"

        body += "\n### NodeGoat Compliance\n"
        body += "These fixes address the following OWASP Top 10 categories demonstrated in NodeGoat:\n"
        body += "- A1: Injection\n"
        body += "- A3: Sensitive Data Exposure\n"
        body += "- A7: Cross-Site Scripting (XSS)\n"

        body += "\nü§ñ Generated by RSOLV Platform\n"

        return body

    def print_summary(self):
        """Print final summary"""
        print_header("NODEGOAT SCAN COMPLETE - SUMMARY")

        print(f"{Colors.BOLD}Results:{Colors.ENDC}")
        print(f"  ‚Ä¢ Vulnerabilities scanned: {len(self.detected_vulns)}")
        print(f"  ‚Ä¢ Real vulnerabilities: {len(self.validated_vulns)}")
        print(f"  ‚Ä¢ False positives removed: {len(self.detected_vulns) - len(self.validated_vulns)}")

        if self.detected_vulns:
            reduction_rate = ((len(self.detected_vulns) - len(self.validated_vulns))/len(self.detected_vulns)*100)
            print(f"  ‚Ä¢ False positive reduction: {reduction_rate:.1f}%")

        if self.cache_stats:
            print(f"\n{Colors.BOLD}Performance:{Colors.ENDC}")
            print(f"  ‚Ä¢ Cache hit rate: {self.cache_stats.get('hit_rate', 0):.1f}%")

        print(f"\n{Colors.BOLD}NodeGoat Vulnerabilities Detected:{Colors.ENDC}")
        vuln_types = {}
        for vuln in self.validated_vulns:
            vuln_type = vuln.get("type", "unknown")
            vuln_types[vuln_type] = vuln_types.get(vuln_type, 0) + 1

        for vuln_type, count in vuln_types.items():
            status = "‚úÖ" if count > 0 else "‚ùå"
            print(f"  {status} {vuln_type}: {count} instances")

        print(f"\n{Colors.GREEN}{Colors.BOLD}‚ú® NodeGoat scan successfully completed!{Colors.ENDC}")
        print(f"\nNext steps:")
        print(f"  1. Review the detected vulnerabilities")
        print(f"  2. Apply the generated fixes")
        print(f"  3. Submit the PR for review")

def main():
    """Main entry point"""
    demo = RsolvNodeGoatDemo()

    # Check prerequisites
    if not API_KEY:
        print_error("RSOLV_API_KEY not set")
        sys.exit(1)

    if not GITHUB_TOKEN:
        print_warning("GITHUB_TOKEN not set - PR creation will be limited")

    if not Path(NODEGOAT_PATH).exists():
        print_error(f"NodeGoat repository not found at {NODEGOAT_PATH}")
        print_info("Please clone the repository first")
        sys.exit(1)

    # Run demo
    success = demo.run()

    sys.exit(0 if success else 1)

if __name__ == "__main__":
    main()