#!/usr/bin/env python3
"""
RSOLV Complete End-to-End Demo Test Script
===========================================
This script programmatically demonstrates the entire RSOLV customer demo flow:
1. SCAN - Pattern detection
2. VALIDATE - AST-based false positive reduction
3. MITIGATE - Credential vending for fixes

Author: RSOLV Team
Date: 2025-09-16
"""

import json
import os
import sys
import time
from datetime import datetime
import requests
from typing import Dict, List, Optional, Tuple

# Configuration
API_BASE_URL = "https://api.rsolv.dev"
API_KEY = os.environ.get("RSOLV_API_KEY", "rsolv_xud6j-kCuMwsQ371QNBkQvTi5gmfZQ98FPXbmNmhMio")

# Demo vulnerability samples
DEMO_VULNERABILITIES = {
    "sql_injection": {
        "id": "vuln-sql-001",
        "type": "sql_injection",
        "filePath": "routes/users.js",
        "line": 7,
        "severity": "high",
        "code_vulnerable": "const query = 'SELECT * FROM users WHERE id = ' + userId;",
        "code_safe": "const query = 'SELECT * FROM users WHERE id = ?'; // parameterized"
    },
    "command_injection": {
        "id": "vuln-cmd-002",
        "type": "command_injection",
        "filePath": "utils/backup.js",
        "line": 15,
        "severity": "critical",
        "code_vulnerable": "exec('tar -czf backup.tar.gz ' + userInput);",
        "code_safe": "execFile('tar', ['-czf', 'backup.tar.gz', userInput]);"
    },
    "xss": {
        "id": "vuln-xss-003",
        "type": "xss",
        "filePath": "views/profile.ejs",
        "line": 42,
        "severity": "medium",
        "code_vulnerable": "<div><%- userData.bio %></div>",
        "code_safe": "<div><%= userData.bio %></div>"
    },
    "hardcoded_secret": {
        "id": "vuln-secret-004",
        "type": "hardcoded_secret",
        "filePath": "config/db.js",
        "line": 3,
        "severity": "high",
        "code_vulnerable": "const API_KEY = 'sk-1234567890abcdef';",
        "code_safe": "const API_KEY = process.env.API_KEY;"
    },
    "path_traversal": {
        "id": "vuln-path-005",
        "type": "path_traversal",
        "filePath": "routes/files.js",
        "line": 28,
        "severity": "high",
        "code_vulnerable": "fs.readFile(req.query.filename, (err, data) => {",
        "code_safe": "const safePath = path.join(UPLOADS_DIR, path.basename(req.query.filename));"
    }
}

class Colors:
    """ANSI color codes for terminal output"""
    HEADER = '\033[95m'
    BLUE = '\033[94m'
    CYAN = '\033[96m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    RED = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

def print_header(text: str):
    """Print a formatted header"""
    print(f"\n{Colors.HEADER}{Colors.BOLD}{'=' * 60}{Colors.ENDC}")
    print(f"{Colors.HEADER}{Colors.BOLD}{text}{Colors.ENDC}")
    print(f"{Colors.HEADER}{Colors.BOLD}{'=' * 60}{Colors.ENDC}\n")

def print_phase(phase: str, description: str):
    """Print phase information"""
    print(f"{Colors.CYAN}{Colors.BOLD}üîÑ PHASE: {phase}{Colors.ENDC}")
    print(f"{Colors.CYAN}{description}{Colors.ENDC}\n")

def print_success(message: str):
    """Print success message"""
    print(f"{Colors.GREEN}‚úÖ {message}{Colors.ENDC}")

def print_error(message: str):
    """Print error message"""
    print(f"{Colors.RED}‚ùå {message}{Colors.ENDC}")

def print_info(message: str):
    """Print info message"""
    print(f"{Colors.BLUE}‚ÑπÔ∏è  {message}{Colors.ENDC}")

def print_warning(message: str):
    """Print warning message"""
    print(f"{Colors.YELLOW}‚ö†Ô∏è  {message}{Colors.ENDC}")

def test_phase_1_scan() -> Tuple[bool, List[Dict]]:
    """
    Phase 1: SCAN - Pattern Detection
    Fetches security patterns from RSOLV API
    """
    print_phase("1: SCAN", "Fetching security patterns from RSOLV API")

    try:
        response = requests.get(
            f"{API_BASE_URL}/api/v1/patterns",
            headers={"X-Api-Key": API_KEY},
            timeout=10
        )

        if response.status_code == 200:
            patterns = response.json()
            print_success(f"Retrieved {len(patterns)} security patterns")

            # Display pattern summary (patterns is a list of dicts)
            if isinstance(patterns, list):
                for pattern in patterns[:min(5, len(patterns))]:  # Show up to 5 patterns
                    if isinstance(pattern, dict):
                        print(f"  üìã {pattern.get('name', 'Unknown')} - {str(pattern.get('description', 'No description'))[:50]}...")

            return True, patterns
        else:
            print_error(f"Failed to fetch patterns: HTTP {response.status_code}")
            print(f"Response: {response.text}")
            return False, []

    except Exception as e:
        print_error(f"Error in SCAN phase: {str(e)}")
        return False, []

def test_phase_2_validate() -> Tuple[bool, Dict]:
    """
    Phase 2: VALIDATE - AST-based false positive reduction
    Tests both vulnerable and safe code patterns
    """
    print_phase("2: VALIDATE", "AST-based validation to reduce false positives (70-90% reduction)")

    results = {
        "total": 0,
        "validated": 0,
        "rejected": 0,
        "details": []
    }

    # Test each vulnerability type
    for vuln_type, vuln_data in DEMO_VULNERABILITIES.items():
        print(f"\n{Colors.BOLD}Testing {vuln_type}:{Colors.ENDC}")

        # Test 1: Actual vulnerability (should be validated as real)
        print(f"  ‚Üí Testing vulnerable code...")
        validation_payload = {
            "vulnerabilities": [{
                "id": vuln_data["id"],
                "type": vuln_data["type"],
                "filePath": vuln_data["filePath"],
                "line": vuln_data["line"],
                "severity": vuln_data["severity"]
            }],
            "files": {
                vuln_data["filePath"]: {
                    "content": vuln_data["code_vulnerable"]
                }
            }
        }

        try:
            response = requests.post(
                f"{API_BASE_URL}/api/v1/vulnerabilities/validate",
                headers={
                    "X-Api-Key": API_KEY,
                    "Content-Type": "application/json"
                },
                json=validation_payload,
                timeout=30
            )

            results["total"] += 1

            if response.status_code == 200:
                result = response.json()

                if result.get("validated") and len(result["validated"]) > 0:
                    vuln_result = result["validated"][0]
                    is_valid = vuln_result.get("isValid", False)
                    confidence = vuln_result.get("confidence", 0)

                    if is_valid:
                        print_success(f"    Correctly identified as REAL vulnerability (confidence: {confidence:.2f})")
                        results["validated"] += 1
                    else:
                        print_warning(f"    Marked as false positive (confidence: {confidence:.2f})")
                        print(f"    Reason: {vuln_result.get('reason', 'No reason provided')}")
                        results["rejected"] += 1

                    results["details"].append({
                        "type": vuln_type,
                        "test": "vulnerable",
                        "expected": True,
                        "actual": is_valid,
                        "confidence": confidence
                    })
            else:
                print_error(f"    Validation failed: HTTP {response.status_code}")

        except Exception as e:
            print_error(f"    Error: {str(e)}")

        # Test 2: Safe code (should be rejected as false positive)
        print(f"  ‚Üí Testing safe code...")
        validation_payload["files"][vuln_data["filePath"]]["content"] = vuln_data["code_safe"]

        try:
            response = requests.post(
                f"{API_BASE_URL}/api/v1/vulnerabilities/validate",
                headers={
                    "X-Api-Key": API_KEY,
                    "Content-Type": "application/json"
                },
                json=validation_payload,
                timeout=30
            )

            results["total"] += 1

            if response.status_code == 200:
                result = response.json()

                if result.get("validated") and len(result["validated"]) > 0:
                    vuln_result = result["validated"][0]
                    is_valid = vuln_result.get("isValid", False)
                    confidence = vuln_result.get("confidence", 0)

                    if not is_valid:
                        print_success(f"    Correctly identified as FALSE POSITIVE (confidence: {confidence:.2f})")
                        print(f"    Reason: {vuln_result.get('reason', 'No reason provided')}")
                        results["rejected"] += 1
                    else:
                        print_warning(f"    Incorrectly marked as real vulnerability")
                        results["validated"] += 1

                    results["details"].append({
                        "type": vuln_type,
                        "test": "safe",
                        "expected": False,
                        "actual": is_valid,
                        "confidence": confidence
                    })
            else:
                print_error(f"    Validation failed: HTTP {response.status_code}")

        except Exception as e:
            print_error(f"    Error: {str(e)}")

    # Calculate false positive reduction
    if results["total"] > 0:
        accuracy = (results["rejected"] / results["total"]) * 100
        print(f"\n{Colors.BOLD}Validation Results:{Colors.ENDC}")
        print(f"  Total tests: {results['total']}")
        print(f"  Correctly validated: {results['validated']}")
        print(f"  Correctly rejected (false positives): {results['rejected']}")
        print(f"  False positive reduction rate: {accuracy:.1f}%")

        success = accuracy >= 70  # Target is 70-90% reduction
        return success, results
    else:
        return False, results

def test_phase_3_mitigate() -> Tuple[bool, Dict]:
    """
    Phase 3: MITIGATE - Credential vending for AI-powered fixes
    """
    print_phase("3: MITIGATE", "Credential vending for AI-powered vulnerability fixes")

    try:
        response = requests.post(
            f"{API_BASE_URL}/api/v1/credentials/exchange",
            headers={
                "X-Api-Key": API_KEY,
                "Content-Type": "application/json"
            },
            json={
                "providers": ["anthropic"]
            },
            timeout=10
        )

        if response.status_code == 200:
            credentials = response.json()
            print_success("Successfully obtained AI credentials")

            if "credentials" in credentials and "anthropic" in credentials["credentials"]:
                api_key = credentials["credentials"]["anthropic"]["api_key"]
                expires_at = credentials["credentials"]["anthropic"]["expires_at"]

                # Validate credential format
                if api_key.startswith("sk-ant-"):
                    print_success(f"  Valid Anthropic API key format")
                    print_info(f"  Expires at: {expires_at}")
                    print_info(f"  Key prefix: {api_key[:20]}...")

                    # Parse expiration time
                    from datetime import datetime
                    expiry = datetime.fromisoformat(expires_at.replace('Z', '+00:00'))
                    now = datetime.now(expiry.tzinfo)
                    ttl_minutes = (expiry - now).total_seconds() / 60

                    print_info(f"  Time to live: {ttl_minutes:.1f} minutes")

                    return True, {
                        "api_key": api_key,
                        "expires_at": expires_at,
                        "ttl_minutes": ttl_minutes
                    }
                else:
                    print_warning("Unexpected API key format")
                    return False, {}
            else:
                print_error("Unexpected response structure")
                return False, {}
        else:
            print_error(f"Failed to obtain credentials: HTTP {response.status_code}")
            print(f"Response: {response.text}")
            return False, {}

    except Exception as e:
        print_error(f"Error in MITIGATE phase: {str(e)}")
        return False, {}

def test_cache_performance() -> Tuple[bool, Dict]:
    """
    Test caching performance by submitting duplicate vulnerabilities
    """
    print_phase("CACHE TEST", "Testing validation cache for performance optimization")

    # Create a test vulnerability
    test_vuln = {
        "vulnerabilities": [{
            "id": "cache-test-001",
            "type": "sql_injection",
            "filePath": "test/cache.js",
            "line": 10,
            "severity": "high"
        }],
        "files": {
            "test/cache.js": {
                "content": "const query = 'SELECT * FROM users'; // Safe static query"
            }
        }
    }

    cache_stats = {
        "requests": [],
        "cache_hits": 0,
        "cache_misses": 0
    }

    print("Sending 5 identical requests to test cache...")

    for i in range(5):
        start_time = time.time()

        try:
            response = requests.post(
                f"{API_BASE_URL}/api/v1/vulnerabilities/validate",
                headers={
                    "X-Api-Key": API_KEY,
                    "Content-Type": "application/json"
                },
                json=test_vuln,
                timeout=30
            )

            elapsed = (time.time() - start_time) * 1000  # Convert to ms

            if response.status_code == 200:
                result = response.json()

                # Check cache stats if available
                if "cache_stats" in result:
                    if result["cache_stats"].get("cache_hits", 0) > 0:
                        cache_stats["cache_hits"] += 1
                        print_success(f"  Request {i+1}: CACHE HIT - {elapsed:.1f}ms")
                    else:
                        cache_stats["cache_misses"] += 1
                        print_info(f"  Request {i+1}: CACHE MISS - {elapsed:.1f}ms")
                else:
                    # Check for fromCache flag in validated results
                    if result.get("validated") and result["validated"][0].get("fromCache"):
                        cache_stats["cache_hits"] += 1
                        print_success(f"  Request {i+1}: CACHE HIT - {elapsed:.1f}ms")
                    else:
                        cache_stats["cache_misses"] += 1
                        print_info(f"  Request {i+1}: CACHE MISS - {elapsed:.1f}ms")

                cache_stats["requests"].append({
                    "request": i + 1,
                    "elapsed_ms": elapsed,
                    "cached": result.get("validated", [{}])[0].get("fromCache", False)
                })

        except Exception as e:
            print_error(f"  Request {i+1}: Error - {str(e)}")

        # Small delay between requests
        if i < 4:
            time.sleep(0.1)

    # Analyze cache performance
    if cache_stats["cache_hits"] > 0:
        hit_rate = (cache_stats["cache_hits"] / 5) * 100
        print(f"\n{Colors.BOLD}Cache Performance:{Colors.ENDC}")
        print(f"  Cache hit rate: {hit_rate:.0f}%")
        print(f"  Cache hits: {cache_stats['cache_hits']}")
        print(f"  Cache misses: {cache_stats['cache_misses']}")

        # Calculate average response times
        if cache_stats["requests"]:
            cached_times = [r["elapsed_ms"] for r in cache_stats["requests"] if r["cached"]]
            uncached_times = [r["elapsed_ms"] for r in cache_stats["requests"] if not r["cached"]]

            if cached_times:
                print(f"  Avg cached response: {sum(cached_times)/len(cached_times):.1f}ms")
            if uncached_times:
                print(f"  Avg uncached response: {sum(uncached_times)/len(uncached_times):.1f}ms")

        return True, cache_stats
    else:
        print_warning("Cache does not appear to be working")
        return False, cache_stats

def run_full_demo():
    """
    Run the complete RSOLV demo flow
    """
    print_header("RSOLV COMPLETE END-TO-END DEMO TEST")
    print(f"API Endpoint: {API_BASE_URL}")
    print(f"API Key: {API_KEY[:20]}...")
    print(f"Timestamp: {datetime.now().isoformat()}")

    # Track overall results
    demo_results = {
        "scan": False,
        "validate": False,
        "mitigate": False,
        "cache": False,
        "overall": False
    }

    # Phase 1: SCAN
    print("\n" + "="*60)
    scan_success, patterns = test_phase_1_scan()
    demo_results["scan"] = scan_success

    # Phase 2: VALIDATE
    print("\n" + "="*60)
    validate_success, validation_results = test_phase_2_validate()
    demo_results["validate"] = validate_success

    # Phase 3: MITIGATE
    print("\n" + "="*60)
    mitigate_success, credentials = test_phase_3_mitigate()
    demo_results["mitigate"] = mitigate_success

    # Bonus: Cache Performance
    print("\n" + "="*60)
    cache_success, cache_results = test_cache_performance()
    demo_results["cache"] = cache_success

    # Overall Results
    print_header("DEMO RESULTS SUMMARY")

    phases_passed = sum([demo_results["scan"], demo_results["validate"], demo_results["mitigate"]])
    total_phases = 3

    print(f"{Colors.BOLD}Core Phases:{Colors.ENDC}")
    print(f"  {'‚úÖ' if demo_results['scan'] else '‚ùå'} SCAN - Pattern Detection")
    print(f"  {'‚úÖ' if demo_results['validate'] else '‚ùå'} VALIDATE - AST False Positive Reduction")
    print(f"  {'‚úÖ' if demo_results['mitigate'] else '‚ùå'} MITIGATE - Credential Vending")

    print(f"\n{Colors.BOLD}Additional Tests:{Colors.ENDC}")
    print(f"  {'‚úÖ' if demo_results['cache'] else '‚ùå'} Cache Performance")

    # Overall success determination
    demo_results["overall"] = phases_passed == total_phases

    if demo_results["overall"]:
        print_header("üéâ DEMO SUCCESSFUL - ALL PHASES WORKING!")
        print(f"{Colors.GREEN}The RSOLV platform is fully operational and ready for customer demonstrations.{Colors.ENDC}")
        print(f"\n{Colors.BOLD}Key Achievements:{Colors.ENDC}")
        print(f"  ‚Ä¢ Pattern detection API serving security patterns")
        print(f"  ‚Ä¢ AST validation reducing false positives by 70-90%")
        print(f"  ‚Ä¢ Credential vending providing temporary AI access")
        print(f"  ‚Ä¢ Cache optimization improving response times")
        return 0
    else:
        print_header("‚ö†Ô∏è DEMO PARTIALLY SUCCESSFUL")
        print(f"{Colors.YELLOW}Passed {phases_passed}/{total_phases} core phases.{Colors.ENDC}")
        print(f"\n{Colors.BOLD}Issues to Address:{Colors.ENDC}")
        if not demo_results["scan"]:
            print(f"  ‚Ä¢ Fix pattern API endpoint")
        if not demo_results["validate"]:
            print(f"  ‚Ä¢ Fix AST validation endpoint")
        if not demo_results["mitigate"]:
            print(f"  ‚Ä¢ Fix credential vending")
        return 1

if __name__ == "__main__":
    sys.exit(run_full_demo())