defmodule RSOLVWeb.WebhookIntegrationTest do
  use RSOLVWeb.ConnCase
  
  import Ecto.Query
  alias RsolvApi.Billing.FixAttempt
  alias RsolvApi.Repo
  
  @github_webhook_secret "test_secret"
  
  describe "complete webhook flow" do
    test "PR lifecycle: opened -> merged", %{conn: conn} do
      # Step 1: PR opened
      pr_opened_payload = %{
        "action" => "opened",
        "pull_request" => %{
          "number" => 42,
          "title" => "Fix SQL injection in user controller",
          "body" => "Fixes #100\n\nThis PR addresses the SQL injection vulnerability.\n\nGenerated by RSOLV",
          "html_url" => "https://github.com/test-org/test-repo/pull/42",
          "base" => %{
            "repo" => %{
              "name" => "test-repo",
              "owner" => %{"login" => "test-org"}
            }
          }
        }
      }
      
      conn = send_webhook(conn, pr_opened_payload)
      assert json_response(conn, 200) == %{"status" => "success", "result" => "pr_opened"}
      
      # Verify fix attempt was created
      fix_attempt = Repo.get_by!(FixAttempt, pr_number: 42)
      assert fix_attempt.status == "pending"
      assert fix_attempt.github_org == "test-org"
      assert fix_attempt.repo_name == "test-repo"
      assert fix_attempt.issue_number == 100
      assert fix_attempt.pr_title == "Fix SQL injection in user controller"
      assert fix_attempt.pr_url == "https://github.com/test-org/test-repo/pull/42"
      
      # Step 2: PR merged
      pr_merged_payload = %{
        "action" => "closed",
        "pull_request" => %{
          "number" => 42,
          "merged" => true,
          "merged_at" => "2025-06-03T16:00:00Z",
          "merged_by" => %{"login" => "reviewer"},
          "merge_commit_sha" => "abc123def456",
          "base" => %{
            "repo" => %{
              "name" => "test-repo",
              "owner" => %{"login" => "test-org"}
            }
          }
        }
      }
      
      conn = send_webhook(build_conn(), pr_merged_payload)
      assert json_response(conn, 200) == %{"status" => "success", "result" => "merged"}
      
      # Verify fix attempt was updated
      fix_attempt = Repo.get!(FixAttempt, fix_attempt.id)
      assert fix_attempt.status == "merged"
      assert fix_attempt.merged_at == ~U[2025-06-03 16:00:00.000000Z]
      assert fix_attempt.merged_by == "reviewer"
      assert fix_attempt.commit_sha == "abc123def456"
      assert fix_attempt.billing_status == "not_billed"
      assert fix_attempt.requires_manual_approval == true
    end
    
    test "PR rejected flow", %{conn: conn} do
      # Create a PR
      pr_opened_payload = %{
        "action" => "opened",
        "pull_request" => %{
          "number" => 43,
          "title" => "Fix XSS vulnerability",
          "body" => "Fixes #101\n\nGenerated by RSOLV",
          "base" => %{
            "repo" => %{
              "name" => "test-repo",
              "owner" => %{"login" => "test-org"}
            }
          }
        }
      }
      
      conn = send_webhook(conn, pr_opened_payload)
      assert json_response(conn, 200) == %{"status" => "success", "result" => "pr_opened"}
      
      # PR closed without merge
      pr_closed_payload = %{
        "action" => "closed",
        "pull_request" => %{
          "number" => 43,
          "merged" => false,
          "base" => %{
            "repo" => %{
              "name" => "test-repo",
              "owner" => %{"login" => "test-org"}
            }
          }
        }
      }
      
      conn = send_webhook(build_conn(), pr_closed_payload)
      assert json_response(conn, 200) == %{"status" => "success", "result" => "rejected"}
      
      # Verify status
      fix_attempt = Repo.get_by!(FixAttempt, pr_number: 43)
      assert fix_attempt.status == "rejected"
    end
    
    test "ignores non-RSOLV PRs", %{conn: conn} do
      # PR without RSOLV marker
      pr_payload = %{
        "action" => "opened",
        "pull_request" => %{
          "number" => 44,
          "title" => "Regular PR",
          "body" => "This is a regular PR, not from RSOLV",
          "base" => %{
            "repo" => %{
              "name" => "test-repo",
              "owner" => %{"login" => "test-org"}
            }
          }
        }
      }
      
      conn = send_webhook(conn, pr_payload)
      assert json_response(conn, 200) == %{"status" => "success", "result" => "ignored"}
      
      # Verify no fix attempt created
      assert Repo.get_by(FixAttempt, pr_number: 44) == nil
    end
    
    test "handles duplicate PR events idempotently", %{conn: conn} do
      payload = %{
        "action" => "opened",
        "pull_request" => %{
          "number" => 45,
          "title" => "Fix security issue",
          "body" => "Fixes #102\n\nGenerated by RSOLV",
          "base" => %{
            "repo" => %{
              "name" => "test-repo",
              "owner" => %{"login" => "test-org"}
            }
          }
        }
      }
      
      # Send twice
      conn = send_webhook(conn, payload)
      assert json_response(conn, 200)
      
      conn = send_webhook(build_conn(), payload)
      assert json_response(conn, 200)
      
      # Should only have one record
      attempts = Repo.all(from f in FixAttempt, where: f.pr_number == 45)
      assert length(attempts) == 1
    end
  end
  
  defp send_webhook(conn, payload) do
    raw_body = Jason.encode!(payload)
    signature = compute_signature(raw_body)
    
    conn
    |> put_req_header("x-github-event", "pull_request")
    |> put_req_header("x-hub-signature-256", signature)
    |> put_req_header("content-type", "application/json")
    |> assign(:test_mode, true)
    |> post("/webhook/github", payload)
  end
  
  defp compute_signature(payload) do
    "sha256=" <> Base.encode16(:crypto.mac(:hmac, :sha256, @github_webhook_secret, payload), case: :lower)
  end
end