import { describe, it, expect, beforeEach, vi } from 'vitest';
import { RepositoryScanner } from '../../src/scanner/repository-scanner.js';
import type { ScanConfig } from '../../src/scanner/types.js';
import type { Vulnerability } from '../../src/security/types.js';
import { VulnerabilityType } from '../../src/security/types.js';

// Mock all external dependencies
vi.mock('../../src/github/api.js');
vi.mock('../../src/security/safe-detector.js');
vi.mock('../../src/vendor/vendor-detector.js');

/**
 * Test suite for vulnerability grouping and severity prioritization
 *
 * Regression test for v3.8.0 bug where max_issues=1 would select
 * 3 HIGH severity issues over 1 CRITICAL severity issue.
 */
describe('RepositoryScanner - Vulnerability Grouping and Severity Prioritization', () => {
  let scanner: RepositoryScanner;
  let mockDetector: any;
  let mockGitHub: any;
  let mockVendorDetector: any;

  const createVulnerability = (
    type: VulnerabilityType,
    severity: 'critical' | 'high' | 'medium' | 'low',
    filePath: string,
    line: number = 10
  ): Vulnerability => ({
    type,
    severity,
    description: `${severity} ${type} detected`,
    message: `Test ${severity} vulnerability`,
    line,
    column: 5,
    filePath,
    snippet: 'test code',
    confidence: 90,
    cweId: 'CWE-001',
    owaspCategory: 'A01:2021',
    remediation: 'Fix it'
  });

  const createConfig = (overrides?: Partial<ScanConfig>): ScanConfig => ({
    repository: { owner: 'test', name: 'repo', defaultBranch: 'main' },
    enableASTValidation: false,
    createIssues: false,
    issueLabel: 'security',
    ...overrides
  });

  beforeEach(async () => {
    vi.clearAllMocks();

    const { getGitHubClient } = await import('../../src/github/api.js');
    const { SafeDetector } = await import('../../src/security/safe-detector.js');
    const { VendorDetector } = await import('../../src/vendor/vendor-detector.js');

    mockDetector = {
      detect: vi.fn().mockResolvedValue([]),
      cleanup: vi.fn()
    };

    mockVendorDetector = {
      isVendorFile: vi.fn().mockResolvedValue(false)
    };

    mockGitHub = {
      git: {
        getTree: vi.fn().mockResolvedValue({ data: { tree: [] } }),
        getBlob: vi.fn().mockResolvedValue({ data: { content: '', encoding: 'base64' } })
      }
    };

    vi.mocked(getGitHubClient).mockReturnValue(mockGitHub as any);
    vi.mocked(SafeDetector).mockImplementation(() => mockDetector as any);
    vi.mocked(VendorDetector).mockImplementation(() => mockVendorDetector as any);

    scanner = new RepositoryScanner();
  });

  describe('Severity Prioritization', () => {
    it('should prioritize CRITICAL over HIGH severity', async () => {
      mockDetector.detect.mockImplementation((content: string, language: string, filePath: string) => {
        if (filePath === 'file1.js') {
          return Promise.resolve([createVulnerability(VulnerabilityType.XSS, 'high', 'file1.js', 10)]);
        } else if (filePath === 'file2.js') {
          return Promise.resolve([createVulnerability(VulnerabilityType.XSS, 'high', 'file2.js', 20)]);
        } else if (filePath === 'file3.js') {
          return Promise.resolve([createVulnerability(VulnerabilityType.XSS, 'high', 'file3.js', 30)]);
        } else if (filePath === 'file4.js') {
          return Promise.resolve([createVulnerability(VulnerabilityType.SQL_INJECTION, 'critical', 'file4.js', 40)]);
        }
        return Promise.resolve([]);
      });

      mockGitHub.git.getTree.mockResolvedValue({
        data: {
          tree: [
            { type: 'blob', path: 'file1.js', sha: '1', size: 100 },
            { type: 'blob', path: 'file2.js', sha: '2', size: 100 },
            { type: 'blob', path: 'file3.js', sha: '3', size: 100 },
            { type: 'blob', path: 'file4.js', sha: '4', size: 100 }
          ]
        }
      });
      mockGitHub.git.getBlob.mockResolvedValue({
        data: { content: Buffer.from('test').toString('base64') }
      });

      const result = await scanner.scan(createConfig());

      // Groups should be sorted with CRITICAL first
      expect(result.groupedVulnerabilities).toHaveLength(2);
      expect(result.groupedVulnerabilities[0].severity).toBe('critical');
      expect(result.groupedVulnerabilities[0].count).toBe(1);
      expect(result.groupedVulnerabilities[1].severity).toBe('high');
      expect(result.groupedVulnerabilities[1].count).toBe(3);
    });

    it('should sort all severity levels correctly: CRITICAL > HIGH > MEDIUM > LOW', async () => {
      mockDetector.detect.mockImplementation((content: string, language: string, filePath: string) => {
        if (filePath === 'file1.js') {
          return Promise.resolve([createVulnerability(VulnerabilityType.XSS, 'low', 'file1.js')]);
        } else if (filePath === 'file2.js') {
          return Promise.resolve([createVulnerability(VulnerabilityType.SQL_INJECTION, 'critical', 'file2.js')]);
        } else if (filePath === 'file3.js') {
          return Promise.resolve([createVulnerability(VulnerabilityType.COMMAND_INJECTION, 'medium', 'file3.js')]);
        } else if (filePath === 'file4.js') {
          return Promise.resolve([createVulnerability(VulnerabilityType.PATH_TRAVERSAL, 'high', 'file4.js')]);
        }
        return Promise.resolve([]);
      });

      mockGitHub.git.getTree.mockResolvedValue({
        data: {
          tree: [
            { type: 'blob', path: 'file1.js', sha: '1', size: 100 },
            { type: 'blob', path: 'file2.js', sha: '2', size: 100 },
            { type: 'blob', path: 'file3.js', sha: '3', size: 100 },
            { type: 'blob', path: 'file4.js', sha: '4', size: 100 }
          ]
        }
      });
      mockGitHub.git.getBlob.mockResolvedValue({
        data: { content: Buffer.from('test').toString('base64') }
      });

      const result = await scanner.scan(createConfig());

      expect(result.groupedVulnerabilities).toHaveLength(4);
      expect(result.groupedVulnerabilities[0].severity).toBe('critical');
      expect(result.groupedVulnerabilities[1].severity).toBe('high');
      expect(result.groupedVulnerabilities[2].severity).toBe('medium');
      expect(result.groupedVulnerabilities[3].severity).toBe('low');
    });

    it('should sort by count when severity is the same', async () => {
      mockDetector.detect.mockImplementation((content: string, language: string, filePath: string) => {
        if (filePath === 'file1.js') {
          return Promise.resolve([createVulnerability(VulnerabilityType.XSS, 'high', 'file1.js', 10)]);
        } else if (filePath === 'file2.js') {
          return Promise.resolve([createVulnerability(VulnerabilityType.SQL_INJECTION, 'high', 'file2.js', 20)]);
        } else if (filePath === 'file3.js') {
          return Promise.resolve([createVulnerability(VulnerabilityType.SQL_INJECTION, 'high', 'file3.js', 30)]);
        } else if (filePath === 'file4.js') {
          return Promise.resolve([createVulnerability(VulnerabilityType.SQL_INJECTION, 'high', 'file4.js', 40)]);
        }
        return Promise.resolve([]);
      });

      mockGitHub.git.getTree.mockResolvedValue({
        data: {
          tree: [
            { type: 'blob', path: 'file1.js', sha: '1', size: 100 },
            { type: 'blob', path: 'file2.js', sha: '2', size: 100 },
            { type: 'blob', path: 'file3.js', sha: '3', size: 100 },
            { type: 'blob', path: 'file4.js', sha: '4', size: 100 }
          ]
        }
      });
      mockGitHub.git.getBlob.mockResolvedValue({
        data: { content: Buffer.from('test').toString('base64') }
      });

      const result = await scanner.scan(createConfig());

      // Both groups are HIGH severity, so should sort by count (descending)
      expect(result.groupedVulnerabilities).toHaveLength(2);
      expect(result.groupedVulnerabilities[0].type).toBe(VulnerabilityType.SQL_INJECTION);
      expect(result.groupedVulnerabilities[0].count).toBe(3);
      expect(result.groupedVulnerabilities[1].type).toBe(VulnerabilityType.XSS);
      expect(result.groupedVulnerabilities[1].count).toBe(1);
    });
  });

  describe('Grouping by Type and Severity', () => {
    it('should group vulnerabilities by type and severity combination', async () => {
      mockDetector.detect.mockImplementation((content: string, language: string, filePath: string) => {
        if (filePath === 'file1.js') {
          return Promise.resolve([createVulnerability(VulnerabilityType.XSS, 'high', 'file1.js')]);
        } else if (filePath === 'file2.js') {
          return Promise.resolve([createVulnerability(VulnerabilityType.XSS, 'high', 'file2.js')]);
        } else if (filePath === 'file3.js') {
          return Promise.resolve([createVulnerability(VulnerabilityType.XSS, 'medium', 'file3.js')]);
        } else if (filePath === 'file4.js') {
          return Promise.resolve([createVulnerability(VulnerabilityType.SQL_INJECTION, 'high', 'file4.js')]);
        }
        return Promise.resolve([]);
      });

      mockGitHub.git.getTree.mockResolvedValue({
        data: {
          tree: [
            { type: 'blob', path: 'file1.js', sha: '1', size: 100 },
            { type: 'blob', path: 'file2.js', sha: '2', size: 100 },
            { type: 'blob', path: 'file3.js', sha: '3', size: 100 },
            { type: 'blob', path: 'file4.js', sha: '4', size: 100 }
          ]
        }
      });
      mockGitHub.git.getBlob.mockResolvedValue({
        data: { content: Buffer.from('test').toString('base64') }
      });

      const result = await scanner.scan(createConfig());

      // Should create 3 groups: XSS-high (2), SQL_INJECTION-high (1), XSS-medium (1)
      expect(result.groupedVulnerabilities).toHaveLength(3);

      // First group: XSS-high or SQL_INJECTION-high (both high severity)
      const highGroups = result.groupedVulnerabilities.filter(g => g.severity === 'high');
      expect(highGroups).toHaveLength(2);

      // XSS-high should have 2 vulnerabilities
      const xssHigh = highGroups.find(g => g.type === VulnerabilityType.XSS);
      expect(xssHigh?.count).toBe(2);

      // SQL_INJECTION-high should have 1 vulnerability
      const sqlHigh = highGroups.find(g => g.type === VulnerabilityType.SQL_INJECTION);
      expect(sqlHigh?.count).toBe(1);

      // XSS-medium should be last (lower severity)
      const xssMedium = result.groupedVulnerabilities.find(g => g.severity === 'medium');
      expect(xssMedium?.type).toBe(VulnerabilityType.XSS);
      expect(xssMedium?.count).toBe(1);
    });

    it('should track unique file paths per group', async () => {
      // Set up detector to return different vulnerabilities per file
      mockDetector.detect.mockImplementation((content: string, language: string, filePath: string) => {
        if (filePath === 'file1.js') {
          return Promise.resolve([
            createVulnerability(VulnerabilityType.XSS, 'high', 'file1.js', 10),
            createVulnerability(VulnerabilityType.XSS, 'high', 'file1.js', 20) // Same file, different line
          ]);
        } else if (filePath === 'file2.js') {
          return Promise.resolve([
            createVulnerability(VulnerabilityType.XSS, 'high', 'file2.js', 30)
          ]);
        }
        return Promise.resolve([]);
      });

      mockGitHub.git.getTree.mockResolvedValue({
        data: {
          tree: [
            { type: 'blob', path: 'file1.js', sha: '1', size: 100 },
            { type: 'blob', path: 'file2.js', sha: '2', size: 100 }
          ]
        }
      });
      mockGitHub.git.getBlob.mockResolvedValue({
        data: { content: Buffer.from('test').toString('base64') }
      });

      const result = await scanner.scan(createConfig());

      expect(result.groupedVulnerabilities).toHaveLength(1);
      const group = result.groupedVulnerabilities[0];
      expect(group.count).toBe(3);
      expect(group.files).toHaveLength(2); // Only 2 unique files
      expect(group.files).toContain('file1.js');
      expect(group.files).toContain('file2.js');
    });
  });

  describe('Regression: v3.8.0 max_issues Bug', () => {
    it('should select CRITICAL vulnerability when max_issues=1, even if HIGH has more count', async () => {
      // Set up detector to return specific vulnerabilities per file
      mockDetector.detect.mockImplementation((content: string, language: string, filePath: string) => {
        if (filePath === 'file1.js') {
          return Promise.resolve([createVulnerability(VulnerabilityType.XSS, 'high', 'file1.js')]);
        } else if (filePath === 'file2.js') {
          return Promise.resolve([createVulnerability(VulnerabilityType.XSS, 'high', 'file2.js')]);
        } else if (filePath === 'file3.js') {
          return Promise.resolve([createVulnerability(VulnerabilityType.XSS, 'high', 'file3.js')]);
        } else if (filePath === 'file4.js') {
          return Promise.resolve([createVulnerability(VulnerabilityType.SQL_INJECTION, 'critical', 'file4.js')]);
        }
        return Promise.resolve([]);
      });

      mockGitHub.git.getTree.mockResolvedValue({
        data: {
          tree: [
            { type: 'blob', path: 'file1.js', sha: '1', size: 100 },
            { type: 'blob', path: 'file2.js', sha: '2', size: 100 },
            { type: 'blob', path: 'file3.js', sha: '3', size: 100 },
            { type: 'blob', path: 'file4.js', sha: '4', size: 100 }
          ]
        }
      });
      mockGitHub.git.getBlob.mockResolvedValue({
        data: { content: Buffer.from('test').toString('base64') }
      });

      const result = await scanner.scan(createConfig());

      // The first group should be CRITICAL (not HIGH with count=3)
      expect(result.groupedVulnerabilities[0].severity).toBe('critical');
      expect(result.groupedVulnerabilities[0].count).toBe(1);

      // When max_issues=1 is applied at issue creation level,
      // it will correctly pick the first group (CRITICAL)
      expect(result.groupedVulnerabilities[1].severity).toBe('high');
      expect(result.groupedVulnerabilities[1].count).toBe(3);
    });
  });
});
