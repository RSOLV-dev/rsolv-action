defmodule RSOLVWeb.WebhookControllerTest do
  use RSOLVWeb.ConnCase
  
  alias RsolvApi.Billing.FixAttempt
  alias RsolvApi.Repo

  @github_webhook_secret "default_dev_secret"
  
  describe "github webhook" do
    test "handles pull request opened event", %{conn: conn} do
      payload = %{
        "action" => "opened",
        "pull_request" => %{
          "number" => 123,
          "title" => "[RSOLV] Fix SQL injection vulnerability",
          "body" => "Fixes #456\n\nGenerated by RSOLV",
          "head" => %{
            "ref" => "rsolv/fix-sql-injection"
          },
          "labels" => [%{"name" => "rsolv:automated"}],
          "user" => %{"login" => "rsolv-bot"},
          "html_url" => "https://github.com/test-org/test-repo/pull/123",
          "base" => %{
            "repo" => %{
              "name" => "test-repo",
              "owner" => %{"login" => "test-org"}
            }
          }
        }
      }
      
      raw_body = Jason.encode!(payload)
      signature = compute_github_signature(raw_body)
      
      conn = conn
        |> put_req_header("x-github-event", "pull_request")
        |> put_req_header("x-hub-signature-256", signature)
        |> put_req_header("content-type", "application/json")
        |> assign(:test_mode, true)
        |> post("/webhook/github", payload)
        
      assert json_response(conn, 200) == %{
        "status" => "success",
        "result" => "pr_opened"
      }
      
      # Verify fix attempt was created
      fix_attempt = Repo.get_by(FixAttempt, pr_number: 123, github_org: "test-org")
      assert fix_attempt != nil
      assert fix_attempt.status == "pending"
    end
    
    test "handles pull request merged event", %{conn: conn} do
      # Create a pending fix attempt first
      {:ok, _} = %FixAttempt{}
        |> FixAttempt.changeset(%{
          github_org: "test-org",
          repo_name: "test-repo",
          pr_number: 124,
          status: "pending"
        })
        |> Repo.insert()
      
      payload = %{
        "action" => "closed",
        "pull_request" => %{
          "number" => 124,
          "merged" => true,
          "merged_at" => "2025-06-03T10:00:00Z",
          "merged_by" => %{"login" => "test-user"},
          "merge_commit_sha" => "abc123",
          "base" => %{
            "repo" => %{
              "name" => "test-repo",
              "owner" => %{"login" => "test-org"}
            }
          }
        }
      }
      
      raw_body = Jason.encode!(payload)
      signature = compute_github_signature(raw_body)
      
      conn = conn
        |> put_req_header("x-github-event", "pull_request")
        |> put_req_header("x-hub-signature-256", signature)
        |> put_req_header("content-type", "application/json")
        |> assign(:test_mode, true)
        |> post("/webhook/github", payload)
        
      assert json_response(conn, 200) == %{
        "status" => "success",
        "result" => "merged"
      }
      
      # Verify fix attempt was updated
      fix_attempt = Repo.get_by(FixAttempt, pr_number: 124)
      assert fix_attempt.status == "merged"
    end
    
    test "rejects request with invalid signature", %{conn: conn} do
      payload = %{"action" => "opened"}
      raw_body = Jason.encode!(payload)
      
      conn = conn
        |> put_req_header("x-github-event", "pull_request")
        |> put_req_header("x-hub-signature-256", "sha256=invalid")
        |> put_req_header("content-type", "application/json")
        |> assign(:raw_body, raw_body)
        |> assign(:test_mode, false)
        |> post("/webhook/github", payload)
        
      assert json_response(conn, 401) == %{
        "error" => "Invalid signature"
      }
    end
    
    test "rejects request without signature", %{conn: conn} do
      conn = conn
        |> put_req_header("x-github-event", "pull_request")
        |> put_req_header("content-type", "application/json")
        |> post("/webhook/github", %{})
        
      assert json_response(conn, 401) == %{
        "error" => "Missing signature"
      }
    end
  end
  
  defp compute_github_signature(payload) do
    "sha256=" <> Base.encode16(:crypto.mac(:hmac, :sha256, @github_webhook_secret, payload), case: :lower)
  end
end