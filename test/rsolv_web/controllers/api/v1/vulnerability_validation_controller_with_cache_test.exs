defmodule RsolvWeb.Api.V1.VulnerabilityValidationControllerWithCacheTest do
  use RsolvWeb.ConnCase, async: false

  alias Rsolv.ValidationCache
  alias Rsolv.Customers
  alias Rsolv.Customers.{Customer, ApiKey}

  # Enable caching for each test in this module - these tests specifically test the cached controller
  setup do
    # Ensure flag is enabled at start of each test (in case it got disabled)
    FunWithFlags.enable(:false_positive_caching)

    # Create a staff customer with API key
    {:ok, customer} =
      Customers.create_customer(%{
        email: "test-staff@rsolv.dev",
        name: "Test Staff",
        is_staff: true,
        active: true,
        monthly_limit: 100,
        current_usage: 0
      })

    {:ok, api_key} =
      Customers.create_api_key(customer, %{
        name: "Test API Key",
        active: true
      })

    %{customer: customer, raw_api_key: api_key.raw_key}
  end

  describe "validate/2 with string forge account IDs" do
    test "handles test forge accounts with string IDs", %{conn: conn, raw_api_key: raw_api_key} do
      # Prepare request with vulnerabilities
      request_body = %{
        "vulnerabilities" => [
          %{
            "id" => "test-vuln-1",
            "file" => "app.js",
            "type" => "sql_injection",
            "severity" => "high",
            "line" => 42,
            "column" => 10,
            "message" => "SQL Injection detected",
            "pattern" => "sql_concat",
            "code" => "query = 'SELECT * FROM users WHERE id = ' + userId"
          }
        ],
        "files" => %{
          "app.js" => %{
            "content" => "const query = 'SELECT * FROM users WHERE id = ' + userId;"
          }
        },
        "repository" => "test-org/test-repo"
      }

      # Make request with API key in header
      conn =
        conn
        |> put_req_header("x-api-key", raw_api_key)
        |> put_req_header("content-type", "application/json")
        |> post("/api/v1/vulnerabilities/validate", request_body)

      # Should succeed without FunctionClauseError
      assert %{"validated" => validated, "stats" => stats} = json_response(conn, 200)
      assert is_list(validated)
      assert Map.has_key?(stats, "total")
    end

    test "caches false positives with string forge IDs", %{conn: conn, raw_api_key: raw_api_key} do
      request_body = %{
        "vulnerabilities" => [
          %{
            "id" => "test-vuln-2",
            "file" => "safe.js",
            "type" => "xss",
            "severity" => "medium",
            "line" => 10,
            "column" => 5,
            "message" => "XSS detected",
            "pattern" => "xss_html",
            "code" => "const safe = escapeHtml(userInput);"
          }
        ],
        "files" => %{
          "safe.js" => %{
            "content" => "const safe = escapeHtml(userInput);"
          }
        },
        "repository" => "test-org/test-repo"
      }

      # First request - should be a cache miss
      conn1 =
        conn
        |> put_req_header("x-api-key", raw_api_key)
        |> put_req_header("content-type", "application/json")
        |> post("/api/v1/vulnerabilities/validate", request_body)

      response1 = json_response(conn1, 200)
      cache_stats1 = response1["cache_stats"] || response1["stats"]

      # Record initial cache hits (may be non-zero from other tests since async: false)
      initial_hits = cache_stats1["cacheHits"] || cache_stats1["cache_hits"] || 0

      # Second request - should potentially be a cache hit if it's a false positive
      conn2 =
        build_conn()
        |> put_req_header("x-api-key", raw_api_key)
        |> put_req_header("content-type", "application/json")
        |> post("/api/v1/vulnerabilities/validate", request_body)

      response2 = json_response(conn2, 200)

      # Verify response structure is consistent
      assert Map.has_key?(response2, "validated")
      assert Map.has_key?(response2, "stats")
    end

    test "generates consistent cache keys for string forge IDs", %{raw_api_key: raw_api_key} do
      # Test that the key generator works correctly with string IDs
      # This would normally be called internally by the cache controller
      locations = [%{file_path: "app.js", line: 42}]

      # Should not raise an error
      key1 =
        ValidationCache.KeyGenerator.generate_key(
          "test-forge-14",
          "test-org/repo",
          locations,
          "sql_injection"
        )

      key2 =
        ValidationCache.KeyGenerator.generate_key(
          "test-forge-14",
          "test-org/repo",
          locations,
          "sql_injection"
        )

      # Keys should be identical for same input
      assert key1 == key2
      assert key1 == "test-forge-14/test-org/repo/[app.js:42]:sql_injection"
    end
  end
end
