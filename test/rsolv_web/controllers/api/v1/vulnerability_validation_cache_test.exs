defmodule RsolvWeb.Api.V1.VulnerabilityValidationCacheTest do
  use RsolvWeb.ConnCase, async: false
  
  alias Rsolv.Cache.ValidationCache
  
  setup do
    # Clear cache before each test
    ValidationCache.clear_all()
    
    # Use predefined test customer
    customer = %{
      id: "test_customer_1",
      name: "Test Customer",
      email: "test@example.com",
      api_key: "rsolv_test_abc123",
      tier: "enterprise",
      flags: ["ai_access", "enterprise_access"],
      monthly_limit: 100,
      current_usage: 15,
      active: true,
      trial: true,
      created_at: DateTime.utc_now()
    }
    
    {:ok, customer: customer}
  end
  
  describe "caching behavior" do
    test "returns cached result for identical vulnerability", %{conn: conn, customer: customer} do
      request_data = %{
        "vulnerabilities" => [
          %{
            "id" => "vuln-123",
            "patternId" => "js-eval-injection",
            "filePath" => "app/routes/test.js",
            "line" => 42,
            "code" => "eval(userInput)",
            "severity" => "critical"
          }
        ],
        "files" => %{
          "app/routes/test.js" => "const userInput = req.body.expr;\neval(userInput);"
        }
      }
      
      # First request - should compute and cache
      conn1 = 
        conn
        |> put_req_header("x-api-key", customer.api_key)
        |> put_req_header("content-type", "application/json")
        |> post("/api/v1/vulnerabilities/validate", request_data)
      
      response1 = json_response(conn1, 200)
      
      # Second identical request - should return from cache
      conn2 = 
        build_conn()
        |> put_req_header("x-api-key", customer.api_key)
        |> put_req_header("content-type", "application/json")
        |> post("/api/v1/vulnerabilities/validate", request_data)
      
      response2 = json_response(conn2, 200)
      
      # Results should be identical
      assert response1 == response2
      
      # Verify cache was used (check metrics)
      assert ValidationCache.get_stats()["cache_hits"] == 1
      assert ValidationCache.get_stats()["cache_misses"] == 1
    end
    
    test "cache key includes vulnerability details", %{conn: conn, customer: customer} do
      # Same vulnerability but different line number
      request_data1 = build_request("vuln-1", 42, "eval(userInput)")
      request_data2 = build_request("vuln-1", 43, "eval(userInput)")
      
      # First request
      conn1 = make_request(conn, customer, request_data1)
      response1 = json_response(conn1, 200)
      
      # Second request with different line
      conn2 = make_request(build_conn(), customer, request_data2)
      response2 = json_response(conn2, 200)
      
      # Should not use cache due to different line number
      assert ValidationCache.get_stats()["cache_hits"] == 0
      assert ValidationCache.get_stats()["cache_misses"] == 2
    end
    
    test "cache respects TTL", %{conn: conn, customer: customer} do
      # Set short TTL for testing
      Application.put_env(:rsolv, :validation_cache_ttl, 100) # 100ms
      
      request_data = build_request("vuln-ttl", 1, "eval(x)")
      
      # First request
      conn1 = make_request(conn, customer, request_data)
      response1 = json_response(conn1, 200)
      
      # Second request (within TTL)
      conn2 = make_request(build_conn(), customer, request_data)
      response2 = json_response(conn2, 200)
      assert ValidationCache.get_stats()["cache_hits"] == 1
      
      # Wait for cache to expire
      :timer.sleep(150)
      
      # Get stats before third request
      stats_before = ValidationCache.get_stats()
      assert stats_before["cache_hits"] == 1
      assert stats_before["cache_misses"] == 1
      
      # Third request (after TTL)
      conn3 = make_request(build_conn(), customer, request_data)
      response3 = json_response(conn3, 200)
      
      # Should be cache miss after expiry
      stats_after = ValidationCache.get_stats()
      assert stats_after["cache_hits"] == 1  # No new hits
      assert stats_after["cache_misses"] == 2  # One more miss
      
      # Reset TTL to default
      Application.delete_env(:rsolv, :validation_cache_ttl)
    end
    
    test "batch requests benefit from cache", %{conn: conn, customer: customer} do
      # Create batch with duplicate vulnerabilities
      vulnerabilities = [
        %{"id" => "vuln-1", "patternId" => "eval", "filePath" => "a.js", "line" => 1, "code" => "eval(x)", "severity" => "critical"},
        %{"id" => "vuln-2", "patternId" => "eval", "filePath" => "b.js", "line" => 2, "code" => "eval(y)", "severity" => "critical"},
        %{"id" => "vuln-3", "patternId" => "eval", "filePath" => "a.js", "line" => 1, "code" => "eval(x)", "severity" => "critical"}, # Duplicate of vuln-1
        %{"id" => "vuln-4", "patternId" => "eval", "filePath" => "b.js", "line" => 2, "code" => "eval(y)", "severity" => "critical"}  # Duplicate of vuln-2
      ]
      
      request_data = %{
        "vulnerabilities" => vulnerabilities,
        "files" => %{
          "a.js" => "eval(x);",
          "b.js" => "eval(y);"
        }
      }
      
      conn = make_request(conn, customer, request_data)
      response = json_response(conn, 200)
      
      # Should validate all 4 but only compute 2 unique ones
      assert length(response["validated"]) == 4
      assert response["stats"]["total"] == 4
      
      # Check internal cache was used for duplicates
      assert ValidationCache.get_stats()["internal_hits"] == 2
    end
  end
  
  describe "cache invalidation" do
    test "can clear specific cache entries", %{conn: conn, customer: customer} do
      request_data = build_request("vuln-clear", 1, "eval(x)")
      
      # Cache the result
      conn1 = make_request(conn, customer, request_data)
      json_response(conn1, 200)
      
      # Clear cache for specific pattern
      ValidationCache.clear_pattern("js-eval-injection")
      
      # Next request should miss cache
      conn2 = make_request(build_conn(), customer, request_data)
      json_response(conn2, 200)
      
      assert ValidationCache.get_stats()["cache_hits"] == 0
      assert ValidationCache.get_stats()["cache_misses"] == 2
    end
    
    test "can clear all cache entries", %{conn: conn, customer: customer} do
      # Cache multiple results
      for i <- 1..3 do
        request_data = build_request("vuln-#{i}", i, "eval(x#{i})")
        conn = make_request(build_conn(), customer, request_data)
        json_response(conn, 200)
      end
      
      # Check initial stats
      initial_stats = ValidationCache.get_stats()
      assert initial_stats["cache_misses"] == 3
      
      # Clear all cache entries (preserving stats)
      :ets.delete_all_objects(:validation_cache)
      
      # All subsequent requests should miss
      for i <- 1..3 do
        request_data = build_request("vuln-#{i}", i, "eval(x#{i})")
        conn = make_request(build_conn(), customer, request_data)
        json_response(conn, 200)
      end
      
      final_stats = ValidationCache.get_stats()
      assert final_stats["cache_hits"] == 0
      assert final_stats["cache_misses"] == 6
    end
  end
  
  # Helper functions
  defp build_request(id, line, code) do
    %{
      "vulnerabilities" => [
        %{
          "id" => id,
          "patternId" => "js-eval-injection",
          "filePath" => "test.js",
          "line" => line,
          "code" => code,
          "severity" => "critical"
        }
      ],
      "files" => %{
        "test.js" => "// Line 1\n" <> code <> ";\n// More code"
      }
    }
  end
  
  defp make_request(conn, customer, request_data) do
    conn
    |> put_req_header("x-api-key", customer.api_key)
    |> put_req_header("content-type", "application/json")
    |> post("/api/v1/vulnerabilities/validate", request_data)
  end
end