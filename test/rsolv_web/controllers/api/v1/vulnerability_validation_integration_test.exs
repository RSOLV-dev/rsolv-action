defmodule RsolvWeb.Api.V1.VulnerabilityValidationIntegrationTest do
  use RsolvWeb.ConnCase, async: false

  import Mock

  alias Rsolv.Accounts
  alias Rsolv.Cache.ValidationCache

  setup do
    # Clear cache before each test
    ValidationCache.clear()

    # Mock customer for testing
    customer = %{
      id: "test_customer_1",
      name: "Test Customer",
      email: "test@example.com",
      subscription_type: "trial",
      tier: "enterprise",
      flags: ["ai_access", "enterprise_access"],
      monthly_limit: 100,
      current_usage: 15,
      active: true,
      trial: true,
      created_at: DateTime.utc_now()
    }

    {:ok, customer: customer}
  end

  describe "integration with file path classifier and safe pattern detector" do
    test "filters vendor file false positives", %{conn: conn, customer: customer} do
      # Mock the API key validation
      with_mock Accounts, get_customer_by_api_key: fn "test_api_key_123" -> customer end do
        # Bootstrap.js timing attack false positive
        request_body = %{
          "vulnerabilities" => [
            %{
              "id" => "vuln-1",
              "type" => "timing_attack",
              "file" => "/vendor/bootstrap/bootstrap.min.js",
              "line" => 100,
              "code" => "e.code === DOMException.QUOTA_EXCEEDED_ERR"
            }
          ],
          "files" => %{
            "/vendor/bootstrap/bootstrap.min.js" => """
            // Minified bootstrap code
            if (e.code === DOMException.QUOTA_EXCEEDED_ERR) {
              // Handle quota exceeded
            }
            """
          }
        }

        conn =
          conn
          |> put_req_header("x-api-key", "test_api_key_123")
          |> put_req_header("content-type", "application/json")
          |> post("/api/v1/vulnerabilities/validate", request_body)

        response = json_response(conn, 200)

        # Should be filtered due to vendor file + safe pattern
        assert length(response["validated"]) == 1
        vuln = hd(response["validated"])
        assert vuln["isValid"] == false
        assert vuln["confidence"] < 0.3
        assert vuln["reason"] =~ "Safe pattern"
      end
    end

    test "filters test file false positives", %{conn: conn, customer: customer} do
      with_mock Accounts, get_customer_by_api_key: fn "test_api_key_123" -> customer end do
        request_body = %{
          "vulnerabilities" => [
            %{
              "id" => "vuln-2",
              "type" => "sql_injection",
              "file" => "/test/integration/db_test.js",
              "line" => 50,
              "code" => "db.query('SELECT * FROM users WHERE id = ' + testId)"
            }
          ],
          "files" => %{
            "/test/integration/db_test.js" => """
            // Test file
            const testId = 'test-123';
            db.query('SELECT * FROM users WHERE id = ' + testId);
            """
          }
        }

        conn =
          conn
          |> put_req_header("x-api-key", "test_api_key_123")
          |> put_req_header("content-type", "application/json")
          |> post("/api/v1/vulnerabilities/validate", request_body)

        response = json_response(conn, 200)

        # Should be filtered or have very low confidence due to test file
        assert length(response["validated"]) == 1
        vuln = hd(response["validated"])
        assert vuln["confidence"] < 0.4 or vuln["isValid"] == false
      end
    end

    test "recognizes safe parameterized queries", %{conn: conn, customer: customer} do
      with_mock Accounts, get_customer_by_api_key: fn "test_api_key_123" -> customer end do
        request_body = %{
          "vulnerabilities" => [
            %{
              "id" => "vuln-3",
              "type" => "sql_injection",
              "file" => "/app/models/user.js",
              "line" => 25,
              "code" => "db.query('SELECT * FROM users WHERE id = $1', [userId])"
            }
          ],
          "files" => %{
            "/app/models/user.js" => """
            function getUser(userId) {
              return db.query('SELECT * FROM users WHERE id = $1', [userId]);
            }
            """
          }
        }

        conn =
          conn
          |> put_req_header("x-api-key", "test_api_key_123")
          |> put_req_header("content-type", "application/json")
          |> post("/api/v1/vulnerabilities/validate", request_body)

        response = json_response(conn, 200)

        # Should be marked as safe pattern
        assert length(response["validated"]) == 1
        vuln = hd(response["validated"])
        assert vuln["isValid"] == false
        assert vuln["reason"] =~ "safe" or vuln["reason"] =~ "parameterized"
      end
    end

    test "correctly flags real vulnerabilities in application code", %{
      conn: conn,
      customer: customer
    } do
      with_mock Accounts, get_customer_by_api_key: fn "test_api_key_123" -> customer end do
        request_body = %{
          "vulnerabilities" => [
            %{
              "id" => "vuln-4",
              "type" => "sql_injection",
              "file" => "/app/controllers/user.js",
              "line" => 15,
              "code" => "db.query('SELECT * FROM users WHERE id = ' + req.body.userId)"
            }
          ],
          "files" => %{
            "/app/controllers/user.js" => """
            app.post('/user', (req, res) => {
              const result = db.query('SELECT * FROM users WHERE id = ' + req.body.userId);
              res.json(result);
            });
            """
          }
        }

        conn =
          conn
          |> put_req_header("x-api-key", "test_api_key_123")
          |> put_req_header("content-type", "application/json")
          |> post("/api/v1/vulnerabilities/validate", request_body)

        response = json_response(conn, 200)

        # Should still be flagged as valid vulnerability
        assert length(response["validated"]) == 1
        vuln = hd(response["validated"])
        assert vuln["isValid"] == true
        assert vuln["confidence"] >= 0.8
      end
    end

    test "applies confidence multipliers correctly", %{conn: conn, customer: customer} do
      with_mock Accounts, get_customer_by_api_key: fn "test_api_key_123" -> customer end do
        request_body = %{
          "vulnerabilities" => [
            %{
              "id" => "vuln-5",
              "type" => "xss",
              "file" => "/config/webpack.config.js",
              "line" => 50,
              "code" => "element.innerHTML = userInput"
            }
          ],
          "files" => %{
            "/config/webpack.config.js" => """
            // Webpack config
            const config = {
              plugins: [{
                apply: (compiler) => {
                  element.innerHTML = userInput;
                }
              }]
            };
            """
          }
        }

        conn =
          conn
          |> put_req_header("x-api-key", "test_api_key_123")
          |> put_req_header("content-type", "application/json")
          |> post("/api/v1/vulnerabilities/validate", request_body)

        response = json_response(conn, 200)

        # Config file should have reduced confidence (0.5x multiplier)
        assert length(response["validated"]) == 1
        vuln = hd(response["validated"])
        # If it was 0.8 confidence, should now be 0.4
        assert vuln["confidence"] <= 0.5
      end
    end
  end

  describe "metrics and statistics" do
    test "tracks false positive reduction metrics", %{conn: conn, customer: customer} do
      with_mock Accounts, get_customer_by_api_key: fn "test_api_key_123" -> customer end do
        request_body = %{
          "vulnerabilities" => [
            # Vendor file - should be filtered
            %{
              "id" => "fp-1",
              "type" => "timing_attack",
              "file" => "/node_modules/jquery/jquery.min.js",
              "line" => 1,
              "code" => "status === HTTP_OK"
            },
            # Test file - should be filtered
            %{
              "id" => "fp-2",
              "type" => "sql_injection",
              "file" => "/test/db_test.js",
              "line" => 1,
              "code" => "query('SELECT * FROM test')"
            },
            # Safe pattern - should be filtered
            %{
              "id" => "fp-3",
              "type" => "sql_injection",
              "file" => "/app/model.js",
              "line" => 1,
              "code" => "db.query('SELECT * FROM users WHERE id = ?', [id])"
            },
            # Real vulnerability - should NOT be filtered
            %{
              "id" => "real-1",
              "type" => "sql_injection",
              "file" => "/app/controller.js",
              "line" => 1,
              "code" => "query('SELECT * FROM users WHERE id = ' + userInput)"
            }
          ],
          "files" => %{
            "/node_modules/jquery/jquery.min.js" => "status === HTTP_OK",
            "/test/db_test.js" => "query('SELECT * FROM test')",
            "/app/model.js" => "db.query('SELECT * FROM users WHERE id = ?', [id])",
            "/app/controller.js" => "query('SELECT * FROM users WHERE id = ' + userInput)"
          }
        }

        conn =
          conn
          |> put_req_header("x-api-key", "test_api_key_123")
          |> put_req_header("content-type", "application/json")
          |> post("/api/v1/vulnerabilities/validate", request_body)

        response = json_response(conn, 200)

        # Should have filtered 3 false positives, kept 1 real vulnerability
        assert response["stats"]["total"] == 4
        assert response["stats"]["validated"] == 1
        assert response["stats"]["rejected"] == 3

        # False positive rate should be 75% filtered (3/4)
        false_positive_reduction = response["stats"]["rejected"] / response["stats"]["total"]
        assert false_positive_reduction >= 0.75
      end
    end
  end
end
