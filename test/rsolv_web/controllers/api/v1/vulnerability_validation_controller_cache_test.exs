defmodule RsolvWeb.Api.V1.VulnerabilityValidationControllerCacheTest do
  use RsolvWeb.ConnCase
  
  alias Rsolv.ValidationCache
  alias Rsolv.Accounts
  alias Rsolv.Customers.Customer
  alias Rsolv.Customers.ForgeAccount
  alias Rsolv.Repo
  alias FunWithFlags
  
  import Rsolv.ValidationCacheHelpers
  
  require Logger
  
  setup do
    # For cache controller tests, we'll use the environment variable
    # to force the cache controller to be used, avoiding FunWithFlags issues
    System.put_env("FORCE_CACHE_CONTROLLER", "true")
    
    on_exit(fn ->
      # Clean up the environment variable
      System.delete_env("FORCE_CACHE_CONTROLLER")
    end)
    
    # Create test customer with API key
    unique_id = System.unique_integer([:positive])
    
    customer = %Customer{
      name: "Test Customer #{unique_id}",
      email: "test#{unique_id}@example.com",
      subscription_plan: "trial"
    }
    |> Repo.insert!()
    
    forge_account = %ForgeAccount{
      forge_type: :github,
      namespace: "test-org-#{unique_id}",
      customer_id: customer.id,
      verified_at: DateTime.utc_now()
    }
    |> Repo.insert!()
    
    # Create an API key for this customer
    api_key = %Rsolv.Customers.ApiKey{
      customer_id: customer.id,
      name: "Test Key",
      key: "test_#{Ecto.UUID.generate()}",
      active: true
    }
    |> Repo.insert!()
    
    {:ok, %{
      customer: customer,
      forge_account: forge_account,
      api_key: api_key.key
    }}
  end
  
  describe "cache integration with validation endpoint" do
    test "first request triggers validation and stores in cache", %{conn: conn, api_key: api_key, forge_account: forge_account} do
      # Prepare request
      request_body = %{
        "vulnerabilities" => [
          %{
            "id" => "vuln-1",
            "type" => "sql-injection",
            "filePath" => "app/routes/user.js",
            "line" => 42,
            "code" => "db.query('SELECT * FROM users WHERE id = ?', [userInput])",
            "locations" => [
              %{"file_path" => "app/routes/user.js", "line" => 42, "is_primary" => true}
            ]
          }
        ],
        "files" => %{
          "app/routes/user.js" => %{
            "content" => "function getUserData(userInput) {\n  return db.query('SELECT * FROM users WHERE id = ?', [userInput]);\n}",
            "hash" => "sha256:test123"
          }
        },
        "repository" => "test-org/test-repo"
      }
      
      # First request - should be cache miss
      response1 = conn
      |> put_req_header("x-api-key", api_key)
      |> put_req_header("content-type", "application/json")
      |> post("/api/v1/vulnerabilities/validate", request_body)
      |> json_response(200)
      
      # Check response structure
      assert response1["validated"]
      assert length(response1["validated"]) == 1
      
      # First result should not be from cache
      first_result = hd(response1["validated"])
      assert first_result["fromCache"] == false
      refute first_result["cachedAt"]
      refute first_result["cacheKey"]
      
      # Check cache stats
      assert response1["cache_stats"]["total_requests"] == 1
      assert response1["cache_stats"]["cache_hits"] == 0
      assert response1["cache_stats"]["cache_misses"] == 1
      
      # Second request with same data - should be cache hit
      response2 = build_conn()
      |> put_req_header("x-api-key", api_key)
      |> put_req_header("content-type", "application/json")
      |> post("/api/v1/vulnerabilities/validate", request_body)
      |> json_response(200)
      
      # Second result should be from cache
      second_result = hd(response2["validated"])
      assert second_result["fromCache"] == true
      assert second_result["cachedAt"]
      assert second_result["cacheKey"]
      assert second_result["cacheScope"] == "organization"
      
      # Validation results should match
      assert second_result["isValid"] == first_result["isValid"]
      assert second_result["confidence"] == first_result["confidence"]
      assert second_result["reason"] == first_result["reason"]
      
      # Check updated cache stats (per-request stats)
      assert response2["cache_stats"]["total_requests"] == 1
      assert response2["cache_stats"]["cache_hits"] == 1
      assert response2["cache_stats"]["cache_misses"] == 0
      assert response2["cache_stats"]["hit_rate"] > 0
    end
    
    test "file change invalidates cache", %{conn: conn, api_key: api_key, forge_account: forge_account} do
      request_body = %{
        "vulnerabilities" => [
          %{
            "id" => "vuln-1",
            "type" => "sql-injection",
            "filePath" => "app.js",
            "line" => 10,
            "code" => "db.query(\"SELECT * FROM users WHERE id = ?\", [userId])",
            "locations" => [
              %{"file_path" => "app.js", "line" => 10, "is_primary" => true}
            ]
          }
        ],
        "files" => %{
          "app.js" => %{
            "content" => "function getUser(userId) {\n  return db.query(\"SELECT * FROM users WHERE id = ?\", [userId]);\n}",
            "hash" => "sha256:original"
          }
        },
        "repository" => "test-org/test-repo"
      }
      
      # First request
      response1 = conn
      |> put_req_header("x-api-key", api_key)
      |> put_req_header("content-type", "application/json")
      |> post("/api/v1/vulnerabilities/validate", request_body)
      |> json_response(200)
      
      assert hd(response1["validated"])["fromCache"] == false
      
      # Second request with same file hash - cache hit
      response2 = build_conn()
      |> put_req_header("x-api-key", api_key)
      |> put_req_header("content-type", "application/json")
      |> post("/api/v1/vulnerabilities/validate", request_body)
      |> json_response(200)
      
      assert hd(response2["validated"])["fromCache"] == true
      
      # Third request with different file hash - cache miss
      modified_request = put_in(request_body, ["files", "app.js", "hash"], "sha256:modified")
      modified_request = put_in(modified_request, ["files", "app.js", "content"], "const input = req.body.code;\n// Fixed: eval(input);")
      
      response3 = build_conn()
      |> put_req_header("x-api-key", api_key)
      |> put_req_header("content-type", "application/json")
      |> post("/api/v1/vulnerabilities/validate", modified_request)
      |> json_response(200)
      
      # Should not be from cache due to file change
      assert hd(response3["validated"])["fromCache"] == false
      assert hd(response3["validated"])["cacheInvalidatedReason"] == "file_changed"
    end
    
    test "multiple vulnerabilities use cache independently", %{conn: conn, api_key: api_key} do
      request_body = %{
        "vulnerabilities" => [
          %{
            "id" => "vuln-1",
            "type" => "sql-injection",
            "filePath" => "db.js",
            "line" => 10,
            "code" => "db.query('SELECT * FROM users WHERE id = ?', [input])",
            "locations" => [
              %{"file_path" => "db.js", "line" => 10, "is_primary" => true}
            ]
          },
          %{
            "id" => "vuln-2",
            "type" => "xss",
            "filePath" => "ui.js",
            "line" => 20,
            "code" => "element.textContent = data",
            "locations" => [
              %{"file_path" => "ui.js", "line" => 20, "is_primary" => true}
            ]
          },
          %{
            "id" => "vuln-3",
            "type" => "sql-injection",
            "filePath" => "db.js",
            "line" => 10,
            "code" => "db.query('SELECT * FROM users WHERE id = ?', [input])",
            "locations" => [
              %{"file_path" => "db.js", "line" => 10, "is_primary" => true}
            ]
          }
        ],
        "files" => %{
          "db.js" => %{
            "content" => "function query(input) { db.query('SELECT * FROM users WHERE id = ?', [input]); }",
            "hash" => "sha256:db123"
          },
          "ui.js" => %{
            "content" => "function render(data) { el.textContent = data; }",
            "hash" => "sha256:ui456"
          }
        },
        "repository" => "test-org/test-repo"
      }
      
      # First request - all cache misses
      response1 = conn
      |> put_req_header("x-api-key", api_key)
      |> put_req_header("content-type", "application/json")
      |> post("/api/v1/vulnerabilities/validate", request_body)
      |> json_response(200)
      
      assert length(response1["validated"]) == 3
      assert Enum.all?(response1["validated"], &(&1["fromCache"] == false))
      
      # Note: vuln-3 is duplicate of vuln-1, should be handled internally
      assert response1["cache_stats"]["cache_hits"] == 0
      assert response1["cache_stats"]["cache_misses"] == 2  # Only 2 unique
      assert response1["cache_stats"]["internal_duplicates"] == 1
      
      # Second request - all from cache
      response2 = build_conn()
      |> put_req_header("x-api-key", api_key)
      |> put_req_header("content-type", "application/json")
      |> post("/api/v1/vulnerabilities/validate", request_body)
      |> json_response(200)
      
      assert length(response2["validated"]) == 3
      assert Enum.all?(response2["validated"], &(&1["fromCache"] == true))
      assert response2["cache_stats"]["cache_hits"] == 2
      assert response2["cache_stats"]["internal_duplicates"] == 1
    end
    
    test "forge account isolation in cache", %{conn: conn} do
      # Create two customers with different forge accounts
      {customer1, forge1} = create_test_customer("customer1")
      {customer2, forge2} = create_test_customer("customer2")
      
      request_body = %{
        "vulnerabilities" => [
          %{
            "id" => "vuln-1",
            "type" => "sql-injection",
            "filePath" => "shared.js",
            "line" => 42,
            "code" => "db.query('SELECT * FROM users WHERE id = ?', [input])",
            "locations" => [
              %{"file_path" => "shared.js", "line" => 42, "is_primary" => true}
            ]
          }
        ],
        "files" => %{
          "shared.js" => %{
            "content" => "function query(input) { return db.query(input); }",
            "hash" => "sha256:shared123"
          }
        },
        "repository" => "shared/repo"
      }
      
      # Customer 1 first request - cache miss
      response1 = conn
      |> put_req_header("x-api-key", customer1.api_key)
      |> put_req_header("content-type", "application/json")
      |> post("/api/v1/vulnerabilities/validate", request_body)
      |> json_response(200)
      
      assert hd(response1["validated"])["fromCache"] == false
      
      # Customer 2 first request - also cache miss (isolated)
      response2 = build_conn()
      |> put_req_header("x-api-key", customer2.api_key)
      |> put_req_header("content-type", "application/json")
      |> post("/api/v1/vulnerabilities/validate", request_body)
      |> json_response(200)
      
      assert hd(response2["validated"])["fromCache"] == false
      
      # Customer 1 second request - cache hit
      response3 = build_conn()
      |> put_req_header("x-api-key", customer1.api_key)
      |> put_req_header("content-type", "application/json")
      |> post("/api/v1/vulnerabilities/validate", request_body)
      |> json_response(200)
      
      assert hd(response3["validated"])["fromCache"] == true
      
      # Customer 2 second request - also cache hit (from their own cache)
      response4 = build_conn()
      |> put_req_header("x-api-key", customer2.api_key)
      |> put_req_header("content-type", "application/json")
      |> post("/api/v1/vulnerabilities/validate", request_body)
      |> json_response(200)
      
      assert hd(response4["validated"])["fromCache"] == true
    end
    
    test "cache metadata included in response", %{conn: conn, api_key: api_key} do
      request_body = %{
        "vulnerabilities" => [
          %{
            "id" => "vuln-1",
            "type" => "sql-injection",
            "filePath" => "app.js",
            "line" => 5,
            "code" => "db.query(\"SELECT * FROM users WHERE id = $1\", [id])",
            "locations" => [
              %{"file_path" => "app.js", "line" => 5, "is_primary" => true}
            ]
          }
        ],
        "files" => %{
          "app.js" => %{
            "content" => "function getUser(id) {\n  return db.query(\"SELECT * FROM users WHERE id = $1\", [id]);\n}",
            "hash" => "sha256:abc789"
          }
        },
        "repository" => "test/repo"
      }
      
      # Store in cache first
      conn
      |> put_req_header("x-api-key", api_key)
      |> put_req_header("content-type", "application/json")
      |> post("/api/v1/vulnerabilities/validate", request_body)
      |> json_response(200)
      
      # Get from cache
      response = build_conn()
      |> put_req_header("x-api-key", api_key)
      |> put_req_header("content-type", "application/json")
      |> post("/api/v1/vulnerabilities/validate", request_body)
      |> json_response(200)
      
      cached_result = hd(response["validated"])
      
      # Check all cache metadata fields
      assert cached_result["fromCache"] == true
      assert cached_result["cachedAt"] =~ ~r/\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}/
      assert cached_result["cacheKey"] =~ "test/repo"
      assert cached_result["cacheKey"] =~ "sql-injection"
      assert cached_result["cacheScope"] == "organization"
      assert cached_result["cacheHitType"] == "exact_match"
      
      # Check cache performance stats
      assert response["cache_stats"]["hit_rate"] > 0
      assert response["cache_stats"]["avg_ttl_remaining"]
      assert response["cache_stats"]["total_cached_entries"] >= 1
    end
  end
  
  # Helper to create test customers with forge accounts
  defp create_test_customer(prefix) do
    unique_id = System.unique_integer([:positive])
    
    customer = %Customer{
      name: "#{prefix} Customer #{unique_id}",
      email: "#{prefix}#{unique_id}@example.com"
    }
    |> Rsolv.Repo.insert!()
    
    forge_account = %ForgeAccount{
      forge_type: :github,
      namespace: "#{prefix}-org-#{unique_id}",
      customer_id: customer.id,
      verified_at: DateTime.utc_now()
    }
    |> Rsolv.Repo.insert!()
    
    # Create an API key for this customer
    api_key = %Rsolv.Customers.ApiKey{
      customer_id: customer.id,
      name: "Test Key for #{prefix}",
      key: "rsolv_#{Base.url_encode64(:crypto.strong_rand_bytes(32), padding: false)}",
      active: true
    }
    |> Rsolv.Repo.insert!()
    
    # Return customer with api_key field for backward compatibility
    customer_with_key = Map.put(customer, :api_key, api_key.key)
    
    {customer_with_key, forge_account}
  end
end