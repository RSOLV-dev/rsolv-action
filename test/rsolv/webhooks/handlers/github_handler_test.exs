defmodule Rsolv.Webhooks.Handlers.GitHubHandlerTest do
  use Rsolv.DataCase
  alias Rsolv.Webhooks.Handlers.GitHubHandler
  alias Rsolv.Billing.FixAttempt
  
  describe "is_rsolv_pr?/1" do
    test "identifies PR with rsolv:automated label" do
      pr = %{
        "title" => "Some random title",
        "body" => "Some random body",
        "labels" => [
          %{"name" => "bug"},
          %{"name" => "rsolv:automated"},
          %{"name" => "security"}
        ]
      }
      
      assert GitHubHandler.is_rsolv_pr?(pr) == true
    end
    
    test "identifies PR with rsolv/ branch prefix" do
      pr = %{
        "title" => "Fix issue",
        "body" => "Regular PR body",
        "head" => %{"ref" => "rsolv/123-fix-security-issue"},
        "labels" => []
      }
      
      assert GitHubHandler.is_rsolv_pr?(pr) == true
    end
    
    test "identifies PR with [RSOLV] title prefix" do
      pr = %{
        "title" => "[RSOLV] Fix authentication bypass vulnerability",
        "body" => "This fixes the issue",
        "labels" => []
      }
      
      assert GitHubHandler.is_rsolv_pr?(pr) == true
    end
    
    test "identifies PR with various body patterns" do
      body_patterns = [
        "This PR was automatically generated by [RSOLV](https://rsolv.dev)",
        "automatically generated by RSOLV",
        "Generated by RSOLV - Automated Security Fix",
        "Created by rsolv.dev automation"
      ]
      
      for body <- body_patterns do
        pr = %{
          "title" => "Regular title",
          "body" => body,
          "labels" => []
        }
        
        assert GitHubHandler.is_rsolv_pr?(pr) == true,
          "Failed to identify PR with body: #{body}"
      end
    end
    
    test "does not identify non-RSOLV PR" do
      pr = %{
        "title" => "Regular PR title",
        "body" => "This is a manual PR",
        "head" => %{"ref" => "feature/new-feature"},
        "labels" => [%{"name" => "enhancement"}]
      }
      
      assert GitHubHandler.is_rsolv_pr?(pr) == false
    end
    
    test "handles missing fields gracefully" do
      test_cases = [
        %{},
        %{"title" => nil},
        %{"body" => nil, "labels" => nil},
        %{"head" => %{}},
        %{"labels" => []}
      ]
      
      for pr <- test_cases do
        # Should not crash, just return false
        assert GitHubHandler.is_rsolv_pr?(pr) == false
      end
    end
  end
  
  describe "extract_issue_references/1" do
    test "extracts simple issue number with various keywords" do
      texts = [
        "This fixes #123",
        "Closes #456",
        "Resolves #789",
        "fixed #111",
        "FIXES #222 (uppercase)"
      ]
      
      for text <- texts do
        refs = GitHubHandler.extract_issue_references(text)
        assert length(refs) == 1
        assert %{type: :number, value: num} = hd(refs)
        assert is_integer(num)
      end
    end
    
    test "extracts full GitHub URLs" do
      text = """
      This PR fixes https://github.com/owner/repo/issues/123
      and closes https://github.com/another/project/issues/456
      """
      
      refs = GitHubHandler.extract_issue_references(text)
      assert length(refs) == 2
      
      assert %{type: :url, owner: "owner", repo: "repo", value: 123} in refs
      assert %{type: :url, owner: "another", repo: "project", value: 456} in refs
    end
    
    test "extracts cross-repo references" do
      text = "This fixes owner/repo#123 and resolves another/project#456"
      
      refs = GitHubHandler.extract_issue_references(text)
      assert length(refs) == 2
      
      assert %{type: :cross_repo, owner: "owner", repo: "repo", value: 123} in refs
      assert %{type: :cross_repo, owner: "another", repo: "project", value: 456} in refs
    end
    
    test "extracts mixed reference types" do
      text = """
      This PR addresses multiple issues:
      - Fixes #123
      - Closes https://github.com/org/repo/issues/456
      - Resolves external/lib#789
      """
      
      refs = GitHubHandler.extract_issue_references(text)
      assert length(refs) == 3
      
      types = Enum.map(refs, & &1.type)
      assert :number in types
      assert :url in types
      assert :cross_repo in types
    end
    
    test "fallback extraction when no keywords present" do
      text = "Related to #123 but doesn't use keywords"
      refs = GitHubHandler.extract_issue_references(text)
      
      assert [%{type: :number, value: 123}] = refs
    end
    
    test "handles nil and empty strings" do
      assert GitHubHandler.extract_issue_references(nil) == []
      assert GitHubHandler.extract_issue_references("") == []
      assert GitHubHandler.extract_issue_references("no issues here") == []
    end
  end
  
  describe "handle_event/2 - pull_request" do
    setup do
      base_pr = %{
        "action" => "opened",
        "pull_request" => %{
          "number" => 42,
          "title" => "[RSOLV] Fix security issue",
          "body" => "This fixes #123\\n\\nGenerated by RSOLV",
          "html_url" => "https://github.com/test/repo/pull/42",
          "head" => %{"ref" => "rsolv/123-fix-security"},
          "base" => %{
            "repo" => %{
              "owner" => %{"login" => "test-org"},
              "name" => "test-repo"
            }
          },
          "user" => %{"login" => "rsolv-bot"},
          "labels" => [%{"name" => "rsolv:automated"}],
          "merged" => false,
          "merged_at" => nil,
          "merged_by" => nil,
          "merge_commit_sha" => nil
        }
      }
      
      {:ok, base_pr: base_pr}
    end
    
    test "creates fix attempt for opened RSOLV PR", %{base_pr: pr} do
      assert {:ok, :pr_opened} = GitHubHandler.handle_event("pull_request", pr)
      
      # Verify fix attempt was created
      fix_attempt = Repo.get_by(FixAttempt,
        github_org: "test-org",
        repo_name: "test-repo",
        pr_number: 42
      )
      
      assert fix_attempt != nil
      assert fix_attempt.pr_title == "[RSOLV] Fix security issue"
      assert fix_attempt.issue_number == 123
      assert fix_attempt.status == "pending"
      
      # Check metadata
      assert fix_attempt.metadata["branch"] == "rsolv/123-fix-security"
      assert "rsolv:automated" in fix_attempt.metadata["labels"]
      assert fix_attempt.metadata["created_by"] == "rsolv-bot"
      assert length(fix_attempt.metadata["issue_references"]) == 1
    end
    
    test "handles reopened PR same as opened", %{base_pr: pr} do
      pr = put_in(pr["action"], "reopened")
      assert {:ok, :pr_opened} = GitHubHandler.handle_event("pull_request", pr)
    end
    
    test "updates fix attempt when PR is merged", %{base_pr: pr} do
      # First create the fix attempt
      GitHubHandler.handle_event("pull_request", pr)
      
      # Then merge it
      merged_pr = pr
      |> put_in(["action"], "closed")
      |> put_in(["pull_request", "merged"], true)
      |> put_in(["pull_request", "merged_at"], "2025-06-03T19:00:00Z")
      |> put_in(["pull_request", "merged_by"], %{"login" => "reviewer"})
      |> put_in(["pull_request", "merge_commit_sha"], "abc123")
      
      assert {:ok, :merged} = GitHubHandler.handle_event("pull_request", merged_pr)
      
      # Verify update
      fix_attempt = Repo.get_by(FixAttempt,
        github_org: "test-org",
        repo_name: "test-repo",
        pr_number: 42
      )
      
      assert fix_attempt.status == "merged"
      assert fix_attempt.merged_by == "reviewer"
      assert fix_attempt.commit_sha == "abc123"
      assert fix_attempt.merged_at != nil
    end
    
    test "ignores non-RSOLV PRs", %{base_pr: pr} do
      # Remove all RSOLV identifiers
      non_rsolv_pr = pr
      |> put_in(["pull_request", "title"], "Regular PR")
      |> put_in(["pull_request", "body"], "Just a regular fix")
      |> put_in(["pull_request", "head", "ref"], "feature/something")
      |> put_in(["pull_request", "labels"], [])
      
      assert {:ok, :ignored} = GitHubHandler.handle_event("pull_request", non_rsolv_pr)
      
      # Verify no fix attempt was created
      assert Repo.get_by(FixAttempt, pr_number: 42) == nil
    end
    
    test "handles multiple issue references", %{base_pr: pr} do
      pr = put_in(pr["pull_request"]["body"], """
      This PR fixes multiple issues:
      - Fixes #123
      - Closes https://github.com/other/repo/issues/456
      - Resolves test-org/another-repo#789
      
      Generated by RSOLV
      """)
      
      assert {:ok, :pr_opened} = GitHubHandler.handle_event("pull_request", pr)
      
      fix_attempt = Repo.get_by(FixAttempt, pr_number: 42)
      refs = fix_attempt.metadata["issue_references"]
      
      assert length(refs) == 3
      assert fix_attempt.issue_number == 123  # Uses first reference
    end
    
    test "handles PR without issue references", %{base_pr: pr} do
      # Remove issue reference from body
      pr = put_in(pr["pull_request"]["body"], """
      This PR improves performance and refactors code.
      
      Generated by RSOLV
      """)
      
      assert {:ok, :pr_opened} = GitHubHandler.handle_event("pull_request", pr)
      
      # Verify fix attempt was created with nil issue_number
      fix_attempt = Repo.get_by(FixAttempt, pr_number: 42)
      assert fix_attempt != nil
      assert fix_attempt.issue_number == nil
      assert fix_attempt.pr_title == "[RSOLV] Fix security issue"
      assert fix_attempt.metadata["issue_references"] == []
    end
  end
end