defmodule Rsolv.Security.Patterns.Php.SsrfVulnerabilityTest do
  use ExUnit.Case, async: true

  alias Rsolv.Security.Patterns.Php.SsrfVulnerability
  alias Rsolv.Security.Pattern

  describe "pattern/0" do
    test "returns a valid pattern struct" do
      pattern = SsrfVulnerability.pattern()

      assert %Pattern{} = pattern
      assert pattern.id == "php-ssrf-vulnerability"
      assert pattern.name == "Server-Side Request Forgery (SSRF)"
      assert pattern.severity == :high
      assert pattern.type == :ssrf
      assert pattern.languages == ["php"]
    end

    test "includes CWE and OWASP references" do
      pattern = SsrfVulnerability.pattern()

      assert pattern.cwe_id == "CWE-918"
      assert pattern.owasp_category == "A10:2021"
    end
  end

  describe "regex matching" do
    setup do
      pattern = SsrfVulnerability.pattern()
      {:ok, pattern: pattern}
    end

    test "matches file_get_contents with user input", %{pattern: pattern} do
      vulnerable_code = [
        ~S|$content = file_get_contents($_POST['url']);|,
        ~S|$data = file_get_contents($_GET['api_url']);|,
        ~S|$result = file_get_contents($_REQUEST['endpoint']);|,
        ~S|file_get_contents($_COOKIE['remote_url']);|
      ]

      for code <- vulnerable_code do
        assert Regex.match?(pattern.regex, code),
               "Should match: #{code}"
      end
    end

    test "matches curl_exec with user input", %{pattern: pattern} do
      vulnerable_code = [
        ~S|curl_setopt($ch, CURLOPT_URL, $_POST['url']); $result = curl_exec($ch);|,
        ~S|curl_setopt($ch, CURLOPT_URL, $_GET['target']); curl_exec($ch);|,
        ~S|curl_setopt($curl, CURLOPT_URL, $_REQUEST['api']);|,
        ~S|curl_setopt($handle, CURLOPT_URL, $_COOKIE['callback']);|
      ]

      for code <- vulnerable_code do
        assert Regex.match?(pattern.regex, code),
               "Should match: #{code}"
      end
    end

    test "matches fopen with user input", %{pattern: pattern} do
      vulnerable_code = [
        ~S|$handle = fopen($_POST['url'], 'r');|,
        ~S|$fp = fopen($_GET['file_url'], 'rb');|,
        ~S|fopen($_REQUEST['resource'], 'r');|,
        ~S|$stream = fopen($_COOKIE['data_url'], 'rb');|
      ]

      for code <- vulnerable_code do
        assert Regex.match?(pattern.regex, code),
               "Should match: #{code}"
      end
    end

    test "matches readfile with user input", %{pattern: pattern} do
      vulnerable_code = [
        ~S|readfile($_POST['download_url']);|,
        ~S|readfile($_GET['file']);|,
        ~S|$size = readfile($_REQUEST['resource']);|,
        ~S|readfile($_COOKIE['media_url']);|
      ]

      for code <- vulnerable_code do
        assert Regex.match?(pattern.regex, code),
               "Should match: #{code}"
      end
    end

    test "matches various spacing and formatting", %{pattern: pattern} do
      vulnerable_code = [
        ~S|file_get_contents( $_GET['url'] );|,
        ~S|curl_setopt(  $ch, CURLOPT_URL,  $_POST['target']  );|,
        ~S|fopen($_REQUEST['file'], 'r');|,
        ~S|readfile( $_COOKIE['download'] );|
      ]

      for code <- vulnerable_code do
        assert Regex.match?(pattern.regex, code),
               "Should match: #{code}"
      end
    end

    test "does not match safe operations", %{pattern: pattern} do
      safe_code = [
        ~S|$content = file_get_contents('config.php');|,
        ~S|curl_setopt($ch, CURLOPT_URL, 'https://api.example.com');|,
        ~S|$handle = fopen($validated_url, 'r');|,
        ~S|readfile('static/file.pdf');|,
        ~S|$data = json_decode($_POST['data'], true);|
      ]

      for code <- safe_code do
        refute Regex.match?(pattern.regex, code),
               "Should not match: #{code}"
      end
    end

    test "matches real-world vulnerable patterns", %{pattern: pattern} do
      vulnerable_code = [
        ~S|$image = file_get_contents($_GET['image_proxy']);|,
        ~S|curl_setopt($ch, CURLOPT_URL, $_POST['webhook_url']);|,
        ~S|$config = file_get_contents($_REQUEST['config_url']);|,
        ~S|$proxy = fopen($_COOKIE['proxy_endpoint'], 'r');|
      ]

      for code <- vulnerable_code do
        assert Regex.match?(pattern.regex, code),
               "Should match: #{code}"
      end
    end
  end

  describe "test_cases/0" do
    test "all positive cases match" do
      pattern = SsrfVulnerability.pattern()
      test_cases = SsrfVulnerability.test_cases()

      for test_case <- test_cases.positive do
        assert Regex.match?(pattern.regex, test_case.code),
               "Failed to match positive case: #{test_case.description}"
      end
    end

    test "negative cases are documented correctly" do
      test_cases = SsrfVulnerability.test_cases()

      assert length(test_cases.negative) > 0

      for test_case <- test_cases.negative do
        assert Map.has_key?(test_case, :code)
        assert Map.has_key?(test_case, :description)
      end
    end
  end

  describe "ast_enhancement/0" do
    test "returns proper enhancement rules" do
      enhancement = SsrfVulnerability.ast_enhancement()

      assert enhancement.min_confidence >= 0.7
      assert length(enhancement.ast_rules) >= 3

      ssrf_functions_rule = Enum.find(enhancement.ast_rules, &(&1.type == "ssrf_functions"))
      assert ssrf_functions_rule
      assert "file_get_contents" in ssrf_functions_rule.functions
      assert "curl_setopt" in ssrf_functions_rule.functions

      validation_rule = Enum.find(enhancement.ast_rules, &(&1.type == "url_validation"))
      assert validation_rule
      assert "filter_var" in validation_rule.functions
      assert "parse_url" in validation_rule.functions
    end
  end

  describe "pattern metadata" do
    test "has proper OWASP reference" do
      pattern = SsrfVulnerability.pattern()
      assert pattern.owasp_category == "A10:2021"
    end

    test "has educational content" do
      desc = SsrfVulnerability.vulnerability_description()
      assert desc =~ "Server-Side Request Forgery"
      assert desc =~ "SSRF"
      assert desc =~ "internal resources"
    end

    test "provides safe alternatives" do
      examples = SsrfVulnerability.examples()
      assert Map.has_key?(examples.fixed, "URL allowlist validation")
      assert Map.has_key?(examples.fixed, "Network restrictions")
    end
  end
end
