/**
 * Tests for VulnerabilityRegistryClient
 * RFC-104: CWE Vulnerability Type Registry
 */
import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { VulnerabilityRegistryClient, VulnerabilityTypeEntry } from '../../external/vulnerability-registry-client.js';
import { setupFetchMock } from '../../../test-helpers/simple-mocks.js';

function makeMockEntry(overrides: Partial<VulnerabilityTypeEntry> = {}): VulnerabilityTypeEntry {
  return {
    cwe_id: 'CWE-89',
    name: 'SQL Injection',
    description: 'SQL Injection vulnerability',
    coverage_status: 'partial',
    pattern_types: ['sql_injection'],
    ecosystems: ['javascript', 'python'],
    related_cwes: ['CWE-943'],
    assertion_template: {
      name: 'SQL Injection',
      assertion_goal: 'Assert user input appears unescaped in query',
      attack_payload: "' OR '1'='1",
      test_strategy: 'Mock the database and capture the query',
      framework_hints: { mocha: 'Use sinon.stub()', pytest: 'Use unittest.mock' },
    },
    few_shot_examples: {
      mocha: '// CWE-89 mocha example\ndescribe("sql", () => {});',
      pytest: '# CWE-89 pytest example\ndef test_sql(): pass',
    },
    few_shot_example: null,
    framework_hint: null,
    educational_content: {
      title: 'SQL Injection',
      description: 'Occurs when untrusted data enters SQL queries',
      prevention: 'Use parameterized queries',
    },
    fix_guidance: { javascript: 'Use prepared statements' },
    ...overrides,
  };
}

describe('VulnerabilityRegistryClient', () => {
  let client: VulnerabilityRegistryClient;
  let fetchMock: ReturnType<typeof setupFetchMock>;
  let originalFetch: typeof fetch;

  beforeEach(() => {
    originalFetch = global.fetch;
    fetchMock = setupFetchMock();
    client = new VulnerabilityRegistryClient('test-api-key', 'https://api.test.dev');
  });

  afterEach(() => {
    global.fetch = originalFetch;
    vi.restoreAllMocks();
  });

  describe('getEntry', () => {
    it('fetches entry from platform API', async () => {
      const mockEntry = makeMockEntry();
      fetchMock.mockImplementationOnce(() =>
        Promise.resolve({
          ok: true,
          status: 200,
          json: async () => mockEntry,
          text: async () => JSON.stringify(mockEntry),
        } as Response)
      );

      const result = await client.getEntry('CWE-89');

      expect(result).not.toBeNull();
      expect(result?.cwe_id).toBe('CWE-89');
      expect(result?.name).toBe('SQL Injection');
      expect(result?.assertion_template?.name).toBe('SQL Injection');
      expect(result?.few_shot_examples?.mocha).toContain('CWE-89 mocha');

      // Verify correct URL and headers
      expect(fetchMock).toHaveBeenCalledOnce();
      const [url, options] = fetchMock.mock.calls[0];
      expect(url).toBe('https://api.test.dev/api/v1/vulnerability-types/CWE-89');
      expect(options.headers['x-api-key']).toBe('test-api-key');
    });

    it('includes framework query param when provided', async () => {
      const mockEntry = makeMockEntry({
        few_shot_example: '// specific mocha example',
        framework_hint: 'Use sinon.stub()',
      });
      fetchMock.mockImplementationOnce(() =>
        Promise.resolve({
          ok: true,
          status: 200,
          json: async () => mockEntry,
          text: async () => JSON.stringify(mockEntry),
        } as Response)
      );

      const result = await client.getEntry('CWE-89', 'mocha');

      expect(result).not.toBeNull();
      expect(result?.few_shot_example).toBe('// specific mocha example');
      expect(result?.framework_hint).toBe('Use sinon.stub()');

      const [url] = fetchMock.mock.calls[0];
      expect(url).toBe('https://api.test.dev/api/v1/vulnerability-types/CWE-89?framework=mocha');
    });

    it('returns null for 404 (unknown CWE)', async () => {
      fetchMock.mockImplementationOnce(() =>
        Promise.resolve({
          ok: false,
          status: 404,
          json: async () => ({ error: 'not_found' }),
          text: async () => '{"error":"not_found"}',
        } as Response)
      );

      const result = await client.getEntry('CWE-99999');
      expect(result).toBeNull();
    });

    it('returns null for server errors', async () => {
      fetchMock.mockImplementationOnce(() =>
        Promise.resolve({
          ok: false,
          status: 500,
          json: async () => ({ error: 'internal' }),
          text: async () => 'Internal Server Error',
        } as Response)
      );

      const result = await client.getEntry('CWE-89');
      expect(result).toBeNull();
    });

    it('returns null on network error', async () => {
      fetchMock.mockImplementationOnce(() =>
        Promise.reject(new Error('Network error'))
      );

      const result = await client.getEntry('CWE-89');
      expect(result).toBeNull();
    });

    it('caches entries to avoid repeated API calls', async () => {
      const mockEntry = makeMockEntry();
      fetchMock.mockImplementationOnce(() =>
        Promise.resolve({
          ok: true,
          status: 200,
          json: async () => mockEntry,
          text: async () => JSON.stringify(mockEntry),
        } as Response)
      );

      // First call — fetches from API
      const result1 = await client.getEntry('CWE-89');
      expect(result1).not.toBeNull();
      expect(fetchMock).toHaveBeenCalledOnce();

      // Second call — uses cache, no new fetch
      const result2 = await client.getEntry('CWE-89');
      expect(result2).not.toBeNull();
      expect(result2?.cwe_id).toBe('CWE-89');
      expect(fetchMock).toHaveBeenCalledOnce(); // Still just 1 call
    });

    it('caches separately by framework', async () => {
      const mochaEntry = makeMockEntry({ few_shot_example: 'mocha code' });
      const pytestEntry = makeMockEntry({ few_shot_example: 'pytest code' });

      fetchMock
        .mockImplementationOnce(() =>
          Promise.resolve({
            ok: true, status: 200,
            json: async () => mochaEntry,
            text: async () => JSON.stringify(mochaEntry),
          } as Response)
        )
        .mockImplementationOnce(() =>
          Promise.resolve({
            ok: true, status: 200,
            json: async () => pytestEntry,
            text: async () => JSON.stringify(pytestEntry),
          } as Response)
        );

      const r1 = await client.getEntry('CWE-89', 'mocha');
      const r2 = await client.getEntry('CWE-89', 'pytest');

      expect(r1?.few_shot_example).toBe('mocha code');
      expect(r2?.few_shot_example).toBe('pytest code');
      expect(fetchMock).toHaveBeenCalledTimes(2);
    });
  });

  describe('getFewShotExample (static)', () => {
    it('returns few_shot_example when available (framework-specific from API)', () => {
      const entry = makeMockEntry({
        few_shot_example: '// framework-specific example from API',
      });
      const result = VulnerabilityRegistryClient.getFewShotExample(entry, 'mocha');
      expect(result).toBe('// framework-specific example from API');
    });

    it('falls back to few_shot_examples map when few_shot_example is null', () => {
      const entry = makeMockEntry({
        few_shot_example: null,
        few_shot_examples: { mocha: '// from map' },
      });
      const result = VulnerabilityRegistryClient.getFewShotExample(entry, 'mocha');
      expect(result).toBe('// from map');
    });

    it('returns null when framework not in few_shot_examples', () => {
      const entry = makeMockEntry({
        few_shot_example: null,
        few_shot_examples: { mocha: '// mocha only' },
      });
      const result = VulnerabilityRegistryClient.getFewShotExample(entry, 'rspec');
      expect(result).toBeNull();
    });

    it('returns null when few_shot_examples is null', () => {
      const entry = makeMockEntry({
        few_shot_example: null,
        few_shot_examples: null,
      });
      const result = VulnerabilityRegistryClient.getFewShotExample(entry, 'mocha');
      expect(result).toBeNull();
    });
  });
});
