/**
 * Vulnerability Assertion Templates
 * RFC-103: RED Test Generation Quality Improvements
 *
 * Phase 2.3: Templates now include behavioral test guidance (Tier 1/2)
 * that instruct the LLM to exercise vulnerable code at runtime, not just
 * scan source files with regex.
 *
 * Phase 2.4: Framework hints include best-practice conventions from
 * betterspecs.org (RSpec), pytest docs, etc.
 *
 * Test Tier Strategy:
 *   Tier 1 (preferred): Import the vulnerable function, mock side effects,
 *          call with malicious input, assert dangerous behavior occurs.
 *   Tier 2 (alternative): Use framework test client to send HTTP requests
 *          with attack payloads, assert response shows vulnerability.
 *   Tier 3 (last resort): Read source file and regex-match for patterns.
 *          Only use when import/HTTP is infeasible. Comment why.
 */

export interface AssertionTemplate {
  name: string;
  assertionGoal: string;
  attackPayload: string;
  testStrategy: string;
  frameworkHints: Record<string, string>;
}

// Framework convention preambles — prepended to each framework hint
const RSPEC_CONVENTIONS =
  'RSpec conventions (betterspecs.org): Use context blocks starting with "when"/"with". ' +
  'One expect() per it block. Use let for test variables. Describe with "#method_name". ' +
  'Use expect() syntax (not should).\n';

const PYTEST_CONVENTIONS =
  'pytest conventions: Use def test_*() functions (not classes). ' +
  'Use @pytest.fixture for setup. Use plain assert statements. ' +
  'Use @pytest.mark.parametrize for multiple inputs.\n';

const MOCHA_CONVENTIONS =
  'Mocha/Vitest conventions: Use describe/it blocks. ' +
  'Use strict assertions (assert.strictEqual over assert.equal). ' +
  'One assertion per it block when possible.\n';

const PHPUNIT_CONVENTIONS =
  'PHPUnit conventions: Use test* methods or @test annotation. ' +
  'Use $this->assert*() methods. Use @dataProvider for multiple inputs.\n';

const EXUNIT_CONVENTIONS =
  'ExUnit conventions: Use describe/test blocks. ' +
  'Use assert/refute macros. Use setup/setup_all for fixtures.\n';

const JUNIT_CONVENTIONS =
  'JUnit 5 conventions: Use @Test annotation. Use @Nested for grouping. ' +
  'Use Assertions.assert*() static methods. Use @ParameterizedTest for multiple inputs.\n';

const TEMPLATES: Record<string, AssertionTemplate> = {
  'CWE-89': {
    name: 'SQL Injection',
    assertionGoal:
      'Import the vulnerable function, mock the database layer, call with SQL injection payload, ' +
      'and assert the payload appears unescaped in the captured query string.',
    attackPayload: '\' OR \'1\'=\'1',
    testStrategy:
      'PREFERRED (Tier 1 — Direct function call):\n' +
      '1. Import/require the module containing the vulnerable function\n' +
      '2. Mock/stub the database connection to capture the SQL query string\n' +
      '3. Call the function with input containing: \' OR \'1\'=\'1\n' +
      '4. Assert the captured SQL query contains the literal unescaped payload\n\n' +
      'ALTERNATIVE (Tier 2 — HTTP request):\n' +
      '1. Use the framework test client (supertest, requests, etc.)\n' +
      '2. Send HTTP request to the vulnerable endpoint with injection payload\n' +
      '3. Capture the SQL query via mock/spy on the database layer\n' +
      '4. Assert the query contains unescaped user input\n\n' +
      'LAST RESORT (Tier 3 — Source analysis):\n' +
      '1. Read the source file\n' +
      '2. Check for string concatenation/interpolation in SQL queries\n' +
      '3. Comment: "// Source analysis fallback — could not import module because: <reason>"',
    frameworkHints: {
      rspec:
        RSPEC_CONVENTIONS +
        'BEHAVIORAL: Use allow().to receive() to stub the database connection and capture the query.\n' +
        'Example:\n' +
        '  let(:malicious_input) { "\' OR \'1\'=\'1" }\n' +
        '  it \'passes unsanitized input to SQL\' do\n' +
        '    allow(ActiveRecord::Base.connection).to receive(:execute).and_call_original\n' +
        '    expect(ActiveRecord::Base.connection).to receive(:execute)\n' +
        '      .with(a_string_including("\' OR \'1\'=\'1"))\n' +
        '    User.search(malicious_input)\n' +
        '  end',
      pytest:
        PYTEST_CONVENTIONS +
        'BEHAVIORAL: Use unittest.mock.patch to intercept the query execution.\n' +
        'Example:\n' +
        '  from unittest.mock import patch\n' +
        '  def test_sql_injection():\n' +
        '      with patch(\'app.db.execute\') as mock_db:\n' +
        '          search_users(query="\' OR \'1\'=\'1")\n' +
        '          sql = mock_db.call_args[0][0]\n' +
        '          assert "\' OR \'1\'=\'1" in sql',
      mocha:
        MOCHA_CONVENTIONS +
        'BEHAVIORAL: Use sinon.stub() to capture the query string.\n' +
        'Example:\n' +
        '  const sinon = require(\'sinon\');\n' +
        '  const queryStub = sinon.stub(db, \'query\').resolves([]);\n' +
        '  await searchUsers({ query: "\' OR \'1\'=\'1" });\n' +
        '  assert.ok(queryStub.firstCall.args[0].includes("\' OR \'1\'=\'1"));',
      exunit:
        EXUNIT_CONVENTIONS +
        'BEHAVIORAL: Use Mox to mock the Ecto.Repo and capture the query.\n' +
        'Define a mock for the repo module and verify the query contains the payload.',
      phpunit:
        PHPUNIT_CONVENTIONS +
        'BEHAVIORAL: Use Mockery to mock PDO and capture the query string.\n' +
        'Mock PDO::prepare() or PDO::query() and capture the SQL parameter.',
      junit:
        JUNIT_CONVENTIONS +
        'BEHAVIORAL: Use Mockito to mock PreparedStatement and capture the query.\n' +
        'Verify that Connection.prepareStatement() receives a string containing the payload.',
    },
  },
  'CWE-79': {
    name: 'Cross-Site Scripting (XSS)',
    assertionGoal:
      'Import the vulnerable route handler or template function, call it with XSS payload, ' +
      'and assert the response body contains the unescaped script tag.',
    attackPayload: '<script>alert(\'XSS\')</script>',
    testStrategy:
      'PREFERRED (Tier 1 — Direct function call):\n' +
      '1. Import the route handler or template rendering function\n' +
      '2. Mock the response object to capture output\n' +
      '3. Call with input containing: <script>alert(\'XSS\')</script>\n' +
      '4. Assert the output contains literal \'<script>\' (not \'&lt;script&gt;\')\n\n' +
      'ALTERNATIVE (Tier 2 — HTTP request):\n' +
      '1. Use the framework test client\n' +
      '2. Send request with XSS payload in the parameter\n' +
      '3. Assert response body contains unescaped \'<script>\'\n\n' +
      'LAST RESORT (Tier 3 — Source analysis):\n' +
      '1. Read the source file\n' +
      '2. Check for raw output of user input without escaping',
    frameworkHints: {
      rspec:
        RSPEC_CONVENTIONS +
        'BEHAVIORAL: Use test client to send request with XSS payload.\n' +
        'Example:\n' +
        '  context \'when input contains script tags\' do\n' +
        '    it \'renders without escaping\' do\n' +
        '      get \'/search\', params: { q: "<script>alert(\'XSS\')</script>" }\n' +
        '      expect(response.body).to include(\'<script>\')\n' +
        '    end\n' +
        '  end',
      pytest:
        PYTEST_CONVENTIONS +
        'BEHAVIORAL: Use Flask/Django test client with XSS payload.\n' +
        'Example:\n' +
        '  def test_xss(client):\n' +
        '      response = client.get(\'/search?q=<script>alert("XSS")</script>\')\n' +
        '      assert b\'<script>\' in response.data',
      mocha:
        MOCHA_CONVENTIONS +
        'BEHAVIORAL: Use supertest or the framework test helper.\n' +
        'Example:\n' +
        '  const request = require(\'supertest\');\n' +
        '  it(\'reflects XSS payload in response\', async () => {\n' +
        '    const res = await request(app).get(\'/search?q=<script>alert("XSS")</script>\');\n' +
        '    assert.ok(res.text.includes(\'<script>\'));\n' +
        '  });',
      exunit:
        EXUNIT_CONVENTIONS +
        'BEHAVIORAL: Use Phoenix.ConnTest to send request with XSS payload.\n' +
        'Assert the response body contains the literal script tag without encoding.',
      phpunit:
        PHPUNIT_CONVENTIONS +
        'BEHAVIORAL: Use the framework test client or capture output buffer.\n' +
        'Use assertStringContainsString() to verify unescaped HTML.',
      junit:
        JUNIT_CONVENTIONS +
        'BEHAVIORAL: Use MockMvc to send request with XSS payload.\n' +
        'Verify the response contains literal \'<script>\' without HTML entity encoding.',
    },
  },
  'CWE-22': {
    name: 'Path Traversal',
    assertionGoal:
      'Import the file-serving function, mock filesystem operations, call with traversal payload, ' +
      'and assert the resolved path escapes the intended directory.',
    attackPayload: '../../../etc/passwd',
    testStrategy:
      'PREFERRED (Tier 1 — Direct function call):\n' +
      '1. Import the function that handles file paths\n' +
      '2. Mock/stub filesystem operations (fs.readFile, open, etc.)\n' +
      '3. Call with path containing: ../../../etc/passwd\n' +
      '4. Assert the path passed to fs operations contains \'../\' or resolves outside base dir\n\n' +
      'ALTERNATIVE (Tier 2 — HTTP request):\n' +
      '1. Use test client to request a file with traversal path\n' +
      '2. Assert the response returns the traversed file or a 200 status\n\n' +
      'LAST RESORT (Tier 3 — Source analysis):\n' +
      '1. Read the source and check for missing path.resolve/realpath validation',
    frameworkHints: {
      rspec:
        RSPEC_CONVENTIONS +
        'BEHAVIORAL: Mock File operations to capture the resolved path.\n' +
        'Example:\n' +
        '  let(:traversal_path) { \'../../../etc/passwd\' }\n' +
        '  it \'allows path traversal\' do\n' +
        '    allow(File).to receive(:read) { |path| @captured_path = path }\n' +
        '    serve_file(traversal_path)\n' +
        '    expect(@captured_path).to include(\'..\')\n' +
        '  end',
      pytest:
        PYTEST_CONVENTIONS +
        'BEHAVIORAL: Use unittest.mock.patch(\'builtins.open\') to capture the path argument.',
      mocha:
        MOCHA_CONVENTIONS +
        'BEHAVIORAL: Use sinon.stub() on fs.readFile. Capture the path and assert it contains \'../\'.',
      exunit:
        EXUNIT_CONVENTIONS +
        'BEHAVIORAL: Use Mox to mock File operations and capture the path.',
      phpunit:
        PHPUNIT_CONVENTIONS +
        'BEHAVIORAL: Mock file_get_contents() or fopen() to capture the resolved path.',
      junit:
        JUNIT_CONVENTIONS +
        'BEHAVIORAL: Mock java.io.File or java.nio.file operations to capture the path.',
    },
  },
  'CWE-78': {
    name: 'Command Injection',
    assertionGoal:
      'Import the function that executes shell commands, mock the command execution, ' +
      'call with injection payload, and assert the captured command contains the injected part.',
    attackPayload: '; cat /etc/passwd',
    testStrategy:
      'PREFERRED (Tier 1 — Direct function call):\n' +
      '1. Import the module containing the shell execution\n' +
      '2. Mock child_process.exec/execSync, subprocess.run, system(), etc.\n' +
      '3. Call with input containing: ; cat /etc/passwd\n' +
      '4. Assert the captured command string contains the semicolon and injected command\n\n' +
      'ALTERNATIVE (Tier 2 — HTTP request):\n' +
      '1. Use test client to send request with injection payload\n' +
      '2. Capture the command via mock/spy on the execution function\n\n' +
      'LAST RESORT (Tier 3 — Source analysis):\n' +
      '1. Read source and check for string concatenation in shell commands',
    frameworkHints: {
      rspec:
        RSPEC_CONVENTIONS +
        'BEHAVIORAL: Stub Kernel.system or Open3 to capture the command.\n' +
        'Example:\n' +
        '  let(:payload) { \'127.0.0.1; cat /etc/passwd\' }\n' +
        '  it \'passes unsanitized input to shell\' do\n' +
        '    expect(Kernel).to receive(:system).with(a_string_including(\'; cat\'))\n' +
        '    ping(payload)\n' +
        '  end',
      pytest:
        PYTEST_CONVENTIONS +
        'BEHAVIORAL: Use unittest.mock.patch(\'subprocess.run\') to capture the command.\n' +
        'Example:\n' +
        '  from unittest.mock import patch\n' +
        '  def test_command_injection():\n' +
        '      with patch(\'subprocess.run\') as mock_run:\n' +
        '          ping("127.0.0.1; cat /etc/passwd")\n' +
        '          cmd = mock_run.call_args[0][0]\n' +
        '          assert "; cat" in cmd',
      mocha:
        MOCHA_CONVENTIONS +
        'BEHAVIORAL: Use sinon.stub() on child_process.exec.\n' +
        'Example:\n' +
        '  const cp = require(\'child_process\');\n' +
        '  const execStub = sinon.stub(cp, \'exec\');\n' +
        '  ping({ address: "127.0.0.1; cat /etc/passwd" });\n' +
        '  assert.ok(execStub.firstCall.args[0].includes(\'; cat\'));',
      exunit:
        EXUNIT_CONVENTIONS +
        'BEHAVIORAL: Use Mox to mock System.cmd and capture the command string.',
      phpunit:
        PHPUNIT_CONVENTIONS +
        'BEHAVIORAL: Mock exec(), shell_exec(), or system() to capture the command string.',
      junit:
        JUNIT_CONVENTIONS +
        'BEHAVIORAL: Mock Runtime.exec() or ProcessBuilder to capture the command.',
    },
  },
  'CWE-94': {
    name: 'Code Injection',
    assertionGoal:
      'Import the function that processes user input, mock the dangerous eval/exec function, ' +
      'call with code injection payload, and assert eval receives attacker-controlled input.',
    attackPayload: 'require(\'child_process\').execSync(\'id\').toString()',
    testStrategy:
      'PREFERRED (Tier 1 — Direct function call):\n' +
      '1. Import the module containing the vulnerable handler\n' +
      '2. Mock eval(), new Function(), or vm.runInContext()\n' +
      '3. Call the function with malicious input\n' +
      '4. Assert eval was called with the attacker-controlled string\n\n' +
      'ALTERNATIVE (Tier 2 — HTTP request):\n' +
      '1. Use test client to send request with code injection payload\n' +
      '2. Mock eval/exec and verify it was called\n\n' +
      'LAST RESORT (Tier 3 — Source analysis):\n' +
      '1. Read source and detect eval() calls with user-controlled input',
    frameworkHints: {
      mocha:
        MOCHA_CONVENTIONS +
        'BEHAVIORAL: Stub eval or child_process.exec to capture calls.\n' +
        'Example:\n' +
        '  const cp = require(\'child_process\');\n' +
        '  vi.mock(\'child_process\');\n' +
        '  it(\'passes user input to exec\', () => {\n' +
        '    handler({ body: { code: "require(\'child_process\').exec(\'id\')" } });\n' +
        '    expect(cp.exec).toHaveBeenCalled();\n' +
        '  });',
      jest:
        'BEHAVIORAL: Mock eval or child_process. Use jest.spyOn to capture calls.',
      rspec:
        RSPEC_CONVENTIONS +
        'BEHAVIORAL: Stub eval or Kernel.system to capture code execution calls.',
      pytest:
        PYTEST_CONVENTIONS +
        'BEHAVIORAL: Use unittest.mock.patch(\'builtins.eval\') to intercept eval calls.\n' +
        'Example:\n' +
        '  def test_code_injection():\n' +
        '      with patch(\'builtins.eval\') as mock_eval:\n' +
        '          process_input("__import__(\'os\').system(\'id\')")\n' +
        '          mock_eval.assert_called()',
      exunit:
        EXUNIT_CONVENTIONS +
        'BEHAVIORAL: Mock Code.eval_string to capture eval calls.',
      phpunit:
        PHPUNIT_CONVENTIONS +
        'BEHAVIORAL: Detect eval(), create_function(), or preg_replace with /e modifier.',
      junit:
        JUNIT_CONVENTIONS +
        'BEHAVIORAL: Mock ScriptEngine.eval() to capture code execution attempts.',
    },
  },
  'CWE-502': {
    name: 'Insecure Deserialization',
    assertionGoal:
      'Import the function that deserializes data, mock the deserialization mechanism, ' +
      'call with malicious serialized payload, and assert unsafe deserialization occurs.',
    attackPayload: 'O:8:"stdClass":1:{s:4:"code";s:10:"system(\'id\');";}',
    testStrategy:
      'PREFERRED (Tier 1 — Direct function call):\n' +
      '1. Import the function that processes serialized data\n' +
      '2. Mock/spy on the deserialization function (Marshal.load, pickle.loads, etc.)\n' +
      '3. Call with malicious serialized payload\n' +
      '4. Assert the unsafe deserializer was called without type checking\n\n' +
      'ALTERNATIVE (Tier 2 — HTTP request):\n' +
      '1. Use test client to send request with serialized payload\n' +
      '2. Verify deserialization occurs without validation\n\n' +
      'LAST RESORT (Tier 3 — Source analysis):\n' +
      '1. Read source and detect Marshal.load/pickle.loads without safe options',
    frameworkHints: {
      rspec:
        RSPEC_CONVENTIONS +
        'BEHAVIORAL: Spy on Marshal.load to verify it\'s called with untrusted data.\n' +
        'Example:\n' +
        '  context \'when deserializing user input\' do\n' +
        '    it \'uses Marshal.load without validation\' do\n' +
        '      allow(Marshal).to receive(:load).and_call_original\n' +
        '      expect(Marshal).to receive(:load)\n' +
        '      process_data(malicious_payload)\n' +
        '    end\n' +
        '  end',
      pytest:
        PYTEST_CONVENTIONS +
        'BEHAVIORAL: Patch pickle.loads to track deserialization.\n' +
        'Example:\n' +
        '  def test_insecure_deserialization():\n' +
        '      with patch(\'pickle.loads\') as mock_loads:\n' +
        '          process_data(malicious_payload)\n' +
        '          mock_loads.assert_called()',
      mocha:
        MOCHA_CONVENTIONS +
        'BEHAVIORAL: Track JSON.parse with reviver or detect node-serialize usage.\n' +
        'Stub the unserialize function and verify it receives untrusted input.',
      exunit:
        EXUNIT_CONVENTIONS +
        'BEHAVIORAL: Mock :erlang.binary_to_term and verify [:safe] option is NOT passed.',
      phpunit:
        PHPUNIT_CONVENTIONS +
        'BEHAVIORAL: Track unserialize() calls and verify no allowed_classes restriction.',
      junit:
        JUNIT_CONVENTIONS +
        'BEHAVIORAL: Mock ObjectInputStream.readObject() to verify type filtering is absent.',
    },
  },
  'CWE-1321': {
    name: 'Prototype Pollution',
    assertionGoal:
      'Import the function that merges/extends objects, call it with __proto__ payload, ' +
      'and assert that Object.prototype was modified (proving pollution occurred).',
    attackPayload: '{"__proto__": {"isAdmin": true}}',
    testStrategy:
      'PREFERRED (Tier 1 — Direct function call):\n' +
      '1. Import the merge/extend/deepCopy function\n' +
      '2. Call with payload: {"__proto__": {"isAdmin": true}}\n' +
      '3. Check if ({}).isAdmin === true (proves prototype was polluted)\n' +
      '4. Clean up: delete Object.prototype.isAdmin\n\n' +
      'ALTERNATIVE (Tier 2 — HTTP request):\n' +
      '1. Send POST request with __proto__ in JSON body\n' +
      '2. Verify a new object inherits the polluted property\n\n' +
      'LAST RESORT (Tier 3 — Source analysis):\n' +
      '1. Read source and detect obj[key] = value without __proto__ guard',
    frameworkHints: {
      mocha:
        MOCHA_CONVENTIONS +
        'BEHAVIORAL: Call the merge function and check for pollution.\n' +
        'Example:\n' +
        '  it(\'allows prototype pollution\', () => {\n' +
        '    const payload = JSON.parse(\'{"__proto__": {"polluted": true}}\');\n' +
        '    merge({}, payload);\n' +
        '    const obj = {};\n' +
        '    assert.strictEqual(obj.polluted, true, \'Prototype was polluted\');\n' +
        '    delete Object.prototype.polluted; // cleanup\n' +
        '  });',
      jest:
        'BEHAVIORAL: Import the merge function and test with __proto__ payload.\n' +
        'Check ({}).polluted === true after merge. Clean up after test.',
      rspec:
        RSPEC_CONVENTIONS +
        'Ruby is not typically vulnerable to prototype pollution. Check for unsafe merge patterns in JS assets.',
      pytest:
        PYTEST_CONVENTIONS +
        'Python dicts are not vulnerable to prototype pollution. Check for unsafe JS interop or API endpoints.',
      exunit:
        EXUNIT_CONVENTIONS +
        'Elixir maps are not vulnerable to prototype pollution. Check for unsafe JS interop.',
      phpunit:
        PHPUNIT_CONVENTIONS +
        'PHP objects are not typically vulnerable to prototype pollution. Check for unsafe json_decode patterns.',
      junit:
        JUNIT_CONVENTIONS +
        'Java objects are not typically vulnerable to prototype pollution. Check for unsafe JSON deserialization.',
    },
  },
  'CWE-798': {
    name: 'Hardcoded Credentials',
    assertionGoal:
      'Import the configuration module, inspect the credential values at runtime, ' +
      'and assert they are literal strings rather than environment variable references.',
    attackPayload: 'password123_or_any_literal_secret',
    testStrategy:
      'PREFERRED (Tier 1 — Direct function call):\n' +
      '1. Import/require the config module that contains credentials\n' +
      '2. Access the credential property (apiKey, password, secret, etc.)\n' +
      '3. Assert it equals a hardcoded literal value (not process.env.X)\n' +
      '4. Or verify typeof is \'string\' and doesn\'t match env var pattern\n\n' +
      'ALTERNATIVE (Tier 2 — Module inspection):\n' +
      '1. Import the module and introspect its exported values\n' +
      '2. Check if secrets are hardcoded constants vs runtime lookups\n\n' +
      'LAST RESORT (Tier 3 — Source analysis):\n' +
      '1. Read source file and regex for hardcoded credential patterns',
    frameworkHints: {
      rspec:
        RSPEC_CONVENTIONS +
        'BEHAVIORAL: Require the config file and inspect credential values.\n' +
        'Example:\n' +
        '  context \'when checking for hardcoded secrets\' do\n' +
        '    it \'contains literal credential values\' do\n' +
        '      config = YAML.load_file(\'config/database.yml\')\n' +
        '      expect(config[\'production\'][\'password\']).not_to match(/ENV/)\n' +
        '    end\n' +
        '  end',
      pytest:
        PYTEST_CONVENTIONS +
        'BEHAVIORAL: Import the config module and check credential values.\n' +
        'Example:\n' +
        '  def test_hardcoded_secrets():\n' +
        '      import app.config as config\n' +
        '      assert not config.API_KEY.startswith("$"), "Key should be from env var"',
      mocha:
        MOCHA_CONVENTIONS +
        'BEHAVIORAL: Require the config and inspect credential values.\n' +
        'Example:\n' +
        '  const config = require(path.join(process.cwd(), \'config.js\'));\n' +
        '  it(\'contains hardcoded API key\', () => {\n' +
        '    assert.ok(typeof config.apiKey === \'string\' && config.apiKey.length > 10,\n' +
        '      \'API key is hardcoded (should use process.env)\');\n' +
        '  });',
      exunit:
        EXUNIT_CONVENTIONS +
        'BEHAVIORAL: Check Application.get_env or config values for hardcoded strings.\n' +
        'Verify credentials are loaded from System.get_env, not hardcoded.',
      phpunit:
        PHPUNIT_CONVENTIONS +
        'BEHAVIORAL: Include the config file and inspect credential values.\n' +
        'Verify getenv() is not used and values are hardcoded literals.',
      junit:
        JUNIT_CONVENTIONS +
        'BEHAVIORAL: Load the config class and inspect credential fields.\n' +
        'Verify System.getenv() is not used for sensitive values.',
    },
  },
  'CWE-1336': {
    name: 'Server-Side Template Injection (SSTI)',
    assertionGoal:
      'Import the route handler or template rendering function, call with template injection ' +
      'payload {{7*7}}, and assert the response contains "49" (proving server-side evaluation).',
    attackPayload: '{{7*7}}',
    testStrategy:
      'PREFERRED (Tier 1 — Direct function call):\n' +
      '1. Import the function that renders templates with user input\n' +
      '2. Call with payload: {{7*7}}\n' +
      '3. Assert the output contains "49" (template was evaluated server-side)\n\n' +
      'ALTERNATIVE (Tier 2 — HTTP request):\n' +
      '1. Use test client to send request with {{7*7}} in parameter\n' +
      '2. Assert response body contains "49"\n\n' +
      'LAST RESORT (Tier 3 — Source analysis):\n' +
      '1. Read source and detect render_template_string() with user input',
    frameworkHints: {
      rspec:
        RSPEC_CONVENTIONS +
        'BEHAVIORAL: Use test client with SSTI payload.\n' +
        'Example:\n' +
        '  context \'when input contains template expression\' do\n' +
        '    it \'evaluates the template server-side\' do\n' +
        '      post \'/render\', params: { name: "{{7*7}}" }\n' +
        '      expect(response.body).to include(\'49\')\n' +
        '    end\n' +
        '  end',
      pytest:
        PYTEST_CONVENTIONS +
        'BEHAVIORAL: Use Flask/Django test client with SSTI payload.\n' +
        'Example:\n' +
        '  @pytest.fixture\n' +
        '  def client():\n' +
        '      app.config[\'TESTING\'] = True\n' +
        '      with app.test_client() as client:\n' +
        '          yield client\n\n' +
        '  def test_ssti(client):\n' +
        '      response = client.post(\'/vulnerable\', data={\'name\': \'{{7*7}}\'})\n' +
        '      assert b\'49\' in response.data',
      mocha:
        MOCHA_CONVENTIONS +
        'BEHAVIORAL: Use supertest to send SSTI payload.\n' +
        'Check for template evaluation in the response.',
      exunit:
        EXUNIT_CONVENTIONS +
        'BEHAVIORAL: Use Phoenix.ConnTest to send SSTI payload and check for evaluation.',
      phpunit:
        PHPUNIT_CONVENTIONS +
        'BEHAVIORAL: Use the framework test client to send Twig/Blade injection payload.',
      junit:
        JUNIT_CONVENTIONS +
        'BEHAVIORAL: Use MockMvc to send Freemarker/Velocity injection payload.',
    },
  },
};

/**
 * Returns all supported CWE IDs that have assertion templates.
 */
export const SUPPORTED_CWES: string[] = Object.keys(TEMPLATES);

/**
 * Returns the assertion template for the given CWE ID.
 *
 * @param cweId - The CWE identifier (e.g., "CWE-89")
 * @returns The assertion template, or undefined if not found
 */
export function getAssertionTemplate(cweId: string): AssertionTemplate | undefined {
  return TEMPLATES[cweId];
}

/**
 * Returns the assertion template with a specific framework hint highlighted.
 *
 * @param cweId - The CWE identifier (e.g., "CWE-89")
 * @param framework - The test framework name (e.g., "rspec", "pytest")
 * @returns The template with frameworkHint field, or undefined if CWE not found
 */
export function getAssertionTemplateForFramework(
  cweId: string,
  framework: string
): (AssertionTemplate & { frameworkHint: string }) | undefined {
  const template = getAssertionTemplate(cweId);
  if (!template) return undefined;

  const frameworkHint = template.frameworkHints[framework] || template.frameworkHints.mocha;

  return {
    ...template,
    frameworkHint,
  };
}
