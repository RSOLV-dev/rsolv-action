/**
 * Vulnerability Assertion Templates
 * RFC-103: RED Test Generation Quality Improvements
 *
 * These templates tell the LLM exactly what to assert when generating
 * RED tests for each vulnerability type.
 */

export interface AssertionTemplate {
  name: string;
  assertionGoal: string;
  attackPayload: string;
  testStrategy: string;
  frameworkHints: Record<string, string>;
}

const TEMPLATES: Record<string, AssertionTemplate> = {
  'CWE-89': {
    name: 'SQL Injection',
    assertionGoal:
      'Assert that user input appears UNESCAPED in the query string. The test must prove that attacker-controlled input flows directly into the SQL query without sanitization.',
    attackPayload: "' OR '1'='1",
    testStrategy:
      'Capture the generated SQL query and verify the attack payload appears literally. The test should intercept the query before execution and assert the payload is present unchanged.',
    frameworkHints: {
      rspec:
        'Use allow().to receive() to stub the database connection and capture the query. Example: allow(ActiveRecord::Base.connection).to receive(:execute).and_capture(&block)',
      pytest:
        'Use unittest.mock.patch to intercept the query execution. Patch the database cursor.execute() method and capture the query string argument.',
      mocha:
        'Use sinon.stub() to capture the query string. Stub the database driver\'s query method and assert on the first argument.',
      exunit:
        'Use Mox to mock the Ecto.Repo and capture the query. Define a mock for the repo module and verify the query contains the payload.',
      phpunit:
        'Use Mockery to mock PDO and capture the query string. Mock PDO::prepare() or PDO::query() and capture the SQL parameter.',
      junit:
        'Use Mockito to mock PreparedStatement and capture the query. Verify that the Connection.prepareStatement() receives a string containing the payload.',
    },
  },
  'CWE-79': {
    name: 'Cross-Site Scripting (XSS)',
    assertionGoal:
      'Assert that user input appears in the output WITHOUT proper HTML encoding or escaping. The test must prove that script content or HTML is rendered unsanitized.',
    attackPayload: "<script>alert('XSS')</script>",
    testStrategy:
      "Capture the rendered HTML output and verify the attack payload appears without being HTML-encoded. Look for literal '<script>' instead of '&lt;script&gt;'. For source code analysis, detect patterns where user input is rendered without escaping.",
    frameworkHints: {
      rspec:
        "Use render and capture the response body. Assert response.body.include?('<script>') and not response.body.include?('&lt;script&gt;').",
      pytest:
        "IMPORTANT: Use pytest test functions with assert statements. Example:\n" +
        "def test_xss_vulnerability():\n" +
        "    source = open(file_path).read()\n" +
        "    # Check for render_template_string with user input\n" +
        "    has_unsafe_render = re.search(r'render_template_string.*request\\.(args|form)', source)\n" +
        "    assert has_unsafe_render is None, 'XSS: User input rendered without escaping'",
      mocha:
        "IMPORTANT: Wrap tests in describe/it blocks. Example:\n" +
        "describe('XSS Vulnerability - RED Test', function() {\n" +
        "  it('should detect unescaped output', function() {\n" +
        "    const sourceCode = fs.readFileSync(filePath, 'utf8');\n" +
        "    const hasUnsafeRender = /innerHTML\\s*=|\\$\\(.*\\)\\.html\\(/.test(sourceCode);\n" +
        "    assert.strictEqual(hasUnsafeRender, false, 'XSS vulnerability found');\n" +
        "  });\n" +
        "});",
      exunit:
        'Use Phoenix.ConnTest and render the response. Assert the response body contains the literal script tag without encoding.',
      phpunit:
        'Capture the output buffer or response content. Use assertStringContainsString() to verify unescaped HTML.',
      junit:
        "Use MockMvc or test the response body. Verify the response contains literal '<script>' without HTML entity encoding.",
    },
  },
  'CWE-22': {
    name: 'Path Traversal',
    assertionGoal:
      'Assert that path traversal sequences (../) are NOT sanitized or blocked. The test must prove that an attacker can access files outside the intended directory.',
    attackPayload: '../../../etc/passwd',
    testStrategy:
      "Capture the file path used for file operations and verify path traversal sequences are preserved. The resolved path should escape the intended base directory.",
    frameworkHints: {
      rspec:
        "Use allow(File).to receive(:read).and_capture(&block) to capture the file path. Assert the path contains '../' or resolves outside the base directory.",
      pytest:
        "Use unittest.mock.patch('builtins.open') or patch the file operation. Capture the path argument and verify it contains traversal sequences.",
      mocha:
        "Use sinon.stub() on fs.readFile or similar. Capture the path argument and assert it contains '../' sequences.",
      exunit:
        'Use Mox to mock File operations. Capture the path and verify it contains traversal sequences or resolves outside the sandbox.',
      phpunit:
        'Mock file_get_contents() or fopen(). Capture the path and assert it contains directory traversal sequences.',
      junit:
        'Mock java.io.File or java.nio.file operations. Capture the path and verify it contains traversal sequences.',
    },
  },
  'CWE-78': {
    name: 'Command Injection',
    assertionGoal:
      'Assert that shell metacharacters are NOT sanitized or escaped. The test must prove that attacker input can inject additional commands into the shell.',
    attackPayload: '; cat /etc/passwd',
    testStrategy:
      'Capture the command string passed to shell execution and verify the attack payload appears as executable code, not as a literal argument.',
    frameworkHints: {
      rspec:
        'Use allow(Kernel).to receive(:system).and_capture(&block) or stub Open3. Capture the command and assert it contains the injection payload.',
      pytest:
        "Use unittest.mock.patch('subprocess.run') or patch os.system. Capture the command argument and verify it contains the injection.",
      mocha:
        'Use sinon.stub() on child_process.exec or execSync. Capture the command and assert it contains the semicolon and additional command.',
      exunit:
        'Use Mox to mock System.cmd or :os.cmd. Capture the command and verify the injection payload is present.',
      phpunit:
        'Mock exec(), shell_exec(), or system(). Capture the command string and assert it contains the injection payload.',
      junit:
        'Mock Runtime.exec() or ProcessBuilder. Capture the command array/string and verify it contains the injection.',
    },
  },
  'CWE-94': {
    name: 'Code Injection',
    assertionGoal:
      'Assert that user input is passed to dynamic code execution functions (eval, Function constructor, vm.runInContext) without sanitization. The test must detect the presence of these dangerous patterns in the source code.',
    attackPayload: "require('child_process').execSync('id').toString()",
    testStrategy:
      'Read the vulnerable source file and use regex or AST analysis to detect calls to eval(), new Function(), or similar dynamic code execution. Assert that user-controlled input flows into these functions.',
    frameworkHints: {
      mocha:
        "Read the source file with fs.readFileSync and use regex to detect eval() calls. Use the assertion library available in the project (should, chai, or assert). Example: assert.ok(/eval\\s*\\(/.test(sourceCode), 'Code uses eval')",
      jest:
        "Read the source file and use expect().toMatch() to detect eval patterns. Example: expect(sourceCode).toMatch(/eval\\s*\\(/)",
      rspec:
        "Parse the source file and check for eval() or instance_eval patterns. Use File.read and regex matching.",
      pytest:
        "Read the source file and use re.search() to detect eval() or exec() patterns. Assert the dangerous pattern is present.",
      exunit:
        'Read the source module and check for Code.eval_string or similar patterns. Use File.read! and Regex.match?',
      phpunit:
        "Parse the source file for eval(), create_function(), or preg_replace with /e modifier. Use file_get_contents and preg_match.",
      junit:
        'Read the source and detect ScriptEngine.eval(), Class.forName with newInstance, or similar reflection patterns.',
    },
  },
  'CWE-502': {
    name: 'Insecure Deserialization',
    assertionGoal:
      'Assert that untrusted data is deserialized without validation. The test must prove that malicious serialized data can be processed, potentially leading to code execution.',
    attackPayload: 'O:8:"stdClass":1:{s:4:"code";s:10:"system(\'id\');";}',
    testStrategy:
      'Provide a malicious serialized object and verify it is deserialized. Track if the deserialization occurs without type checking or allowlist validation.',
    frameworkHints: {
      rspec:
        'Use allow(Marshal).to receive(:load).and_call_original to track calls. Or verify YAML.load (unsafe) vs YAML.safe_load behavior.',
      pytest:
        "Use unittest.mock.patch('pickle.loads') to track deserialization. Verify unsafe deserialization methods are called with untrusted data.",
      mocha:
        'Track JSON.parse usage with reviver or detect use of eval() on parsed data. For node-serialize, verify unserialize() is called.',
      exunit:
        'Track :erlang.binary_to_term/1 usage with safe options. Verify [:safe] option is NOT passed when deserializing untrusted data.',
      phpunit:
        "Track unserialize() calls. Verify it's called without allowed_classes restriction on untrusted input.",
      junit:
        'Track ObjectInputStream usage. Verify readObject() is called on untrusted data without type filtering.',
    },
  },
  'CWE-1321': {
    name: 'Prototype Pollution',
    assertionGoal:
      'Assert that user-controlled keys can modify Object.prototype or __proto__. The test must prove that property assignment via user input can pollute the prototype chain of all objects.',
    attackPayload: '{"__proto__": {"isAdmin": true}}',
    testStrategy:
      'Read the vulnerable source file and detect patterns where user-controlled keys are assigned to objects without validation. Look for obj[key] = value patterns where key comes from user input, or JSON.parse/merge/extend operations on untrusted data without __proto__ filtering.',
    frameworkHints: {
      mocha:
        "Read the source file with fs.readFileSync and detect unsafe property assignment patterns. Example:\n" +
        "describe('Prototype Pollution - RED Test', function() {\n" +
        "  it('should detect unsafe object property assignment', function() {\n" +
        "    const source = fs.readFileSync(filePath, 'utf8');\n" +
        "    const hasUnsafeMerge = /\\w+\\[\\w+\\]\\s*=/.test(source);\n" +
        "    const hasProtoGuard = /__proto__|hasOwnProperty|Object\\.create\\(null\\)/.test(source);\n" +
        "    assert.ok(hasProtoGuard, 'No prototype pollution guard found');\n" +
        "  });\n" +
        "});",
      jest:
        "Read the source file and detect unsafe merge/extend patterns. Use expect().toMatch() for pattern detection.",
      rspec:
        'Ruby is not typically vulnerable to prototype pollution. Check for unsafe merge patterns in JS assets or API endpoints that pass user data to JS.',
      pytest:
        "Read the source file and detect patterns where user-controlled dict keys are merged without filtering __proto__ or constructor. Use re.search() to detect unsafe dict merge patterns.",
      exunit:
        'Elixir maps are not vulnerable to prototype pollution. Check for unsafe JS interop or API endpoints that pass unfiltered data to JavaScript.',
      phpunit:
        'PHP objects are not typically vulnerable to prototype pollution. Check for unsafe json_decode to object patterns or JS asset inspection.',
      junit:
        'Java objects are not typically vulnerable to prototype pollution. Check for unsafe JSON deserialization or JS interop patterns.',
    },
  },
  'CWE-798': {
    name: 'Hardcoded Credentials',
    assertionGoal:
      'Assert that credentials (passwords, API keys, tokens) are hardcoded in source code rather than loaded from environment variables or secure storage. The test MUST detect literal secret values in the source.',
    attackPayload: 'password123_or_any_literal_secret',
    testStrategy:
      'Read the source file and use regex to find hardcoded credential patterns (API keys, passwords, tokens as literal strings). Assert that these patterns exist (RED test proves vulnerability). The test should verify credentials are NOT loaded from environment variables.',
    frameworkHints: {
      rspec:
        'Parse the source file and assert it contains literal credential values. Use File.read and regex matching to detect hardcoded patterns.',
      pytest:
        'Read the source file and use regex to detect hardcoded credentials. Assert secrets are not loaded from os.environ.',
      mocha:
        "IMPORTANT: Wrap tests in describe/it blocks. Example structure:\n" +
        "describe('Hardcoded Credentials - RED Test', function() {\n" +
        "  it('should detect hardcoded API keys', function() {\n" +
        "    const sourceCode = fs.readFileSync(filePath, 'utf8');\n" +
        "    const hasHardcodedKey = /['\"]\\w{20,}['\"]/.test(sourceCode);\n" +
        "    assert.strictEqual(hasHardcodedKey, false, 'Hardcoded credential found');\n" +
        "  });\n" +
        "});",
      exunit:
        'Read the source module and check for hardcoded strings. Verify Application.get_env or System.get_env is NOT used for secrets.',
      phpunit:
        'Parse the source file for hardcoded credentials. Verify getenv() or $_ENV is not used to load secrets.',
      junit:
        'Parse source for hardcoded strings. Verify System.getenv() or properties files are not used for credential storage.',
    },
  },
  'CWE-1336': {
    name: 'Server-Side Template Injection (SSTI)',
    assertionGoal:
      'Assert that user input is passed directly to a template engine for rendering without sanitization. The test must prove that attacker-controlled template expressions can be evaluated on the server.',
    attackPayload: '{{7*7}}',
    testStrategy:
      'Read the vulnerable source file and detect patterns where user input flows into template rendering functions. Look for render_template_string(user_input), Jinja2 Template(user_input).render(), ERB.new(user_input).result, or similar template engine calls with unsanitized input.',
    frameworkHints: {
      rspec:
        'Parse the source file for ERB.new with user-controlled input. Use File.read and regex to detect template rendering with request parameters.',
      pytest:
        "IMPORTANT: Use pytest test functions with assert statements. Read the source file and detect render_template_string() calls with user input (request.args, request.form). Example:\n" +
        "def test_ssti_vulnerability():\n" +
        "    source = open(file_path).read()\n" +
        "    has_unsafe_render = re.search(r'render_template_string.*request\\.(args|form)', source)\n" +
        "    assert has_unsafe_render is None, 'SSTI: User input rendered as template'",
      mocha:
        "Read the source file and detect patterns where user input is passed to template engines. Check for ejs.render(userInput), Handlebars.compile(userInput), or nunjucks.renderString(userInput).",
      exunit:
        'Read the source and check for EEx.eval_string with user-controlled input. Use File.read! and Regex to detect unsafe template rendering.',
      phpunit:
        'Parse the source for Twig render with user input, or eval() used in template context. Use file_get_contents and preg_match.',
      junit:
        'Read source for Freemarker Template with user input, or Velocity.evaluate with untrusted data. Use file reading and pattern matching.',
    },
  },
};

/**
 * Returns all supported CWE IDs that have assertion templates.
 */
export const SUPPORTED_CWES: string[] = Object.keys(TEMPLATES);

/**
 * Returns the assertion template for the given CWE ID.
 *
 * @param cweId - The CWE identifier (e.g., "CWE-89")
 * @returns The assertion template, or undefined if not found
 */
export function getAssertionTemplate(cweId: string): AssertionTemplate | undefined {
  return TEMPLATES[cweId];
}

/**
 * Returns the assertion template with a specific framework hint highlighted.
 *
 * @param cweId - The CWE identifier (e.g., "CWE-89")
 * @param framework - The test framework name (e.g., "rspec", "pytest")
 * @returns The template with frameworkHint field, or undefined if CWE not found
 */
export function getAssertionTemplateForFramework(
  cweId: string,
  framework: string
): (AssertionTemplate & { frameworkHint: string }) | undefined {
  const template = getAssertionTemplate(cweId);
  if (!template) return undefined;

  const frameworkHint = template.frameworkHints[framework] || template.frameworkHints.mocha;

  return {
    ...template,
    frameworkHint,
  };
}
