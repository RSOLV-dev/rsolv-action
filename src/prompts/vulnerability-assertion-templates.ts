/**
 * Vulnerability Assertion Templates
 * RFC-103: RED Test Generation Quality Improvements
 *
 * These templates tell the LLM exactly what to assert when generating
 * RED tests for each vulnerability type.
 */

export interface AssertionTemplate {
  name: string;
  assertionGoal: string;
  attackPayload: string;
  testStrategy: string;
  frameworkHints: Record<string, string>;
}

const TEMPLATES: Record<string, AssertionTemplate> = {
  'CWE-89': {
    name: 'SQL Injection',
    assertionGoal:
      'Assert that user input appears UNESCAPED in the query string. The test must prove that attacker-controlled input flows directly into the SQL query without sanitization.',
    attackPayload: "' OR '1'='1",
    testStrategy:
      'Capture the generated SQL query and verify the attack payload appears literally. The test should intercept the query before execution and assert the payload is present unchanged.',
    frameworkHints: {
      rspec:
        'Use allow().to receive() to stub the database connection and capture the query. Example: allow(ActiveRecord::Base.connection).to receive(:execute).and_capture(&block)',
      pytest:
        'Use unittest.mock.patch to intercept the query execution. Patch the database cursor.execute() method and capture the query string argument.',
      mocha:
        'Use sinon.stub() to capture the query string. Stub the database driver\'s query method and assert on the first argument.',
      exunit:
        'Use Mox to mock the Ecto.Repo and capture the query. Define a mock for the repo module and verify the query contains the payload.',
      phpunit:
        'Use Mockery to mock PDO and capture the query string. Mock PDO::prepare() or PDO::query() and capture the SQL parameter.',
      junit:
        'Use Mockito to mock PreparedStatement and capture the query. Verify that the Connection.prepareStatement() receives a string containing the payload.',
    },
  },
  'CWE-79': {
    name: 'Cross-Site Scripting (XSS)',
    assertionGoal:
      'Assert that user input appears in the output WITHOUT proper HTML encoding or escaping. The test must prove that script content or HTML is rendered unsanitized.',
    attackPayload: "<script>alert('XSS')</script>",
    testStrategy:
      "Capture the rendered HTML output and verify the attack payload appears without being HTML-encoded. Look for literal '<script>' instead of '&lt;script&gt;'.",
    frameworkHints: {
      rspec:
        "Use render and capture the response body. Assert response.body.include?('<script>') and not response.body.include?('&lt;script&gt;').",
      pytest:
        "Use the test client to render the response. Assert '<script>' in response.data or response.text without HTML encoding.",
      mocha:
        'Use a DOM testing library (jsdom) or capture the innerHTML. Assert that the script tag appears literally in the output.',
      exunit:
        'Use Phoenix.ConnTest and render the response. Assert the response body contains the literal script tag without encoding.',
      phpunit:
        'Capture the output buffer or response content. Use assertStringContainsString() to verify unescaped HTML.',
      junit:
        "Use MockMvc or test the response body. Verify the response contains literal '<script>' without HTML entity encoding.",
    },
  },
  'CWE-22': {
    name: 'Path Traversal',
    assertionGoal:
      'Assert that path traversal sequences (../) are NOT sanitized or blocked. The test must prove that an attacker can access files outside the intended directory.',
    attackPayload: '../../../etc/passwd',
    testStrategy:
      "Capture the file path used for file operations and verify path traversal sequences are preserved. The resolved path should escape the intended base directory.",
    frameworkHints: {
      rspec:
        "Use allow(File).to receive(:read).and_capture(&block) to capture the file path. Assert the path contains '../' or resolves outside the base directory.",
      pytest:
        "Use unittest.mock.patch('builtins.open') or patch the file operation. Capture the path argument and verify it contains traversal sequences.",
      mocha:
        "Use sinon.stub() on fs.readFile or similar. Capture the path argument and assert it contains '../' sequences.",
      exunit:
        'Use Mox to mock File operations. Capture the path and verify it contains traversal sequences or resolves outside the sandbox.',
      phpunit:
        'Mock file_get_contents() or fopen(). Capture the path and assert it contains directory traversal sequences.',
      junit:
        'Mock java.io.File or java.nio.file operations. Capture the path and verify it contains traversal sequences.',
    },
  },
  'CWE-78': {
    name: 'Command Injection',
    assertionGoal:
      'Assert that shell metacharacters are NOT sanitized or escaped. The test must prove that attacker input can inject additional commands into the shell.',
    attackPayload: '; cat /etc/passwd',
    testStrategy:
      'Capture the command string passed to shell execution and verify the attack payload appears as executable code, not as a literal argument.',
    frameworkHints: {
      rspec:
        'Use allow(Kernel).to receive(:system).and_capture(&block) or stub Open3. Capture the command and assert it contains the injection payload.',
      pytest:
        "Use unittest.mock.patch('subprocess.run') or patch os.system. Capture the command argument and verify it contains the injection.",
      mocha:
        'Use sinon.stub() on child_process.exec or execSync. Capture the command and assert it contains the semicolon and additional command.',
      exunit:
        'Use Mox to mock System.cmd or :os.cmd. Capture the command and verify the injection payload is present.',
      phpunit:
        'Mock exec(), shell_exec(), or system(). Capture the command string and assert it contains the injection payload.',
      junit:
        'Mock Runtime.exec() or ProcessBuilder. Capture the command array/string and verify it contains the injection.',
    },
  },
  'CWE-94': {
    name: 'Code Injection',
    assertionGoal:
      'Assert that user input is passed to dynamic code execution functions (eval, Function constructor, vm.runInContext) without sanitization. The test must detect the presence of these dangerous patterns in the source code.',
    attackPayload: "require('child_process').execSync('id').toString()",
    testStrategy:
      'Read the vulnerable source file and use regex or AST analysis to detect calls to eval(), new Function(), or similar dynamic code execution. Assert that user-controlled input flows into these functions.',
    frameworkHints: {
      mocha:
        "Read the source file with fs.readFileSync and use regex to detect eval() calls. Use the assertion library available in the project (should, chai, or assert). Example: assert.ok(/eval\\s*\\(/.test(sourceCode), 'Code uses eval')",
      jest:
        "Read the source file and use expect().toMatch() to detect eval patterns. Example: expect(sourceCode).toMatch(/eval\\s*\\(/)",
      rspec:
        "Parse the source file and check for eval() or instance_eval patterns. Use File.read and regex matching.",
      pytest:
        "Read the source file and use re.search() to detect eval() or exec() patterns. Assert the dangerous pattern is present.",
      exunit:
        'Read the source module and check for Code.eval_string or similar patterns. Use File.read! and Regex.match?',
      phpunit:
        "Parse the source file for eval(), create_function(), or preg_replace with /e modifier. Use file_get_contents and preg_match.",
      junit:
        'Read the source and detect ScriptEngine.eval(), Class.forName with newInstance, or similar reflection patterns.',
    },
  },
  'CWE-502': {
    name: 'Insecure Deserialization',
    assertionGoal:
      'Assert that untrusted data is deserialized without validation. The test must prove that malicious serialized data can be processed, potentially leading to code execution.',
    attackPayload: 'O:8:"stdClass":1:{s:4:"code";s:10:"system(\'id\');";}',
    testStrategy:
      'Provide a malicious serialized object and verify it is deserialized. Track if the deserialization occurs without type checking or allowlist validation.',
    frameworkHints: {
      rspec:
        'Use allow(Marshal).to receive(:load).and_call_original to track calls. Or verify YAML.load (unsafe) vs YAML.safe_load behavior.',
      pytest:
        "Use unittest.mock.patch('pickle.loads') to track deserialization. Verify unsafe deserialization methods are called with untrusted data.",
      mocha:
        'Track JSON.parse usage with reviver or detect use of eval() on parsed data. For node-serialize, verify unserialize() is called.',
      exunit:
        'Track :erlang.binary_to_term/1 usage with safe options. Verify [:safe] option is NOT passed when deserializing untrusted data.',
      phpunit:
        "Track unserialize() calls. Verify it's called without allowed_classes restriction on untrusted input.",
      junit:
        'Track ObjectInputStream usage. Verify readObject() is called on untrusted data without type filtering.',
    },
  },
  'CWE-798': {
    name: 'Hardcoded Credentials',
    assertionGoal:
      'Assert that credentials (passwords, API keys, tokens) are hardcoded in source code rather than loaded from environment variables or secure storage.',
    attackPayload: 'password123_or_any_literal_secret',
    testStrategy:
      'Analyze the source code or configuration to verify secrets are literal strings, not environment variable references or secure vault lookups.',
    frameworkHints: {
      rspec:
        'Parse the source file and assert it contains literal credential values. Use File.read and regex matching to detect hardcoded patterns.',
      pytest:
        'Read the source file and use regex to detect hardcoded credentials. Assert secrets are not loaded from os.environ.',
      mocha:
        'Read the source file and parse for literal strings matching credential patterns. Verify process.env is not used for secrets.',
      exunit:
        'Read the source module and check for hardcoded strings. Verify Application.get_env or System.get_env is NOT used for secrets.',
      phpunit:
        'Parse the source file for hardcoded credentials. Verify getenv() or $_ENV is not used to load secrets.',
      junit:
        'Parse source for hardcoded strings. Verify System.getenv() or properties files are not used for credential storage.',
    },
  },
};

/**
 * Returns all supported CWE IDs that have assertion templates.
 */
export const SUPPORTED_CWES: string[] = Object.keys(TEMPLATES);

/**
 * Returns the assertion template for the given CWE ID.
 *
 * @param cweId - The CWE identifier (e.g., "CWE-89")
 * @returns The assertion template, or undefined if not found
 */
export function getAssertionTemplate(cweId: string): AssertionTemplate | undefined {
  return TEMPLATES[cweId];
}

/**
 * Returns the assertion template with a specific framework hint highlighted.
 *
 * @param cweId - The CWE identifier (e.g., "CWE-89")
 * @param framework - The test framework name (e.g., "rspec", "pytest")
 * @returns The template with frameworkHint field, or undefined if CWE not found
 */
export function getAssertionTemplateForFramework(
  cweId: string,
  framework: string
): (AssertionTemplate & { frameworkHint: string }) | undefined {
  const template = getAssertionTemplate(cweId);
  if (!template) return undefined;

  const frameworkHint = template.frameworkHints[framework] || template.frameworkHints.mocha;

  return {
    ...template,
    frameworkHint,
  };
}
