import { Vulnerability, VulnerabilityType } from './types.js';

export interface CveEntry {
  id: string;
  description: string;
  cvssScore: number;
  severity: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';
  cweIds: string[];
  publishedDate: string;
  lastModified: string;
  references: string[];
}

export interface CveCorrelation {
  vulnerability: Vulnerability;
  relatedCves: CveEntry[];
  maxCvssScore: number;
  averageCvssScore: number;
  riskLevel: 'low' | 'medium' | 'high' | 'critical';
}

export interface CveCorrelationResult {
  correlations: CveCorrelation[];
  totalCves: number;
  highSeverityCves: number;
  riskAssessment: {
    overallRisk: 'low' | 'medium' | 'high' | 'critical';
    criticalVulnerabilities: number;
    exposureScore: number;
  };
}

export interface EnhancedVulnerability extends Vulnerability {
  cveInfo?: {
    relatedCveCount: number;
    maxCvssScore: number;
    averageCvssScore: number;
    enhancedRisk: 'low' | 'medium' | 'high' | 'critical';
    topCves: CveEntry[];
  };
}

export interface CveDatabaseStats {
  totalCves: number;
  lastUpdated: string;
  coverageByYear: Record<string, number>;
  topCweCategories: Array<{ cweId: string; count: number }>;
}

export interface CveSearchOptions {
  keyword?: string;
  cweId?: string;
  severityMin?: number;
  severityMax?: number;
  yearFrom?: number;
  yearTo?: number;
  limit?: number;
}

export interface CveSearchResult {
  results: CveEntry[];
  total: number;
  query: CveSearchOptions;
}

export interface CveEnhancedReport {
  vulnerabilities: EnhancedVulnerability[];
  cveCorrelations: CveCorrelationResult;
  riskAssessment: {
    overallRisk: 'low' | 'medium' | 'high' | 'critical';
    criticalVulnerabilities: number;
    exposureScore: number;
    riskFactors: string[];
  };
  recommendations: string[];
  summary: {
    totalVulnerabilities: number;
    totalRelatedCves: number;
    averageRiskScore: number;
    highestCvssScore: number;
  };
}

/**
 * CVE Correlator that maps detected vulnerabilities to known CVE database entries
 * Uses a simulated CVE database for demonstration purposes
 */
export class CveCorrelator {
  private cveCache: Map<string, CveEntry[]> = new Map();
  private cveDatabase: CveEntry[];

  constructor() {
    this.cveDatabase = this.initializeCveDatabase();
  }

  async correlateWithCve(vulnerabilities: Vulnerability[]): Promise<CveCorrelationResult> {
    const correlations: CveCorrelation[] = [];
    let totalCves = 0;
    let highSeverityCves = 0;

    for (const vuln of vulnerabilities) {
      const relatedCves = await this.findCvesByCwe(vuln.cweId || '');
      const maxCvssScore = Math.max(...relatedCves.map(c => c.cvssScore), 0);
      const averageCvssScore = relatedCves.length > 0 
        ? relatedCves.reduce((sum, c) => sum + c.cvssScore, 0) / relatedCves.length 
        : 0;

      const correlation: CveCorrelation = {
        vulnerability: vuln,
        relatedCves,
        maxCvssScore,
        averageCvssScore,
        riskLevel: this.calculateRiskLevel(maxCvssScore, vuln.severity)
      };

      correlations.push(correlation);
      totalCves += relatedCves.length;
      highSeverityCves += relatedCves.filter(c => c.severity === 'HIGH' || c.severity === 'CRITICAL').length;
    }

    const riskAssessment = this.calculateOverallRisk(correlations);

    return {
      correlations,
      totalCves,
      highSeverityCves,
      riskAssessment
    };
  }

  async findCvesByCwe(cweId: string): Promise<CveEntry[]> {
    // Check cache first
    if (this.cveCache.has(cweId)) {
      return this.cveCache.get(cweId)!;
    }

    // Simulate API call delay
    await new Promise(resolve => setTimeout(resolve, 10));

    const relatedCves = this.cveDatabase.filter(cve => 
      cve.cweIds.includes(cweId)
    );

    // Cache the results
    this.cveCache.set(cweId, relatedCves);
    
    return relatedCves;
  }

  async enhanceWithCveRisk(vulnerabilities: Vulnerability[]): Promise<EnhancedVulnerability[]> {
    const enhanced: EnhancedVulnerability[] = [];

    for (const vuln of vulnerabilities) {
      const relatedCves = await this.findCvesByCwe(vuln.cweId || '');
      const maxCvssScore = Math.max(...relatedCves.map(c => c.cvssScore), 0);
      const averageCvssScore = relatedCves.length > 0 
        ? relatedCves.reduce((sum, c) => sum + c.cvssScore, 0) / relatedCves.length 
        : 0;

      const enhancedVuln: EnhancedVulnerability = {
        ...vuln,
        cveInfo: {
          relatedCveCount: relatedCves.length,
          maxCvssScore,
          averageCvssScore,
          enhancedRisk: this.calculateRiskLevel(maxCvssScore, vuln.severity),
          topCves: relatedCves
            .sort((a, b) => b.cvssScore - a.cvssScore)
            .slice(0, 5)
        }
      };

      enhanced.push(enhancedVuln);
    }

    return enhanced;
  }

  async getDatabaseStats(): Promise<CveDatabaseStats> {
    const coverageByYear: Record<string, number> = {};
    const cweCount: Record<string, number> = {};

    for (const cve of this.cveDatabase) {
      const year = cve.publishedDate.substring(0, 4);
      coverageByYear[year] = (coverageByYear[year] || 0) + 1;

      for (const cweId of cve.cweIds) {
        cweCount[cweId] = (cweCount[cweId] || 0) + 1;
      }
    }

    const topCweCategories = Object.entries(cweCount)
      .sort(([, a], [, b]) => b - a)
      .slice(0, 10)
      .map(([cweId, count]) => ({ cweId, count }));

    return {
      totalCves: this.cveDatabase.length,
      lastUpdated: new Date().toISOString(),
      coverageByYear,
      topCweCategories
    };
  }

  async searchCves(options: CveSearchOptions): Promise<CveSearchResult> {
    let results = [...this.cveDatabase];

    // Apply keyword filter
    if (options.keyword) {
      const keyword = options.keyword.toLowerCase();
      results = results.filter(cve => 
        cve.description.toLowerCase().includes(keyword)
      );
    }

    // Apply CWE filter
    if (options.cweId) {
      results = results.filter(cve => 
        cve.cweIds.includes(options.cweId!)
      );
    }

    // Apply severity filters
    if (options.severityMin !== undefined) {
      results = results.filter(cve => cve.cvssScore >= options.severityMin!);
    }

    if (options.severityMax !== undefined) {
      results = results.filter(cve => cve.cvssScore <= options.severityMax!);
    }

    // Apply year filters
    if (options.yearFrom !== undefined) {
      results = results.filter(cve => {
        const year = parseInt(cve.publishedDate.substring(0, 4));
        return year >= options.yearFrom!;
      });
    }

    if (options.yearTo !== undefined) {
      results = results.filter(cve => {
        const year = parseInt(cve.publishedDate.substring(0, 4));
        return year <= options.yearTo!;
      });
    }

    // Sort by CVSS score (highest first)
    results.sort((a, b) => b.cvssScore - a.cvssScore);

    const total = results.length;
    const limit = options.limit || 50;
    results = results.slice(0, limit);

    return {
      results,
      total,
      query: options
    };
  }

  async generateCveEnhancedReport(vulnerabilities: Vulnerability[]): Promise<CveEnhancedReport> {
    const enhancedVulns = await this.enhanceWithCveRisk(vulnerabilities);
    const cveCorrelations = await this.correlateWithCve(vulnerabilities);
    
    const totalRelatedCves = enhancedVulns.reduce((sum, v) => sum + (v.cveInfo?.relatedCveCount || 0), 0);
    const averageRiskScore = enhancedVulns.reduce((sum, v) => sum + (v.cveInfo?.averageCvssScore || 0), 0) / enhancedVulns.length;
    const highestCvssScore = Math.max(...enhancedVulns.map(v => v.cveInfo?.maxCvssScore || 0));

    const riskAssessment = {
      ...cveCorrelations.riskAssessment,
      riskFactors: this.identifyRiskFactors(enhancedVulns)
    };

    const recommendations = this.generateCveBasedRecommendations(enhancedVulns);

    return {
      vulnerabilities: enhancedVulns,
      cveCorrelations,
      riskAssessment,
      recommendations,
      summary: {
        totalVulnerabilities: vulnerabilities.length,
        totalRelatedCves,
        averageRiskScore,
        highestCvssScore
      }
    };
  }

  private initializeCveDatabase(): CveEntry[] {
    // Simulated CVE database with realistic entries
    return [
      {
        id: 'CVE-2021-44228',
        description: 'Apache Log4j2 JNDI features do not protect against attacker controlled LDAP and other JNDI related endpoints',
        cvssScore: 10.0,
        severity: 'CRITICAL',
        cweIds: ['CWE-502', 'CWE-400'],
        publishedDate: '2021-12-10',
        lastModified: '2021-12-14',
        references: ['https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-44228']
      },
      {
        id: 'CVE-2022-22965',
        description: 'Spring Framework RCE via Data Binding on JDK 9+',
        cvssScore: 9.8,
        severity: 'CRITICAL',
        cweIds: ['CWE-94'],
        publishedDate: '2022-03-31',
        lastModified: '2022-04-01',
        references: ['https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-22965']
      },
      {
        id: 'CVE-2021-34527',
        description: 'Windows Print Spooler Remote Code Execution Vulnerability',
        cvssScore: 8.8,
        severity: 'HIGH',
        cweIds: ['CWE-74'],
        publishedDate: '2021-07-01',
        lastModified: '2021-07-13',
        references: ['https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-34527']
      },
      // SQL Injection CVEs
      {
        id: 'CVE-2023-1001',
        description: 'SQL injection vulnerability in web application allowing unauthorized database access',
        cvssScore: 8.7,
        severity: 'HIGH',
        cweIds: ['CWE-89'],
        publishedDate: '2023-01-15',
        lastModified: '2023-01-16',
        references: ['https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-1001']
      },
      {
        id: 'CVE-2023-1002',
        description: 'Blind SQL injection in authentication mechanism',
        cvssScore: 7.5,
        severity: 'HIGH',
        cweIds: ['CWE-89'],
        publishedDate: '2023-02-10',
        lastModified: '2023-02-11',
        references: ['https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-1002']
      },
      {
        id: 'CVE-2023-1003',
        description: 'SQL injection via parameter manipulation in search functionality',
        cvssScore: 9.1,
        severity: 'CRITICAL',
        cweIds: ['CWE-89'],
        publishedDate: '2023-03-05',
        lastModified: '2023-03-06',
        references: ['https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-1003']
      },
      // XSS CVEs
      {
        id: 'CVE-2023-2001',
        description: 'Cross-site scripting vulnerability in user input handling',
        cvssScore: 6.1,
        severity: 'MEDIUM',
        cweIds: ['CWE-79'],
        publishedDate: '2023-01-20',
        lastModified: '2023-01-21',
        references: ['https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-2001']
      },
      {
        id: 'CVE-2023-2002',
        description: 'Stored XSS vulnerability in comment system',
        cvssScore: 7.2,
        severity: 'HIGH',
        cweIds: ['CWE-79'],
        publishedDate: '2023-02-15',
        lastModified: '2023-02-16',
        references: ['https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-2002']
      },
      {
        id: 'CVE-2023-2003',
        description: 'DOM-based XSS in JavaScript framework',
        cvssScore: 8.2,
        severity: 'HIGH',
        cweIds: ['CWE-79'],
        publishedDate: '2023-03-10',
        lastModified: '2023-03-11',
        references: ['https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-2003']
      }
    ];
  }

  private calculateRiskLevel(cvssScore: number, originalSeverity: string): 'low' | 'medium' | 'high' | 'critical' {
    // Combine CVSS score with original severity
    if (cvssScore >= 9.0 || originalSeverity === 'critical') return 'critical';
    if (cvssScore >= 7.0 || originalSeverity === 'high') return 'high';
    if (cvssScore >= 4.0 || originalSeverity === 'medium') return 'medium';
    return 'low';
  }

  private calculateOverallRisk(correlations: CveCorrelation[]): {
    overallRisk: 'low' | 'medium' | 'high' | 'critical';
    criticalVulnerabilities: number;
    exposureScore: number;
  } {
    const criticalVulnerabilities = correlations.filter(c => c.riskLevel === 'critical').length;
    const highVulnerabilities = correlations.filter(c => c.riskLevel === 'high').length;
    
    // Calculate exposure score based on vulnerability count and severity
    const exposureScore = correlations.reduce((score, c) => {
      const multiplier = c.riskLevel === 'critical' ? 4 : c.riskLevel === 'high' ? 3 : c.riskLevel === 'medium' ? 2 : 1;
      return score + (c.maxCvssScore * multiplier);
    }, 0);

    let overallRisk: 'low' | 'medium' | 'high' | 'critical' = 'low';
    if (criticalVulnerabilities > 0) overallRisk = 'critical';
    else if (highVulnerabilities >= 3) overallRisk = 'critical';
    else if (highVulnerabilities >= 1) overallRisk = 'high';
    else if (correlations.length > 0) overallRisk = 'medium';

    return {
      overallRisk,
      criticalVulnerabilities,
      exposureScore
    };
  }

  private identifyRiskFactors(vulnerabilities: EnhancedVulnerability[]): string[] {
    const factors: string[] = [];
    
    const highCvssVulns = vulnerabilities.filter(v => (v.cveInfo?.maxCvssScore || 0) >= 8.0);
    if (highCvssVulns.length > 0) {
      factors.push(`${highCvssVulns.length} vulnerabilities with CVSS score >= 8.0`);
    }

    const multipleCveVulns = vulnerabilities.filter(v => (v.cveInfo?.relatedCveCount || 0) >= 3);
    if (multipleCveVulns.length > 0) {
      factors.push(`${multipleCveVulns.length} vulnerabilities with multiple related CVEs`);
    }

    const sqlInjectionVulns = vulnerabilities.filter(v => v.type === VulnerabilityType.SQL_INJECTION);
    if (sqlInjectionVulns.length > 0) {
      factors.push(`${sqlInjectionVulns.length} SQL injection vulnerabilities detected`);
    }

    return factors;
  }

  private generateCveBasedRecommendations(vulnerabilities: EnhancedVulnerability[]): string[] {
    const recommendations: string[] = [];
    
    const sqlInjectionVulns = vulnerabilities.filter(v => v.type === VulnerabilityType.SQL_INJECTION);
    if (sqlInjectionVulns.length > 0) {
      recommendations.push('Implement parameterized queries to prevent SQL injection (based on CVE analysis)');
    }

    const xssVulns = vulnerabilities.filter(v => v.type === VulnerabilityType.XSS);
    if (xssVulns.length > 0) {
      recommendations.push('Apply output encoding and Content Security Policy to prevent XSS attacks');
    }

    const highCvssVulns = vulnerabilities.filter(v => (v.cveInfo?.maxCvssScore || 0) >= 8.0);
    if (highCvssVulns.length > 0) {
      recommendations.push('Prioritize fixing vulnerabilities with CVSS score >= 8.0 for immediate risk reduction');
    }

    return recommendations;
  }
}