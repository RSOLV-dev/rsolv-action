/**
 * Vulnerability Registry Client
 * RFC-104: Fetches per-CWE vulnerability type entries from the platform API.
 *
 * The platform serves a unified registry of assertion templates, few-shot
 * examples, educational content, and fix guidance per CWE ID.
 *
 * Falls back gracefully if the API is unavailable â€” the action retains
 * local templates as a fallback (see vulnerability-assertion-templates.ts).
 */

import { logger } from '../utils/logger.js';

/** Platform API response for test classification */
export interface TestClassificationResult {
  is_static: boolean;
  reason: string;
  static_acceptable?: boolean;
}

/** Platform API response for a single vulnerability type entry */
export interface VulnerabilityTypeEntry {
  cwe_id: string;
  name: string;
  description: string;
  coverage_status: string;
  pattern_types: string[];
  ecosystems: string[];
  related_cwes: string[];
  assertion_template: {
    name: string;
    assertion_goal: string;
    attack_payload: string;
    test_strategy: string;
    framework_hints: Record<string, string>;
  } | null;
  few_shot_examples: Record<string, string> | null;
  /** Present only when ?framework= query param is provided */
  few_shot_example?: string | null;
  /** Present only when ?framework= query param is provided */
  framework_hint?: string | null;
  educational_content: {
    title: string;
    description: string;
    prevention: string;
    example?: string;
  } | null;
  fix_guidance: Record<string, string> | null;
  /** Whether static source analysis is acceptable for this CWE (e.g., true for CWE-798) */
  static_acceptable?: boolean;
}

export class VulnerabilityRegistryClient {
  private readonly baseUrl: string;
  private readonly apiKey: string;
  private readonly cache: Map<string, VulnerabilityTypeEntry>;
  private static readonly TIMEOUT_MS = 10000; // 10 seconds

  constructor(
    apiKey: string,
    baseUrl: string = process.env.RSOLV_API_URL || 'https://api.rsolv.dev'
  ) {
    this.apiKey = apiKey;
    this.baseUrl = baseUrl;
    this.cache = new Map();
  }

  /**
   * Fetch a vulnerability type entry from the platform registry.
   * Returns null if the API is unavailable or the CWE is not found.
   *
   * @param cweId - CWE identifier (e.g., "CWE-89")
   * @param framework - Optional test framework for framework-specific fields
   */
  async getEntry(cweId: string, framework?: string): Promise<VulnerabilityTypeEntry | null> {
    // Check cache first (keyed by cweId + framework)
    const cacheKey = framework ? `${cweId}:${framework}` : cweId;
    const cached = this.cache.get(cacheKey);
    if (cached) {
      logger.debug(`[RFC-104] Using cached registry entry for ${cweId}`);
      return cached;
    }

    try {
      let url = `${this.baseUrl}/api/v1/vulnerability-types/${cweId}`;
      if (framework) {
        url += `?framework=${encodeURIComponent(framework)}`;
      }

      const controller = new AbortController();
      const timeoutId = setTimeout(
        () => controller.abort(),
        VulnerabilityRegistryClient.TIMEOUT_MS
      );

      const response = await fetch(url, {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
          'x-api-key': this.apiKey,
        },
        signal: controller.signal,
      });

      clearTimeout(timeoutId);

      if (!response.ok) {
        if (response.status === 404) {
          logger.debug(`[RFC-104] CWE ${cweId} not found in platform registry`);
          return null;
        }
        logger.warn(`[RFC-104] Platform registry API error: ${response.status}`);
        return null;
      }

      const entry = (await response.json()) as VulnerabilityTypeEntry;
      this.cache.set(cacheKey, entry);
      logger.info(`[RFC-104] Fetched registry entry for ${cweId} from platform`);
      return entry;
    } catch (error) {
      if (error instanceof Error && error.name === 'AbortError') {
        logger.warn(`[RFC-104] Platform registry API timed out for ${cweId}`);
      } else {
        logger.warn(`[RFC-104] Platform registry API unavailable: ${(error as Error).message}`);
      }
      return null;
    }
  }

  /**
   * Classify test code as static (source analysis) or behavioral (runtime) via platform API.
   * Returns null if the API is unavailable or errors.
   *
   * When cweId is provided, also returns whether a static test is acceptable for that CWE.
   *
   * @param testCode - Generated test source code to classify
   * @param cweId - Optional CWE identifier for CWE-aware classification
   */
  async classifyTest(testCode: string, cweId?: string): Promise<TestClassificationResult | null> {
    try {
      const url = `${this.baseUrl}/api/v1/test-classification`;

      const controller = new AbortController();
      const timeoutId = setTimeout(
        () => controller.abort(),
        VulnerabilityRegistryClient.TIMEOUT_MS
      );

      const body: Record<string, string> = { test_code: testCode };
      if (cweId) {
        body.cwe_id = cweId;
      }

      const response = await fetch(url, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'x-api-key': this.apiKey,
        },
        body: JSON.stringify(body),
        signal: controller.signal,
      });

      clearTimeout(timeoutId);

      if (!response.ok) {
        logger.warn(`[RFC-104] Test classification API error: ${response.status}`);
        return null;
      }

      const result = (await response.json()) as TestClassificationResult;
      logger.info(`[RFC-104] Test classified: is_static=${result.is_static}, reason=${result.reason}`);
      return result;
    } catch (error) {
      if (error instanceof Error && error.name === 'AbortError') {
        logger.warn('[RFC-104] Test classification API timed out');
      } else {
        logger.warn(`[RFC-104] Test classification API unavailable: ${(error as Error).message}`);
      }
      return null;
    }
  }

  /**
   * Extract the few-shot example for a specific framework from a registry entry.
   * Tries the entry's `few_shot_example` (framework-specific field from API),
   * then falls back to the `few_shot_examples` map.
   */
  static getFewShotExample(entry: VulnerabilityTypeEntry, framework: string): string | null {
    // If the API returned a framework-specific example, use it
    if (entry.few_shot_example) {
      return entry.few_shot_example;
    }
    // Fall back to the full map
    if (entry.few_shot_examples && entry.few_shot_examples[framework]) {
      return entry.few_shot_examples[framework];
    }
    return null;
  }
}
