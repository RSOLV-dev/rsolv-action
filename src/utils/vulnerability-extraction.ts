/**
 * Shared vulnerability extraction logic for all validation modes.
 *
 * This module provides a single source of truth for extracting vulnerability
 * information from GitHub issues, used by both the legacy validation-mode
 * and the newer three-phase RFC-060 system.
 */

import { logger } from './logger.js';
import type { IssueContext } from '../types/index.js';
import type { ScanPhaseData } from '../types/vulnerability.js';

/**
 * Represents a vulnerability found in the issue body
 */
export interface IssueBodyVulnerability {
  line: number;
  message: string;
}

/**
 * Maps a file to its vulnerabilities
 */
export interface FileVulnerabilityMapping {
  path: string;
  vulnerabilities: IssueBodyVulnerability[];
}

/**
 * Parsed structure from the issue body
 */
export interface ParsedIssueBody {
  type?: string;
  severity?: string;
  files: FileVulnerabilityMapping[];
}

/**
 * Standard vulnerability structure for validation phase data
 */
export interface ValidationVulnerability {
  file: string;
  line: number;
  type: string;
  description?: string;
  confidence?: number | string;
  enclosingFunction?: {
    name: string;
    startLine: number;
    endLine: number;
    params: string[];
  };
}

/**
 * Reverse mapping from human-readable vulnerability type names back to machine-readable keys.
 * This is the inverse of VULNERABILITY_TYPE_NAMES in scanner/issue-creator.ts.
 *
 * SCAN writes human-readable names like "Code Injection" to the issue body.
 * VALIDATE needs machine-readable names like "code_injection" for pipeline processing.
 */
const READABLE_TO_MACHINE: Record<string, string> = {
  'sql injection': 'sql_injection',
  'cross-site scripting (xss)': 'xss',
  'command injection': 'command_injection',
  'path traversal': 'path_traversal',
  'weak cryptography': 'weak_cryptography',
  'hardcoded secrets': 'hardcoded_secrets',
  'insecure random number generation': 'insecure-random',
  'open redirect': 'open_redirect',
  'xml external entity (xxe)': 'xxe',
  'server-side request forgery (ssrf)': 'ssrf',
  'nosql injection': 'nosql_injection',
  'ldap injection': 'ldap_injection',
  'xpath injection': 'xpath_injection',
  'weak hashing algorithm': 'weak-hash',
  'insecure deserialization': 'insecure_deserialization',
  'prototype pollution': 'prototype_pollution',
  'code injection': 'code_injection',
  'server-side template injection (ssti)': 'template_injection',
  'template injection': 'template_injection',
  'insecure jwt configuration': 'insecure_jwt',
  'debug mode enabled': 'debug_mode',
  'broken access control': 'broken_access_control',
  'broken authentication': 'broken_authentication',
  'security misconfiguration': 'security_misconfiguration',
  'sensitive data exposure': 'sensitive_data_exposure',
  'mass assignment': 'mass_assignment',
  'log injection': 'log_injection',
  'information disclosure': 'information_disclosure',
  'improper input validation': 'improper_input_validation',
  'cross-site request forgery (csrf)': 'csrf',
  'denial of service': 'denial_of_service',
};

/**
 * Normalize a vulnerability type from human-readable format to machine-readable snake_case.
 *
 * Handles:
 * - Human-readable: "Code Injection" → "code_injection"
 * - Parenthetical abbreviations: "Cross-Site Scripting (XSS)" → "xss"
 * - Already normalized: "code_injection" → "code_injection"
 * - Mixed case underscore: "Command_injection" → "command_injection"
 * - Unknown types: "Some Unknown Type" → "some_unknown_type"
 */
export function normalizeVulnerabilityType(type: string): string {
  if (!type) return 'unknown';

  // Check the reverse mapping first (case-insensitive)
  const lookup = READABLE_TO_MACHINE[type.toLowerCase()];
  if (lookup) return lookup;

  // Already in machine-readable format (contains underscores or hyphens, no spaces)
  if (/^[a-z0-9_-]+$/.test(type)) return type;

  // Mixed case with underscores (e.g., "Command_injection") — just lowercase
  if (type.includes('_')) return type.toLowerCase();

  // Fallback: lowercase and replace spaces with underscores
  return type.toLowerCase().replace(/\s+/g, '_').replace(/[()]/g, '');
}

/**
 * Parse issue body to extract file and vulnerability information.
 *
 * Parses markdown-formatted GitHub issue bodies to extract:
 * - Vulnerability type (e.g., Command_injection, XSS)
 * - Severity level (e.g., CRITICAL, high, medium)
 * - Affected files and line numbers
 *
 * @param issueBody The markdown content of the GitHub issue
 * @returns Parsed structure with type, severity, and file vulnerabilities
 *
 * @example
 * const parsed = parseIssueBody(`**Type**: XSS
 * **Severity**: high
 *
 * #### \`index.html\`
 *
 * - **Line 42**: Unescaped user input
 * `);
 * // Returns: { type: 'XSS', severity: 'high', files: [...] }
 */
export function parseIssueBody(issueBody: string): ParsedIssueBody {
  const result: ParsedIssueBody = {
    files: []
  };

  if (!issueBody || typeof issueBody !== 'string') {
    logger.warn('[VulnerabilityExtraction] Invalid issue body provided');
    return result;
  }

  // Extract type (e.g., **Type**: Code Injection or **Type**: Command_injection)
  // Use (.+) to capture multi-word human-readable types like "Code Injection"
  const typeMatch = issueBody.match(/\*\*Type\*\*:\s*(.+)/);
  if (typeMatch) {
    result.type = typeMatch[1].trim();
  }

  // Extract severity (e.g., **Severity**: CRITICAL)
  const severityMatch = issueBody.match(/\*\*Severity\*\*:\s*(\S+)/);
  if (severityMatch) {
    result.severity = severityMatch[1];
  }

  // Extract files and their vulnerabilities
  // Pattern: #### `filepath`
  const lines = issueBody.split('\n');

  let currentFile: FileVulnerabilityMapping | null = null;
  let inFileSection = false;

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];

    // Check for file header (e.g., #### `Gruntfile.js`)
    const fileMatch = line.match(/####\s*`([^`]+)`/);
    if (fileMatch) {
      // Save previous file if exists
      if (currentFile) {
        result.files.push(currentFile);
      }

      currentFile = {
        path: fileMatch[1],
        vulnerabilities: []
      };
      inFileSection = true;
      continue;
    }

    // Parse vulnerability lines (format: - **Line X**: message)
    if (inFileSection && currentFile && line.trim().startsWith('-')) {
      const vulnMatch = line.match(/-\s*\*\*Line\s+(\d+)\*\*:\s*(.+)/);
      if (vulnMatch) {
        currentFile.vulnerabilities.push({
          line: parseInt(vulnMatch[1], 10),
          message: vulnMatch[2].trim()
        });
      }
    }

    // Check if we've left the files section (new section header)
    if (line.startsWith('###') && !line.includes('Affected Files')) {
      inFileSection = false;
      if (currentFile) {
        result.files.push(currentFile);
        currentFile = null;
      }
    }
  }

  // Don't forget the last file
  if (currentFile) {
    result.files.push(currentFile);
  }

  logger.debug('[VulnerabilityExtraction] Parsed issue body:', {
    type: result.type,
    severity: result.severity,
    filesCount: result.files.length,
    files: result.files.map(f => ({
      path: f.path,
      vulnerabilitiesCount: f.vulnerabilities.length
    }))
  });

  return result;
}

/**
 * Extract vulnerabilities from a GitHub issue with fallback to scan data.
 *
 * This is the main entry point for vulnerability extraction. It:
 * 1. Attempts to parse the issue body for detailed vulnerability info
 * 2. Falls back to scan data if issue body doesn't contain vulnerabilities
 * 3. Returns a standardized array of ValidationVulnerability objects
 *
 * @param issue The GitHub issue context containing the issue body
 * @param scanData Optional scan phase data to use as fallback
 * @returns Array of standardized vulnerability objects
 *
 * @example
 * const vulnerabilities = extractVulnerabilitiesFromIssue(issue, scanData);
 * // Returns: [{ file: 'test.js', line: 42, type: 'XSS', description: '...', confidence: 'high' }]
 */
export function extractVulnerabilitiesFromIssue(
  issue: IssueContext,
  scanData?: ScanPhaseData
): ValidationVulnerability[] {
  const vulnerabilities: ValidationVulnerability[] = [];

  // Parse issue body to extract vulnerability information
  const parsedIssueBody = parseIssueBody(issue.body);

  // Normalize the type from human-readable (e.g., "Code Injection") to machine-readable ("code_injection")
  const normalizedType = parsedIssueBody.type
    ? normalizeVulnerabilityType(parsedIssueBody.type)
    : scanData?.analysisData?.vulnerabilityType || 'unknown';

  // Extract vulnerabilities from parsed issue body
  for (const fileMapping of parsedIssueBody.files) {
    for (const vuln of fileMapping.vulnerabilities) {
      vulnerabilities.push({
        file: fileMapping.path,
        line: vuln.line,
        type: normalizedType,
        description: vuln.message,
        confidence: parsedIssueBody.severity || scanData?.analysisData?.severity || 'medium'
      });
    }
  }

  // If no vulnerabilities found in issue body, create from scan data
  if (vulnerabilities.length === 0 && scanData?.analysisData?.filesToModify) {
    for (const file of scanData.analysisData.filesToModify) {
      vulnerabilities.push({
        file,
        line: 0, // Line number not available from scan data
        type: scanData.analysisData.vulnerabilityType || 'unknown',
        description: scanData.analysisData.reason || 'Vulnerability detected',
        confidence: scanData.analysisData.severity || 'medium'
      });
    }
  }

  logger.debug('[VulnerabilityExtraction] Extracted vulnerabilities from issue', {
    issueNumber: issue.number,
    vulnerabilitiesCount: vulnerabilities.length,
    files: vulnerabilities.map(v => v.file)
  });

  return vulnerabilities;
}
