/**
 * Shared vulnerability extraction logic for all validation modes.
 *
 * This module provides a single source of truth for extracting vulnerability
 * information from GitHub issues, used by both the legacy validation-mode
 * and the newer three-phase RFC-060 system.
 */

import { logger } from './logger.js';
import type { IssueContext } from '../types/index.js';
import type { ScanPhaseData } from '../types/vulnerability.js';

/**
 * Represents a vulnerability found in the issue body
 */
export interface IssueBodyVulnerability {
  line: number;
  message: string;
}

/**
 * Maps a file to its vulnerabilities
 */
export interface FileVulnerabilityMapping {
  path: string;
  vulnerabilities: IssueBodyVulnerability[];
}

/**
 * Parsed structure from the issue body
 */
export interface ParsedIssueBody {
  type?: string;
  severity?: string;
  files: FileVulnerabilityMapping[];
}

/**
 * Standard vulnerability structure for validation phase data
 */
export interface ValidationVulnerability {
  file: string;
  line: number;
  type: string;
  description?: string;
  confidence?: number | string;
  enclosingFunction?: {
    name: string;
    startLine: number;
    endLine: number;
    params: string[];
  };
}

/**
 * Parse issue body to extract file and vulnerability information.
 *
 * Parses markdown-formatted GitHub issue bodies to extract:
 * - Vulnerability type (e.g., Command_injection, XSS)
 * - Severity level (e.g., CRITICAL, high, medium)
 * - Affected files and line numbers
 *
 * @param issueBody The markdown content of the GitHub issue
 * @returns Parsed structure with type, severity, and file vulnerabilities
 *
 * @example
 * const parsed = parseIssueBody(`**Type**: XSS
 * **Severity**: high
 *
 * #### \`index.html\`
 *
 * - **Line 42**: Unescaped user input
 * `);
 * // Returns: { type: 'XSS', severity: 'high', files: [...] }
 */
export function parseIssueBody(issueBody: string): ParsedIssueBody {
  const result: ParsedIssueBody = {
    files: []
  };

  if (!issueBody || typeof issueBody !== 'string') {
    logger.warn('[VulnerabilityExtraction] Invalid issue body provided');
    return result;
  }

  // Extract type (e.g., **Type**: Command_injection)
  const typeMatch = issueBody.match(/\*\*Type\*\*:\s*(\S+)/);
  if (typeMatch) {
    result.type = typeMatch[1];
  }

  // Extract severity (e.g., **Severity**: CRITICAL)
  const severityMatch = issueBody.match(/\*\*Severity\*\*:\s*(\S+)/);
  if (severityMatch) {
    result.severity = severityMatch[1];
  }

  // Extract files and their vulnerabilities
  // Pattern: #### `filepath`
  const lines = issueBody.split('\n');

  let currentFile: FileVulnerabilityMapping | null = null;
  let inFileSection = false;

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];

    // Check for file header (e.g., #### `Gruntfile.js`)
    const fileMatch = line.match(/####\s*`([^`]+)`/);
    if (fileMatch) {
      // Save previous file if exists
      if (currentFile) {
        result.files.push(currentFile);
      }

      currentFile = {
        path: fileMatch[1],
        vulnerabilities: []
      };
      inFileSection = true;
      continue;
    }

    // Parse vulnerability lines (format: - **Line X**: message)
    if (inFileSection && currentFile && line.trim().startsWith('-')) {
      const vulnMatch = line.match(/-\s*\*\*Line\s+(\d+)\*\*:\s*(.+)/);
      if (vulnMatch) {
        currentFile.vulnerabilities.push({
          line: parseInt(vulnMatch[1], 10),
          message: vulnMatch[2].trim()
        });
      }
    }

    // Check if we've left the files section (new section header)
    if (line.startsWith('###') && !line.includes('Affected Files')) {
      inFileSection = false;
      if (currentFile) {
        result.files.push(currentFile);
        currentFile = null;
      }
    }
  }

  // Don't forget the last file
  if (currentFile) {
    result.files.push(currentFile);
  }

  logger.debug('[VulnerabilityExtraction] Parsed issue body:', {
    type: result.type,
    severity: result.severity,
    filesCount: result.files.length,
    files: result.files.map(f => ({
      path: f.path,
      vulnerabilitiesCount: f.vulnerabilities.length
    }))
  });

  return result;
}

/**
 * Extract vulnerabilities from a GitHub issue with fallback to scan data.
 *
 * This is the main entry point for vulnerability extraction. It:
 * 1. Attempts to parse the issue body for detailed vulnerability info
 * 2. Falls back to scan data if issue body doesn't contain vulnerabilities
 * 3. Returns a standardized array of ValidationVulnerability objects
 *
 * @param issue The GitHub issue context containing the issue body
 * @param scanData Optional scan phase data to use as fallback
 * @returns Array of standardized vulnerability objects
 *
 * @example
 * const vulnerabilities = extractVulnerabilitiesFromIssue(issue, scanData);
 * // Returns: [{ file: 'test.js', line: 42, type: 'XSS', description: '...', confidence: 'high' }]
 */
export function extractVulnerabilitiesFromIssue(
  issue: IssueContext,
  scanData?: ScanPhaseData
): ValidationVulnerability[] {
  const vulnerabilities: ValidationVulnerability[] = [];

  // Parse issue body to extract vulnerability information
  const parsedIssueBody = parseIssueBody(issue.body);

  // Extract vulnerabilities from parsed issue body
  for (const fileMapping of parsedIssueBody.files) {
    for (const vuln of fileMapping.vulnerabilities) {
      vulnerabilities.push({
        file: fileMapping.path,
        line: vuln.line,
        type: parsedIssueBody.type || scanData?.analysisData?.vulnerabilityType || 'unknown',
        description: vuln.message,
        confidence: parsedIssueBody.severity || scanData?.analysisData?.severity || 'medium'
      });
    }
  }

  // If no vulnerabilities found in issue body, create from scan data
  if (vulnerabilities.length === 0 && scanData?.analysisData?.filesToModify) {
    for (const file of scanData.analysisData.filesToModify) {
      vulnerabilities.push({
        file,
        line: 0, // Line number not available from scan data
        type: scanData.analysisData.vulnerabilityType || 'unknown',
        description: scanData.analysisData.reason || 'Vulnerability detected',
        confidence: scanData.analysisData.severity || 'medium'
      });
    }
  }

  logger.debug('[VulnerabilityExtraction] Extracted vulnerabilities from issue', {
    issueNumber: issue.number,
    vulnerabilitiesCount: vulnerabilities.length,
    files: vulnerabilities.map(v => v.file)
  });

  return vulnerabilities;
}
