/**
 * Tests for VulnerabilityRegistryClient
 * RFC-104: Platform-first test classification via API
 */

import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { VulnerabilityRegistryClient, TestClassificationResult } from '../../external/vulnerability-registry-client.js';

describe('VulnerabilityRegistryClient', () => {
  let client: VulnerabilityRegistryClient;
  const mockFetch = vi.fn();

  beforeEach(() => {
    vi.stubGlobal('fetch', mockFetch);
    mockFetch.mockReset();
    client = new VulnerabilityRegistryClient('test-api-key', 'https://api.test.rsolv.dev');
  });

  afterEach(() => {
    vi.unstubAllGlobals();
  });

  describe('classifyTest()', () => {
    it('classifies static JavaScript test via platform API', async () => {
      const staticCode = `
        const fs = require('fs');
        const source = fs.readFileSync('app/handler.js', 'utf8');
        assert(source.includes('eval('));
      `;

      mockFetch.mockResolvedValueOnce({
        ok: true,
        json: async () => ({
          is_static: true,
          reason: 'Uses fs.readFileSync with string pattern matching â€” static source analysis',
        }),
      });

      const result = await client.classifyTest(staticCode);

      expect(result).not.toBeNull();
      expect(result!.is_static).toBe(true);
      expect(result!.reason).toContain('readFileSync');
      // Verify API call
      expect(mockFetch).toHaveBeenCalledTimes(1);
      const [url, options] = mockFetch.mock.calls[0];
      expect(url).toBe('https://api.test.rsolv.dev/api/v1/test-classification');
      expect(options.method).toBe('POST');
      expect(options.headers['x-api-key']).toBe('test-api-key');
      const body = JSON.parse(options.body);
      expect(body.test_code).toBe(staticCode);
      expect(body.cwe_id).toBeUndefined();
    });

    it('classifies behavioral test as not static', async () => {
      const behavioralCode = `
        const sinon = require('sinon');
        const dbStub = sinon.stub(db, 'query');
        searchUsers({ query: "' OR '1'='1" });
        expect(dbStub.firstCall.args[0]).to.include("' OR '1'='1");
      `;

      mockFetch.mockResolvedValueOnce({
        ok: true,
        json: async () => ({
          is_static: false,
          reason: 'Test appears to be behavioral',
        }),
      });

      const result = await client.classifyTest(behavioralCode);

      expect(result).not.toBeNull();
      expect(result!.is_static).toBe(false);
      expect(result!.reason).toContain('behavioral');
    });

    it('passes cweId when provided for CWE-aware classification', async () => {
      const code = `
        const fs = require('fs');
        const source = fs.readFileSync('config.js', 'utf8');
        expect(source).toMatch(/apiKey.*=.*['"][^'"]+['"]/);
      `;

      mockFetch.mockResolvedValueOnce({
        ok: true,
        json: async () => ({
          is_static: true,
          reason: 'Static source analysis',
          static_acceptable: true,
        }),
      });

      const result = await client.classifyTest(code, 'CWE-798');

      expect(result).not.toBeNull();
      expect(result!.is_static).toBe(true);
      expect(result!.static_acceptable).toBe(true);

      // Verify CWE ID was sent in request body
      const body = JSON.parse(mockFetch.mock.calls[0][1].body);
      expect(body.cwe_id).toBe('CWE-798');
    });

    it('returns static_acceptable=false for CWE-89 static tests', async () => {
      mockFetch.mockResolvedValueOnce({
        ok: true,
        json: async () => ({
          is_static: true,
          reason: 'Static source analysis',
          static_acceptable: false,
        }),
      });

      const result = await client.classifyTest('some static test code', 'CWE-89');

      expect(result).not.toBeNull();
      expect(result!.is_static).toBe(true);
      expect(result!.static_acceptable).toBe(false);
    });

    it('returns null when platform API is unavailable', async () => {
      mockFetch.mockRejectedValueOnce(new Error('ECONNREFUSED'));

      const result = await client.classifyTest('some test code');

      expect(result).toBeNull();
    });

    it('returns null on non-OK HTTP response', async () => {
      mockFetch.mockResolvedValueOnce({
        ok: false,
        status: 500,
      });

      const result = await client.classifyTest('some test code');

      expect(result).toBeNull();
    });

    it('returns null on timeout', async () => {
      mockFetch.mockImplementationOnce(() => {
        const error = new Error('The operation was aborted');
        error.name = 'AbortError';
        return Promise.reject(error);
      });

      const result = await client.classifyTest('some test code');

      expect(result).toBeNull();
    });
  });

  describe('getEntry()', () => {
    it('includes static_acceptable in returned entry', async () => {
      mockFetch.mockResolvedValueOnce({
        ok: true,
        json: async () => ({
          cwe_id: 'CWE-798',
          name: 'Hardcoded Credentials',
          description: 'Hardcoded credentials',
          coverage_status: 'partial',
          pattern_types: ['hardcoded_secrets'],
          ecosystems: ['javascript'],
          related_cwes: [],
          assertion_template: null,
          few_shot_examples: null,
          educational_content: null,
          fix_guidance: null,
          static_acceptable: true,
        }),
      });

      const entry = await client.getEntry('CWE-798');

      expect(entry).not.toBeNull();
      expect(entry!.static_acceptable).toBe(true);
    });
  });
});
