import { describe, it, expect } from 'vitest';
import { extractVulnerabilitiesFromIssue, parseIssueBody, normalizeVulnerabilityType } from '../vulnerability-extraction.js';
import type { IssueContext } from '../../types/index.js';

describe('parseIssueBody', () => {
  it('should extract type and severity from issue body', () => {
    const issueBody = `## Security Vulnerability Report

**Type**: Command_injection
**Severity**: CRITICAL
**Total Instances**: 38
**Affected Files**: 7`;

    const result = parseIssueBody(issueBody);

    expect(result.type).toBe('Command_injection');
    expect(result.severity).toBe('CRITICAL');
  });

  it('should extract file paths and line numbers', () => {
    const issueBody = `### Affected Files

#### \`Gruntfile.js\`

- **Line 15**: Use of eval() function
- **Line 97**: Use of eval() function

#### \`app/routes/contributions.js\`

- **Line 31**: Use of eval() function`;

    const result = parseIssueBody(issueBody);

    expect(result.files).toHaveLength(2);
    expect(result.files[0].path).toBe('Gruntfile.js');
    expect(result.files[0].vulnerabilities).toHaveLength(2);
    expect(result.files[0].vulnerabilities[0]).toEqual({
      line: 15,
      message: 'Use of eval() function'
    });
    expect(result.files[1].path).toBe('app/routes/contributions.js');
    expect(result.files[1].vulnerabilities[0].line).toBe(31);
  });

  it('should return empty files array for invalid issue body', () => {
    const result = parseIssueBody('Not a valid issue body');

    expect(result.files).toEqual([]);
  });

  it('should handle null or undefined issue body', () => {
    expect(parseIssueBody(null as any).files).toEqual([]);
    expect(parseIssueBody(undefined as any).files).toEqual([]);
  });

  it('should extract multi-word type from issue body (e.g., Code Injection)', () => {
    const issueBody = `## Security Vulnerability Report

**Type**: Code Injection
**Severity**: CRITICAL
**Total Instances**: 8
**Affected Files**: 7`;

    const result = parseIssueBody(issueBody);

    // Should capture full "Code Injection", not just "Code"
    expect(result.type).toBe('Code Injection');
    expect(result.severity).toBe('CRITICAL');
  });

  it('should extract types with parentheses (e.g., Cross-Site Scripting (XSS))', () => {
    const issueBody = `**Type**: Cross-Site Scripting (XSS)
**Severity**: high`;

    const result = parseIssueBody(issueBody);

    expect(result.type).toBe('Cross-Site Scripting (XSS)');
  });

  it('should still work with single-word types like XSS', () => {
    const issueBody = `**Type**: XSS
**Severity**: medium`;

    const result = parseIssueBody(issueBody);

    expect(result.type).toBe('XSS');
  });

  it('should still work with underscore types like Command_injection', () => {
    const issueBody = `**Type**: Command_injection
**Severity**: CRITICAL`;

    const result = parseIssueBody(issueBody);

    expect(result.type).toBe('Command_injection');
  });
});

describe('normalizeVulnerabilityType', () => {
  it('should normalize "Code Injection" to "code_injection"', () => {
    expect(normalizeVulnerabilityType('Code Injection')).toBe('code_injection');
  });

  it('should normalize "Cross-Site Scripting (XSS)" to "xss"', () => {
    expect(normalizeVulnerabilityType('Cross-Site Scripting (XSS)')).toBe('xss');
  });

  it('should normalize "SQL Injection" to "sql_injection"', () => {
    expect(normalizeVulnerabilityType('SQL Injection')).toBe('sql_injection');
  });

  it('should normalize "Command Injection" to "command_injection"', () => {
    expect(normalizeVulnerabilityType('Command Injection')).toBe('command_injection');
  });

  it('should normalize "Hardcoded Secrets" to "hardcoded_secrets"', () => {
    expect(normalizeVulnerabilityType('Hardcoded Secrets')).toBe('hardcoded_secrets');
  });

  it('should normalize "NoSQL Injection" to "nosql_injection"', () => {
    expect(normalizeVulnerabilityType('NoSQL Injection')).toBe('nosql_injection');
  });

  it('should normalize "Path Traversal" to "path_traversal"', () => {
    expect(normalizeVulnerabilityType('Path Traversal')).toBe('path_traversal');
  });

  it('should normalize "Server-Side Request Forgery (SSRF)" to "ssrf"', () => {
    expect(normalizeVulnerabilityType('Server-Side Request Forgery (SSRF)')).toBe('ssrf');
  });

  it('should normalize "XML External Entity (XXE)" to "xxe"', () => {
    expect(normalizeVulnerabilityType('XML External Entity (XXE)')).toBe('xxe');
  });

  it('should pass through already-normalized types unchanged', () => {
    expect(normalizeVulnerabilityType('code_injection')).toBe('code_injection');
    expect(normalizeVulnerabilityType('xss')).toBe('xss');
    expect(normalizeVulnerabilityType('sql_injection')).toBe('sql_injection');
  });

  it('should handle underscore-style types (Command_injection)', () => {
    expect(normalizeVulnerabilityType('Command_injection')).toBe('command_injection');
  });

  it('should handle unknown types by lowercasing and replacing spaces with underscores', () => {
    expect(normalizeVulnerabilityType('Some Unknown Type')).toBe('some_unknown_type');
  });
});

describe('extractVulnerabilitiesFromIssue', () => {
  const createMockIssue = (body: string): IssueContext => ({
    id: '1',
    number: 1091,
    title: 'Test Issue',
    body,
    labels: [],
    assignees: [],
    repository: {
      owner: 'test-owner',
      name: 'test-repo',
      fullName: 'test-owner/test-repo',
      defaultBranch: 'main'
    },
    source: 'github'
  });

  it('should extract vulnerabilities from issue body with type and severity', () => {
    const issue = createMockIssue(`## Security Vulnerability Report

**Type**: Command_injection
**Severity**: CRITICAL

### Affected Files

#### \`Gruntfile.js\`

- **Line 15**: Use of eval() function
- **Line 97**: Use of eval() function`);

    const vulnerabilities = extractVulnerabilitiesFromIssue(issue);

    expect(vulnerabilities).toHaveLength(2);
    expect(vulnerabilities[0]).toEqual({
      file: 'Gruntfile.js',
      line: 15,
      type: 'command_injection',
      description: 'Use of eval() function',
      confidence: 'CRITICAL'
    });
    expect(vulnerabilities[1]).toEqual({
      file: 'Gruntfile.js',
      line: 97,
      type: 'command_injection',
      description: 'Use of eval() function',
      confidence: 'CRITICAL'
    });
  });

  it('should fall back to scanData when issue body has no vulnerabilities', () => {
    const issue = createMockIssue('Simple issue without vulnerability data');
    const scanData = {
      analysisData: {
        canBeFixed: true,
        vulnerabilityType: 'SQL_Injection',
        severity: 'high',
        filesToModify: ['database.js', 'api.js'],
        reason: 'SQL injection detected'
      }
    };

    const vulnerabilities = extractVulnerabilitiesFromIssue(issue, scanData);

    expect(vulnerabilities).toHaveLength(2);
    expect(vulnerabilities[0]).toEqual({
      file: 'database.js',
      line: 0,
      type: 'SQL_Injection',
      description: 'SQL injection detected',
      confidence: 'high'
    });
    expect(vulnerabilities[1]).toEqual({
      file: 'api.js',
      line: 0,
      type: 'SQL_Injection',
      description: 'SQL injection detected',
      confidence: 'high'
    });
  });

  it('should use issue body data over scanData when both are available', () => {
    const issue = createMockIssue(`**Type**: XSS
**Severity**: medium

#### \`index.html\`

- **Line 42**: Unescaped user input`);

    const scanData = {
      analysisData: {
        canBeFixed: true,
        vulnerabilityType: 'SQL_Injection',
        severity: 'low',
        filesToModify: ['other.js']
      }
    };

    const vulnerabilities = extractVulnerabilitiesFromIssue(issue, scanData);

    // Should use issue body data, not scanData
    expect(vulnerabilities).toHaveLength(1);
    expect(vulnerabilities[0].type).toBe('xss');
    expect(vulnerabilities[0].file).toBe('index.html');
    expect(vulnerabilities[0].line).toBe(42);
  });

  it('should return empty array when neither issue body nor scanData has vulnerability info', () => {
    const issue = createMockIssue('Empty issue');

    const vulnerabilities = extractVulnerabilitiesFromIssue(issue);

    expect(vulnerabilities).toEqual([]);
  });

  it('should handle missing scanData gracefully', () => {
    const issue = createMockIssue('**Type**: XSS\n\n#### `test.js`\n\n- **Line 1**: Test');

    const vulnerabilities = extractVulnerabilitiesFromIssue(issue, undefined);

    expect(vulnerabilities).toHaveLength(1);
    expect(vulnerabilities[0].type).toBe('xss');
  });

  it('should use default values for missing type and severity', () => {
    const issue = createMockIssue(`#### \`test.js\`

- **Line 10**: Some issue`);

    const vulnerabilities = extractVulnerabilitiesFromIssue(issue);

    expect(vulnerabilities[0].type).toBe('unknown');
    expect(vulnerabilities[0].confidence).toBe('medium');
  });
});
