import { describe, it, expect } from 'vitest';
import { extractVulnerabilitiesFromIssue, parseIssueBody } from '../vulnerability-extraction.js';
import type { IssueContext } from '../../types/index.js';

describe('parseIssueBody', () => {
  it('should extract type and severity from issue body', () => {
    const issueBody = `## Security Vulnerability Report

**Type**: Command_injection
**Severity**: CRITICAL
**Total Instances**: 38
**Affected Files**: 7`;

    const result = parseIssueBody(issueBody);

    expect(result.type).toBe('Command_injection');
    expect(result.severity).toBe('CRITICAL');
  });

  it('should extract file paths and line numbers', () => {
    const issueBody = `### Affected Files

#### \`Gruntfile.js\`

- **Line 15**: Use of eval() function
- **Line 97**: Use of eval() function

#### \`app/routes/contributions.js\`

- **Line 31**: Use of eval() function`;

    const result = parseIssueBody(issueBody);

    expect(result.files).toHaveLength(2);
    expect(result.files[0].path).toBe('Gruntfile.js');
    expect(result.files[0].vulnerabilities).toHaveLength(2);
    expect(result.files[0].vulnerabilities[0]).toEqual({
      line: 15,
      message: 'Use of eval() function'
    });
    expect(result.files[1].path).toBe('app/routes/contributions.js');
    expect(result.files[1].vulnerabilities[0].line).toBe(31);
  });

  it('should return empty files array for invalid issue body', () => {
    const result = parseIssueBody('Not a valid issue body');

    expect(result.files).toEqual([]);
  });

  it('should handle null or undefined issue body', () => {
    expect(parseIssueBody(null as any).files).toEqual([]);
    expect(parseIssueBody(undefined as any).files).toEqual([]);
  });
});

describe('extractVulnerabilitiesFromIssue', () => {
  const createMockIssue = (body: string): IssueContext => ({
    id: '1',
    number: 1091,
    title: 'Test Issue',
    body,
    labels: [],
    assignees: [],
    repository: {
      owner: 'test-owner',
      name: 'test-repo',
      fullName: 'test-owner/test-repo',
      defaultBranch: 'main'
    },
    source: 'github'
  });

  it('should extract vulnerabilities from issue body with type and severity', () => {
    const issue = createMockIssue(`## Security Vulnerability Report

**Type**: Command_injection
**Severity**: CRITICAL

### Affected Files

#### \`Gruntfile.js\`

- **Line 15**: Use of eval() function
- **Line 97**: Use of eval() function`);

    const vulnerabilities = extractVulnerabilitiesFromIssue(issue);

    expect(vulnerabilities).toHaveLength(2);
    expect(vulnerabilities[0]).toEqual({
      file: 'Gruntfile.js',
      line: 15,
      type: 'Command_injection',
      description: 'Use of eval() function',
      confidence: 'CRITICAL'
    });
    expect(vulnerabilities[1]).toEqual({
      file: 'Gruntfile.js',
      line: 97,
      type: 'Command_injection',
      description: 'Use of eval() function',
      confidence: 'CRITICAL'
    });
  });

  it('should fall back to scanData when issue body has no vulnerabilities', () => {
    const issue = createMockIssue('Simple issue without vulnerability data');
    const scanData = {
      analysisData: {
        canBeFixed: true,
        vulnerabilityType: 'SQL_Injection',
        severity: 'high',
        filesToModify: ['database.js', 'api.js'],
        reason: 'SQL injection detected'
      }
    };

    const vulnerabilities = extractVulnerabilitiesFromIssue(issue, scanData);

    expect(vulnerabilities).toHaveLength(2);
    expect(vulnerabilities[0]).toEqual({
      file: 'database.js',
      line: 0,
      type: 'SQL_Injection',
      description: 'SQL injection detected',
      confidence: 'high'
    });
    expect(vulnerabilities[1]).toEqual({
      file: 'api.js',
      line: 0,
      type: 'SQL_Injection',
      description: 'SQL injection detected',
      confidence: 'high'
    });
  });

  it('should use issue body data over scanData when both are available', () => {
    const issue = createMockIssue(`**Type**: XSS
**Severity**: medium

#### \`index.html\`

- **Line 42**: Unescaped user input`);

    const scanData = {
      analysisData: {
        canBeFixed: true,
        vulnerabilityType: 'SQL_Injection',
        severity: 'low',
        filesToModify: ['other.js']
      }
    };

    const vulnerabilities = extractVulnerabilitiesFromIssue(issue, scanData);

    // Should use issue body data, not scanData
    expect(vulnerabilities).toHaveLength(1);
    expect(vulnerabilities[0].type).toBe('XSS');
    expect(vulnerabilities[0].file).toBe('index.html');
    expect(vulnerabilities[0].line).toBe(42);
  });

  it('should return empty array when neither issue body nor scanData has vulnerability info', () => {
    const issue = createMockIssue('Empty issue');

    const vulnerabilities = extractVulnerabilitiesFromIssue(issue);

    expect(vulnerabilities).toEqual([]);
  });

  it('should handle missing scanData gracefully', () => {
    const issue = createMockIssue('**Type**: XSS\n\n#### `test.js`\n\n- **Line 1**: Test');

    const vulnerabilities = extractVulnerabilitiesFromIssue(issue, undefined);

    expect(vulnerabilities).toHaveLength(1);
    expect(vulnerabilities[0].type).toBe('XSS');
  });

  it('should use default values for missing type and severity', () => {
    const issue = createMockIssue(`#### \`test.js\`

- **Line 10**: Some issue`);

    const vulnerabilities = extractVulnerabilitiesFromIssue(issue);

    expect(vulnerabilities[0].type).toBe('unknown');
    expect(vulnerabilities[0].confidence).toBe('medium');
  });
});
