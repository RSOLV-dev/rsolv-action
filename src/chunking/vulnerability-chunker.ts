/**
 * RFC-046: Multi-file Vulnerability Chunking Implementation
 */

import {
  ChunkingConfig,
  VulnerabilityFile,
  MultiFileVulnerability,
  Chunk,
  ChunkingStrategy,
  TOKENS_PER_LINE,
  TOKENS_PER_FILE_OVERHEAD,
  MAX_SAFE_TOKENS
} from './types';

/**
 * Strategy for grouping files by module/directory
 */
class ModuleGroupingStrategy implements ChunkingStrategy {
  name = 'module_grouping';

  async group(files: VulnerabilityFile[]): Promise<VulnerabilityFile[][]> {
    const groups = new Map<string, VulnerabilityFile[]>();
    
    for (const file of files) {
      // Extract module from path (first directory or root)
      const parts = file.path.split('/');
      const module = parts.length > 1 ? parts[0] : 'root';
      
      if (!groups.has(module)) {
        groups.set(module, []);
      }
      groups.get(module)!.push(file);
    }
    
    return Array.from(groups.values());
  }
}

/**
 * Strategy for grouping files by severity
 */
class SeverityBasedStrategy implements ChunkingStrategy {
  name = 'severity_based';
  
  async group(files: VulnerabilityFile[]): Promise<VulnerabilityFile[][]> {
    const severityOrder = ['CRITICAL', 'HIGH', 'MEDIUM', 'LOW'];
    const groups = new Map<string, VulnerabilityFile[]>();
    
    // Initialize groups
    severityOrder.forEach(severity => groups.set(severity, []));
    
    // Group files by severity
    for (const file of files) {
      groups.get(file.severity)!.push(file);
    }
    
    // Return non-empty groups in priority order
    return severityOrder
      .map(severity => groups.get(severity)!)
      .filter(group => group.length > 0);
  }
}

/**
 * Strategy for analyzing and grouping by dependencies
 */
class DependencyAnalysisStrategy implements ChunkingStrategy {
  name = 'dependency_analysis';
  
  async group(files: VulnerabilityFile[]): Promise<VulnerabilityFile[][]> {
    const groups: VulnerabilityFile[][] = [];
    const processed = new Set<string>();
    
    for (const file of files) {
      if (processed.has(file.path)) continue;
      
      const group = [file];
      processed.add(file.path);
      
      // Find files that import this file or are imported by it
      if (file.imports) {
        for (const importPath of file.imports) {
          const importedFile = files.find(f => 
            f.path === importPath || 
            f.path === importPath + '.js' ||
            f.path === importPath.replace('./', '') + '.js' ||
            f.path === importPath.replace('./', '')
          );
          
          if (importedFile && !processed.has(importedFile.path)) {
            group.push(importedFile);
            processed.add(importedFile.path);
          }
        }
      }
      
      // Check if other files import this one
      for (const otherFile of files) {
        if (processed.has(otherFile.path)) continue;
        
        if (otherFile.imports?.some(imp => 
          file.path.includes(imp.replace('./', '')) ||
          file.path === imp + '.js'
        )) {
          group.push(otherFile);
          processed.add(otherFile.path);
        }
      }
      
      groups.push(group);
    }
    
    // Add any remaining ungrouped files
    const ungrouped = files.filter(f => !processed.has(f.path));
    if (ungrouped.length > 0) {
      groups.push(ungrouped);
    }
    
    return groups;
  }
}

/**
 * Main vulnerability chunking implementation
 */
export class VulnerabilityChunker {
  private strategies: Map<string, ChunkingStrategy>;
  
  constructor(private config: ChunkingConfig) {
    this.strategies = new Map();
    this.strategies.set('module_grouping', new ModuleGroupingStrategy());
    this.strategies.set('severity_based', new SeverityBasedStrategy());
    this.strategies.set('dependency_analysis', new DependencyAnalysisStrategy());
  }

  async chunkVulnerability(vulnerability: MultiFileVulnerability): Promise<Chunk[]> {
    const { files } = vulnerability;
    const chunks: Chunk[] = [];
    
    // Try intelligent grouping first
    const groupedFiles = await this.groupFilesByStrategy(files);
    
    // Now split groups into chunks respecting size limits
    let chunkIndex = 0;
    
    for (const group of groupedFiles) {
      let currentChunkFiles: VulnerabilityFile[] = [];
      let currentTokens = 0;
      
      for (const file of group) {
        const fileTokens = this.estimateTokens([file]);
        
        // Check if adding this file would exceed limits
        const wouldExceedFileLimit = currentChunkFiles.length >= this.config.maxFilesPerChunk;
        const wouldExceedTokenLimit = currentTokens + fileTokens > this.config.maxContextTokens;
        
        if (currentChunkFiles.length > 0 && (wouldExceedFileLimit || wouldExceedTokenLimit)) {
          // Save current chunk and start a new one
          chunks.push({
            index: chunkIndex++,
            files: currentChunkFiles,
            estimatedTokens: currentTokens,
            vulnerabilityType: vulnerability.type
          });
          
          currentChunkFiles = [];
          currentTokens = 0;
        }
        
        currentChunkFiles.push(file);
        currentTokens += fileTokens;
      }
      
      // Add remaining files as a chunk
      if (currentChunkFiles.length > 0) {
        chunks.push({
          index: chunkIndex++,
          files: currentChunkFiles,
          estimatedTokens: currentTokens,
          vulnerabilityType: vulnerability.type
        });
      }
    }
    
    return chunks;
  }

  getStrategy(name: string): ChunkingStrategy {
    const strategy = this.strategies.get(name);
    if (!strategy) {
      throw new Error(`Strategy ${name} not found`);
    }
    return strategy;
  }

  private async groupFilesByStrategy(files: VulnerabilityFile[]): Promise<VulnerabilityFile[][]> {
    // If no special grouping is needed or strategies don't apply,
    // just return all files as a single group to be chunked by size
    if (!this.config.strategies || this.config.strategies.length === 0) {
      return [files];
    }
    
    // Try strategies in order of preference
    const preferredStrategies = this.config.strategies;
    
    for (const strategyName of preferredStrategies) {
      const strategy = this.strategies.get(strategyName);
      if (strategy) {
        const groups = await strategy.group(files);
        if (groups.length > 0) {
          return groups;
        }
      }
    }
    
    // Fallback: all files in one group to be chunked by size limits
    return [files];
  }

  private estimateTokens(files: VulnerabilityFile[]): number {
    return files.reduce((total, file) => {
      const lineTokens = file.lines.length * TOKENS_PER_LINE;
      return total + lineTokens + TOKENS_PER_FILE_OVERHEAD;
    }, 0);
  }
}

// Re-export for use in tests
export { 
  ModuleGroupingStrategy,
  SeverityBasedStrategy,
  DependencyAnalysisStrategy
};