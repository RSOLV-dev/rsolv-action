import { describe, it, expect, beforeEach, vi, spyOn } from 'vitest';
import { ActionConfig, IssueContext } from '../../types/index.js';

// Module-level mocks
let capturedIssueContext: IssueContext | null = null;
let adapterCalls: Array<{ issueContext: IssueContext; analysis: any }> = [];

vi.mock('../../utils/logger.js', () => ({
  Logger: class {
    info = vi.fn();
    warn = vi.fn();
    error = vi.fn();
    debug = vi.fn();
  },
  logger: {
    debug: vi.fn(() => {}),
    info: vi.fn(() => {}),
    warn: vi.fn(() => {}),
    error: vi.fn(() => {})
  }
}));

vi.mock('../analyzer.js', () => ({
  analyzeIssue: vi.fn(() => ({
    complexity: 'medium',
    relatedFiles: ['app/routes/contributions.js'],
    requiresTests: false,
    suggestedApproach: 'Replace eval with parseInt'
  }))
}));

vi.mock('../adapters/claude-code-git.js', () => ({
  GitBasedClaudeCodeAdapter: class {
    constructor() {}
    async generateSolution(issueContext: any, analysis: any) {
      capturedIssueContext = issueContext;
      adapterCalls.push({ issueContext, analysis });
      return {
        success: true,
        message: 'Fixed',
        filesModified: ['app/routes/contributions.js'],
        commitHash: 'abc123'
      };
    }
  }
}));

vi.mock('../git-based-test-validator.js', () => ({
  GitBasedTestValidator: class {
    async validateFix() {
      return { success: true };
    }
  }
}));

vi.mock('../git-based-processor.js', () => ({
  processIssueWithGit: vi.fn(async (issue: IssueContext, config: ActionConfig) => {
    // Capture the issue context
    capturedIssueContext = issue;
    adapterCalls.push({ issueContext: issue, analysis: {} });
    return {
      success: true,
      message: 'Fixed via git-based processing',
      pullRequestUrl: 'https://github.com/test/repo/pull/1'
    };
  })
}));

// Import after mocks are set up
import { processIssues } from '../unified-processor.js';

describe('Unified Processor - specificVulnerabilities data flow', () => {
  
  beforeEach(() => {
    // Reset captured data
    capturedIssueContext = null;
    adapterCalls = [];
  });

  it('should pass specificVulnerabilities from issue context to Claude adapter', async () => {
    // Arrange: Create issue with specific vulnerabilities
    const issueWithVulnerabilities: IssueContext = {
      number: 301,
      title: 'Insecure deserialization vulnerability',
      body: 'eval() usage detected',
      state: 'open',
      labels: ['rsolv:automate'],
      specificVulnerabilities: [
        {
          file: 'app/routes/contributions.js',
          line: 32,
          message: 'Unsafe eval usage',
          snippet: 'const preTax = eval(req.body.preTax);',
          remediation: 'Use parseInt() instead',
          confidence: 'high'
        }
      ]
    };

    const config: ActionConfig = {
      mode: 'mitigate',
      aiProvider: {
        provider: 'claude-code',
        model: 'claude-3',
        apiKey: 'test-key'
      },
      workingDir: '/tmp/test',
      useGitBasedEditing: true
    };

    // Act: Process the issue
    const results = await processIssues([issueWithVulnerabilities], config);

    // Assert: Verify specificVulnerabilities was passed through
    expect(capturedIssueContext).toBeTruthy();
    expect(capturedIssueContext.specificVulnerabilities).toBeDefined();
    expect(capturedIssueContext.specificVulnerabilities).toHaveLength(1);
    expect(capturedIssueContext.specificVulnerabilities[0].file).toBe('app/routes/contributions.js');
    expect(capturedIssueContext.specificVulnerabilities[0].line).toBe(32);
    expect(capturedIssueContext.specificVulnerabilities[0].remediation).toBe('Use parseInt() instead');
    
    // Also verify the result
    expect(results).toHaveLength(1);
    expect(results[0].success).toBe(true);
  });

  it('should preserve specificVulnerabilities through TDD validator flow', async () => {
    // This test verifies the data flows through when using TDD validation
    const issueWithVulnerabilities: IssueContext = {
      number: 302,
      title: 'XSS vulnerability',
      body: 'Unescaped output',
      state: 'open',
      labels: ['rsolv:automate'],
      specificVulnerabilities: [
        {
          file: 'views/index.pug',
          line: 15,
          message: 'Unescaped user input',
          snippet: '!{userInput}',
          remediation: 'Use escaped output: #{userInput}',
          confidence: 'high'
        }
      ]
    };

    const config: ActionConfig = {
      mode: 'mitigate',
      aiProvider: {
        provider: 'claude-code',
        model: 'claude-3',
        apiKey: 'test-key'
      },
      workingDir: '/tmp/test',
      useGitBasedEditing: true,
      validation: {
        enabled: true,
        useTDD: true
      }
    };

    // Act
    const results = await processIssues([issueWithVulnerabilities], config);

    // Assert: Check all adapter calls preserved specificVulnerabilities
    expect(adapterCalls.length).toBeGreaterThan(0);
    
    for (const call of adapterCalls) {
      expect(call.issueContext.specificVulnerabilities).toBeDefined();
      expect(call.issueContext.specificVulnerabilities).toHaveLength(1);
      expect(call.issueContext.specificVulnerabilities[0].file).toBe('views/index.pug');
      expect(call.issueContext.specificVulnerabilities[0].remediation).toContain('escaped output');
    }
    
    expect(results[0].success).toBe(true);
  });
});