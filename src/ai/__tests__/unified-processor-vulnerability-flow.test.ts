import { describe, it, expect, beforeEach, mock, spyOn } from 'bun:test';
import { processIssues } from '../unified-processor.js';
import { ActionConfig, IssueContext } from '../../types/index.js';

describe('Unified Processor - specificVulnerabilities data flow', () => {
  let mockClaudeAdapter: any;
  let mockAnalyzer: any;
  
  beforeEach(() => {
    // Reset all mocks
    mock.restore();
    
    // Mock the logger
    mock.module('../../utils/logger.js', () => ({
      logger: {
        info: mock(() => {}),
        warn: mock(() => {}),
        error: mock(() => {}),
        debug: mock(() => {})
      }
    }));
  });

  it('should pass specificVulnerabilities from issue context to Claude adapter', async () => {
    // Arrange: Create issue with specific vulnerabilities
    const issueWithVulnerabilities: IssueContext = {
      number: 301,
      title: 'Insecure deserialization vulnerability',
      body: 'eval() usage detected',
      state: 'open',
      labels: ['rsolv:automate'],
      specificVulnerabilities: [
        {
          file: 'app/routes/contributions.js',
          line: 32,
          message: 'Unsafe eval usage',
          snippet: 'const preTax = eval(req.body.preTax);',
          remediation: 'Use parseInt() instead',
          confidence: 'high'
        }
      ]
    };

    const config: ActionConfig = {
      mode: 'mitigate',
      aiProvider: {
        model: 'claude-3',
        apiKey: 'test-key'
      },
      workingDir: '/tmp/test'
    };

    // Mock the analyzer to return simple analysis
    mock.module('../analyzer.js', () => ({
      analyzeIssue: mock(() => ({
        complexity: 'medium',
        relatedFiles: ['app/routes/contributions.js'],
        requiresTests: false,
        suggestedApproach: 'Replace eval with parseInt'
      }))
    }));

    // Mock the GitBasedClaudeCodeAdapter to capture what it receives
    let capturedIssueContext: any = null;
    mock.module('../adapters/claude-code-git.js', () => ({
      GitBasedClaudeCodeAdapter: class {
        constructor() {}
        async generateSolution(issueContext: any, analysis: any) {
          capturedIssueContext = issueContext;
          return {
            success: true,
            message: 'Fixed',
            filesModified: ['app/routes/contributions.js'],
            commitHash: 'abc123'
          };
        }
      }
    }));

    // Act: Process the issue
    const results = await processIssues([issueWithVulnerabilities], config);

    // Assert: Verify specificVulnerabilities was passed through
    expect(capturedIssueContext).toBeTruthy();
    expect(capturedIssueContext.specificVulnerabilities).toBeDefined();
    expect(capturedIssueContext.specificVulnerabilities).toHaveLength(1);
    expect(capturedIssueContext.specificVulnerabilities[0].file).toBe('app/routes/contributions.js');
    expect(capturedIssueContext.specificVulnerabilities[0].line).toBe(32);
    expect(capturedIssueContext.specificVulnerabilities[0].remediation).toBe('Use parseInt() instead');
    
    // Also verify the result
    expect(results).toHaveLength(1);
    expect(results[0].success).toBe(true);
  });

  it('should preserve specificVulnerabilities through TDD validator flow', async () => {
    // This test verifies the data flows through when using TDD validation
    const issueWithVulnerabilities: IssueContext = {
      number: 302,
      title: 'XSS vulnerability',
      body: 'Unescaped output',
      state: 'open',
      labels: ['rsolv:automate'],
      specificVulnerabilities: [
        {
          file: 'views/index.pug',
          line: 15,
          message: 'Unescaped user input',
          snippet: '!{userInput}',
          remediation: 'Use escaped output: #{userInput}',
          confidence: 'high'
        }
      ]
    };

    const config: ActionConfig = {
      mode: 'mitigate',
      aiProvider: {
        model: 'claude-3',
        apiKey: 'test-key'
      },
      workingDir: '/tmp/test',
      validation: {
        enabled: true,
        useTDD: true
      }
    };

    // Track all adapter calls
    const adapterCalls: any[] = [];
    
    // Mock validator
    mock.module('../git-based-test-validator.js', () => ({
      GitBasedTestValidator: class {
        async validateFix() {
          return { success: true };
        }
      }
    }));

    // Mock adapter to track calls
    mock.module('../adapters/claude-code-git.js', () => ({
      GitBasedClaudeCodeAdapter: class {
        constructor() {}
        async generateSolution(issueContext: any, analysis: any) {
          adapterCalls.push({ issueContext, analysis });
          return {
            success: true,
            message: 'Fixed',
            filesModified: ['views/index.pug'],
            commitHash: 'def456'
          };
        }
      }
    }));

    // Mock analyzer
    mock.module('../analyzer.js', () => ({
      analyzeIssue: mock(() => ({
        complexity: 'low',
        relatedFiles: ['views/index.pug'],
        requiresTests: true,
        suggestedApproach: 'Escape output'
      }))
    }));

    // Act
    const results = await processIssues([issueWithVulnerabilities], config);

    // Assert: Check all adapter calls preserved specificVulnerabilities
    expect(adapterCalls.length).toBeGreaterThan(0);
    
    for (const call of adapterCalls) {
      expect(call.issueContext.specificVulnerabilities).toBeDefined();
      expect(call.issueContext.specificVulnerabilities).toHaveLength(1);
      expect(call.issueContext.specificVulnerabilities[0].file).toBe('views/index.pug');
      expect(call.issueContext.specificVulnerabilities[0].remediation).toContain('escaped output');
    }
    
    expect(results[0].success).toBe(true);
  });
});