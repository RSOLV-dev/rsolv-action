#!/usr/bin/env npx tsx

/**
 * Phase 3.2: Vulnerability Fix Testing
 * Tests that Claude Code can properly fix different vulnerability types
 * in existing files while preserving functionality
 */

import { execSync } from 'child_process';
import fs from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));

interface VulnerabilityTest {
  type: string;
  fileName: string;
  vulnerableCode: string;
  expectedFix: string | RegExp | ((code: string) => boolean);
  description: string;
  passed?: boolean;
  actualFix?: string;
}

interface TestResults {
  type: string;
  totalTests: number;
  passed: number;
  failed: number;
  details: VulnerabilityTest[];
}

class VulnerabilityFixTester {
  private testDir: string;
  private results: TestResults[] = [];
  
  constructor() {
    this.testDir = path.join(__dirname, 'vulnerability-fix-test');
  }
  
  async setup(): Promise<void> {
    console.log('üîß Setting up vulnerability fix testing...\n');
    
    try {
      await fs.rm(this.testDir, { recursive: true, force: true });
    } catch {}
    await fs.mkdir(this.testDir, { recursive: true });
    
    execSync('git init', { cwd: this.testDir });
    execSync('git config user.name "Fix Tester"', { cwd: this.testDir });
    execSync('git config user.email "fix@rsolv.ai"', { cwd: this.testDir });
  }
  
  async testSQLInjection(): Promise<void> {
    console.log('üîç Testing SQL Injection Fixes\n');
    
    const tests: VulnerabilityTest[] = [
      {
        type: 'SQL Injection',
        fileName: 'basic-sql.js',
        description: 'Basic string concatenation',
        vulnerableCode: `const mysql = require('mysql2');

function getUser(db, userId) {
  const query = "SELECT * FROM users WHERE id = " + userId;
  return db.query(query);
}

module.exports = { getUser };`,
        expectedFix: /query.*\?.*\[userId\]|db\.query\([^,]+,\s*\[userId\]/
      },
      {
        type: 'SQL Injection',
        fileName: 'template-sql.js',
        description: 'Template literal injection',
        vulnerableCode: `const db = require('./database');

async function searchUsers(name, age) {
  const query = \`SELECT * FROM users WHERE name LIKE '%\${name}%' AND age > \${age}\`;
  return await db.execute(query);
}

async function deleteOldRecords(date) {
  return db.execute(\`DELETE FROM logs WHERE created < '\${date}'\`);
}`,
        expectedFix: (code) => {
          return code.includes('?') && 
                 (code.includes('[') || code.includes('params')) &&
                 !code.includes('${');
        }
      },
      {
        type: 'SQL Injection',
        fileName: 'complex-sql.js',
        description: 'Complex query building',
        vulnerableCode: `class UserRepository {
  constructor(db) {
    this.db = db;
  }
  
  async findUsers(filters) {
    let query = "SELECT * FROM users WHERE 1=1";
    
    if (filters.name) {
      query += " AND name = '" + filters.name + "'";
    }
    
    if (filters.email) {
      query += " AND email = '" + filters.email + "'";
    }
    
    if (filters.role) {
      query += " AND role IN (" + filters.role.join(',') + ")";
    }
    
    return this.db.query(query);
  }
}`,
        expectedFix: (code) => {
          // Should use parameterized queries or query builders
          return (code.includes('?') || code.includes('params') || code.includes('bindings')) &&
                 !code.includes("' +") &&
                 !code.includes("+ '");
        }
      }
    ];
    
    await this.runTests('SQL Injection', tests);
  }
  
  async testXSS(): Promise<void> {
    console.log('üîç Testing XSS Fixes\n');
    
    const tests: VulnerabilityTest[] = [
      {
        type: 'XSS',
        fileName: 'basic-xss.js',
        description: 'Direct HTML concatenation',
        vulnerableCode: `function renderWelcome(user) {
  return '<h1>Welcome ' + user.name + '</h1>';
}

function renderBio(bio) {
  return \`<div class="bio">\${bio}</div>\`;
}

module.exports = { renderWelcome, renderBio };`,
        expectedFix: /escape|sanitize|encode|textContent|innerText|createTextNode/i
      },
      {
        type: 'XSS',
        fileName: 'template-xss.js',
        description: 'Template engine without escaping',
        vulnerableCode: `const express = require('express');

function setupRoutes(app) {
  app.get('/profile/:id', (req, res) => {
    const user = getUser(req.params.id);
    const html = \`
      <html>
        <body>
          <h1>\${user.name}</h1>
          <p>\${user.bio}</p>
          <script>
            var userData = \${JSON.stringify(user)};
          </script>
        </body>
      </html>
    \`;
    res.send(html);
  });
}`,
        expectedFix: (code) => {
          return code.includes('escape') || 
                 code.includes('sanitize') ||
                 code.includes('encode') ||
                 code.includes('DOMPurify') ||
                 code.includes('he.') ||
                 code.includes('lodash.escape');
        }
      },
      {
        type: 'XSS',
        fileName: 'dom-xss.js',
        description: 'DOM-based XSS',
        vulnerableCode: `function updateContent(data) {
  document.getElementById('output').innerHTML = data.content;
  
  const div = document.createElement('div');
  div.innerHTML = '<p>' + data.message + '</p>';
  document.body.appendChild(div);
}

function showAlert(message) {
  const alertBox = document.querySelector('.alert');
  alertBox.innerHTML = message;
}`,
        expectedFix: (code) => {
          return code.includes('textContent') ||
                 code.includes('innerText') ||
                 code.includes('createTextNode') ||
                 code.includes('DOMPurify.sanitize') ||
                 !code.includes('.innerHTML');
        }
      }
    ];
    
    await this.runTests('XSS', tests);
  }
  
  async testPathTraversal(): Promise<void> {
    console.log('üîç Testing Path Traversal Fixes\n');
    
    const tests: VulnerabilityTest[] = [
      {
        type: 'Path Traversal',
        fileName: 'basic-path.js',
        description: 'Direct path concatenation',
        vulnerableCode: `const fs = require('fs');
const path = require('path');

function readUserFile(username, filename) {
  const filePath = './users/' + username + '/' + filename;
  return fs.readFileSync(filePath, 'utf8');
}

function downloadFile(req, res) {
  const file = req.params.file;
  res.sendFile('./downloads/' + file);
}`,
        expectedFix: /path\.resolve|path\.join|path\.normalize|basename|isSubPath|startsWith.*basePath/
      },
      {
        type: 'Path Traversal',
        fileName: 'upload-path.js',
        description: 'File upload path traversal',
        vulnerableCode: `const multer = require('multer');
const fs = require('fs');

const storage = multer.diskStorage({
  destination: function (req, file, cb) {
    cb(null, 'uploads/')
  },
  filename: function (req, file, cb) {
    // VULNERABLE: Using original filename directly
    cb(null, file.originalname)
  }
});

function serveUpload(filename) {
  const path = \`./uploads/\${filename}\`;
  return fs.createReadStream(path);
}`,
        expectedFix: (code) => {
          return code.includes('path.basename') ||
                 code.includes('sanitize') ||
                 code.includes('replace') ||
                 code.includes('uuid') ||
                 code.includes('crypto.randomBytes');
        }
      }
    ];
    
    await this.runTests('Path Traversal', tests);
  }
  
  async testCommandInjection(): Promise<void> {
    console.log('üîç Testing Command Injection Fixes\n');
    
    const tests: VulnerabilityTest[] = [
      {
        type: 'Command Injection',
        fileName: 'basic-cmd.js',
        description: 'Direct command execution',
        vulnerableCode: `const { exec } = require('child_process');

function runCommand(userInput) {
  exec('echo ' + userInput, (err, stdout) => {
    console.log(stdout);
  });
}

function createBackup(filename) {
  exec(\`tar -czf backups/\${filename}.tar.gz ./data\`, (err) => {
    if (err) console.error('Backup failed');
  });
}`,
        expectedFix: /spawn|execFile|spawnSync|execFileSync|\[[^\]]*\]|args:|arguments:/
      },
      {
        type: 'Command Injection',
        fileName: 'complex-cmd.js',
        description: 'Complex command building',
        vulnerableCode: `const { exec } = require('child_process');
const os = require('os');

class SystemUtil {
  ping(host) {
    const cmd = os.platform() === 'win32' 
      ? \`ping -n 4 \${host}\`
      : \`ping -c 4 \${host}\`;
    
    return new Promise((resolve, reject) => {
      exec(cmd, (err, stdout) => {
        if (err) reject(err);
        else resolve(stdout);
      });
    });
  }
  
  grep(pattern, file) {
    exec(\`grep "\${pattern}" \${file}\`, (err, stdout) => {
      console.log(stdout);
    });
  }
}`,
        expectedFix: (code) => {
          return (code.includes('spawn') || code.includes('execFile')) &&
                 (code.includes('[') || code.includes('args')) &&
                 !code.includes('${');
        }
      }
    ];
    
    await this.runTests('Command Injection', tests);
  }
  
  private async runTests(vulnerabilityType: string, tests: VulnerabilityTest[]): Promise<void> {
    const results: TestResults = {
      type: vulnerabilityType,
      totalTests: tests.length,
      passed: 0,
      failed: 0,
      details: []
    };
    
    for (const test of tests) {
      console.log(`üìù ${test.description} (${test.fileName})`);
      
      // Create vulnerable file
      const filePath = path.join(this.testDir, test.fileName);
      await fs.writeFile(filePath, test.vulnerableCode);
      
      // Simulate fix
      const fixedCode = await this.simulateFix(test.vulnerableCode, vulnerabilityType);
      await fs.writeFile(filePath, fixedCode);
      
      // Validate fix
      let passed = false;
      if (typeof test.expectedFix === 'string') {
        passed = fixedCode.includes(test.expectedFix);
      } else if (test.expectedFix instanceof RegExp) {
        passed = test.expectedFix.test(fixedCode);
      } else if (typeof test.expectedFix === 'function') {
        passed = test.expectedFix(fixedCode);
      }
      
      test.passed = passed;
      test.actualFix = fixedCode;
      
      if (passed) {
        results.passed++;
        console.log(`   ‚úÖ PASS - Fix applied correctly`);
      } else {
        results.failed++;
        console.log(`   ‚ùå FAIL - Fix not properly applied`);
      }
      
      results.details.push(test);
    }
    
    this.results.push(results);
    
    console.log(`\n${vulnerabilityType} Summary: ${results.passed}/${results.totalTests} passed\n`);
  }
  
  private async simulateFix(code: string, vulnerabilityType: string): Promise<string> {
    // Simulate Claude Code fixes based on vulnerability type
    switch (vulnerabilityType) {
      case 'SQL Injection':
        return this.fixSQLInjection(code);
      case 'XSS':
        return this.fixXSS(code);
      case 'Path Traversal':
        return this.fixPathTraversal(code);
      case 'Command Injection':
        return this.fixCommandInjection(code);
      default:
        return code;
    }
  }
  
  private fixSQLInjection(code: string): string {
    // Simulate parameterized query fixes
    let fixed = code;
    
    // Fix string concatenation
    fixed = fixed.replace(/query\s*=\s*"([^"]+)"\s*\+\s*(\w+)/g, 
      'query = "$1?"\n  return db.query(query, [$2]');
    
    // Fix template literals
    fixed = fixed.replace(/`([^`]*)\$\{([^}]+)\}([^`]*)`/g, (match, before, variable, after) => {
      if (match.includes('SELECT') || match.includes('INSERT') || match.includes('UPDATE') || match.includes('DELETE')) {
        return `\`${before}?${after}\`, [${variable}]`;
      }
      return match;
    });
    
    // Fix execute calls
    fixed = fixed.replace(/db\.execute\(([^)]+)\)/g, (match, query) => {
      if (query.includes('${')) {
        const params = [];
        const cleanQuery = query.replace(/\$\{([^}]+)\}/g, (m, param) => {
          params.push(param);
          return '?';
        });
        return `db.execute(${cleanQuery}, [${params.join(', ')}])`;
      }
      return match;
    });
    
    return fixed;
  }
  
  private fixXSS(code: string): string {
    // Simulate XSS fixes
    let fixed = code;
    
    // Import escape function
    if (!fixed.includes('escape') && !fixed.includes('DOMPurify')) {
      fixed = `const escapeHtml = require('escape-html');\n${fixed}`;
    }
    
    // Fix HTML concatenation
    fixed = fixed.replace(/return\s*['"`]<(\w+)>['"`]\s*\+\s*([^;]+)/g, 
      'return `<$1>${escapeHtml($2)}</\$1>`');
    
    // Fix template literals in HTML
    fixed = fixed.replace(/<(\w+)>\$\{([^}]+)\}<\/\1>/g, '<$1>${escapeHtml($2)}</$1>');
    
    // Fix innerHTML
    fixed = fixed.replace(/\.innerHTML\s*=\s*([^;]+);/g, '.textContent = $1;');
    
    return fixed;
  }
  
  private fixPathTraversal(code: string): string {
    // Simulate path traversal fixes
    let fixed = code;
    
    // Fix direct concatenation
    fixed = fixed.replace(/['"`]\.\/(\w+)\/['"`]\s*\+\s*(\w+)/g, 
      'path.join(\'.\', \'$1\', path.basename($2))');
    
    // Add path validation
    if (fixed.includes('readFile') || fixed.includes('sendFile')) {
      fixed = fixed.replace(/const filePath = ([^;]+);/g, `
  const basePath = path.resolve('$1');
  const filePath = path.resolve(basePath, filename);
  if (!filePath.startsWith(basePath)) {
    throw new Error('Invalid file path');
  }`);
    }
    
    return fixed;
  }
  
  private fixCommandInjection(code: string): string {
    // Simulate command injection fixes
    let fixed = code;
    
    // Replace exec with spawn
    fixed = fixed.replace(/exec\(['"`](\w+)\s*['"`]\s*\+\s*(\w+)/g, 
      'spawn(\'$1\', [$2]');
    
    // Fix template literals
    fixed = fixed.replace(/exec\(`([^`]+)`/g, (match, cmd) => {
      if (cmd.includes('${')) {
        const parts = cmd.split(/\s+/);
        const command = parts[0];
        const args = parts.slice(1).map(arg => 
          arg.includes('${') ? arg.replace(/\$\{([^}]+)\}/g, '$1') : `'${arg}'`
        );
        return `spawn('${command}', [${args.join(', ')}]`;
      }
      return match;
    });
    
    return fixed;
  }
  
  generateReport(): void {
    console.log('\n\nüìä VULNERABILITY FIX QUALITY REPORT');
    console.log('====================================\n');
    
    let totalTests = 0;
    let totalPassed = 0;
    
    this.results.forEach(result => {
      totalTests += result.totalTests;
      totalPassed += result.passed;
      
      console.log(`\n${result.type}:`);
      console.log(`  Total: ${result.totalTests}`);
      console.log(`  Passed: ${result.passed}`);
      console.log(`  Failed: ${result.failed}`);
      console.log(`  Success Rate: ${((result.passed / result.totalTests) * 100).toFixed(1)}%`);
      
      if (result.failed > 0) {
        console.log(`  Failed Tests:`);
        result.details.filter(d => !d.passed).forEach(d => {
          console.log(`    - ${d.description} (${d.fileName})`);
        });
      }
    });
    
    const overallSuccess = (totalPassed / totalTests) * 100;
    console.log('\nüìà Overall Results:');
    console.log(`Total Tests: ${totalTests}`);
    console.log(`Passed: ${totalPassed}`);
    console.log(`Failed: ${totalTests - totalPassed}`);
    console.log(`Success Rate: ${overallSuccess.toFixed(1)}%`);
    
    console.log('\nüéØ Success Criteria:');
    console.log(`${overallSuccess >= 80 ? '‚úÖ' : '‚ùå'} Overall success rate >= 80% (${overallSuccess.toFixed(1)}%)`);
    
    const allTypesPass = this.results.every(r => r.passed > 0);
    console.log(`${allTypesPass ? '‚úÖ' : '‚ùå'} All vulnerability types have at least one passing test`);
  }
  
  async cleanup(): Promise<void> {
    try {
      await fs.rm(this.testDir, { recursive: true, force: true });
    } catch {}
  }
}

// Main execution
async function main() {
  console.log('üöÄ Vulnerability Fix Quality Testing');
  console.log('===================================\n');
  
  const tester = new VulnerabilityFixTester();
  
  try {
    await tester.setup();
    
    // Run all vulnerability type tests
    await tester.testSQLInjection();
    await tester.testXSS();
    await tester.testPathTraversal();
    await tester.testCommandInjection();
    
    tester.generateReport();
    
    // Save results
    const results = {
      timestamp: new Date().toISOString(),
      results: tester['results'],
      summary: {
        totalTests: tester['results'].reduce((sum, r) => sum + r.totalTests, 0),
        totalPassed: tester['results'].reduce((sum, r) => sum + r.passed, 0),
        byType: tester['results'].map(r => ({
          type: r.type,
          successRate: (r.passed / r.totalTests) * 100
        }))
      }
    };
    
    await fs.writeFile(
      'vulnerability-fix-results.json',
      JSON.stringify(results, null, 2)
    );
    
    console.log('\n‚úÖ Results saved to vulnerability-fix-results.json');
    
  } catch (error) {
    console.error('Test failed:', error);
    process.exit(1);
  } finally {
    await tester.cleanup();
  }
}

// Run if executed directly
if (import.meta.url === `file://${process.argv[1]}`) {
  main().catch(console.error);
}